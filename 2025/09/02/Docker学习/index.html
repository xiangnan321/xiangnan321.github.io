<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker学习 | Hi</title><meta name="author" content="South"><meta name="copyright" content="South"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="阅读《Docker 从入门到实践》 后的简单整理总结 概述Docker是一个用于开发，交付和运行应用程序的开放平台。Docker能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的快速交付，测试和部署代码的方法，可以显着减少编写代码和在生产环境中运行代码之间的延迟。 Docker 使用Google公司推出的 Go">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker学习">
<meta property="og:url" content="https://xiangnan321.github.io/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hi">
<meta property="og:description" content="阅读《Docker 从入门到实践》 后的简单整理总结 概述Docker是一个用于开发，交付和运行应用程序的开放平台。Docker能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的快速交付，测试和部署代码的方法，可以显着减少编写代码和在生产环境中运行代码之间的延迟。 Docker 使用Google公司推出的 Go">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiangnan321.github.io/image/avatar.png">
<meta property="article:published_time" content="2025-09-02T08:18:48.000Z">
<meta property="article:modified_time" content="2025-10-11T04:07:21.894Z">
<meta property="article:author" content="South">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiangnan321.github.io/image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker学习",
  "url": "https://xiangnan321.github.io/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/",
  "image": "https://xiangnan321.github.io/image/avatar.png",
  "datePublished": "2025-09-02T08:18:48.000Z",
  "dateModified": "2025-10-11T04:07:21.894Z",
  "author": [
    {
      "@type": "Person",
      "name": "South",
      "url": "https://xiangnan321.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/image/logo.png"><link rel="canonical" href="https://xiangnan321.github.io/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: South","link":"链接: ","source":"来源: Hi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/styles.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/logo.png" alt="Logo"><span class="site-name">Hi</span></a><a class="nav-page-title" href="/"><span class="site-name">Docker学习</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Docker学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-02T08:18:48.000Z" title="发表于 2025-09-02 16:18:48">2025-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-11T04:07:21.894Z" title="更新于 2025-10-11 12:07:21">2025-10-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>阅读<a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/">《Docker 从入门到实践》</a> 后的简单整理总结</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Docker是一个用于开发，交付和运行应用程序的开放平台。Docker能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的快速交付，测试和部署代码的方法，可以显着减少编写代码和在生产环境中运行代码之间的延迟。</p>
<p>Docker 使用<code>Google</code>公司推出的 Go 语言 进行开发实现，基于<code>Linux</code>内核的 cgroup ，namespace ，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术 。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC ，从<code>0.7</code>版本以后开始去除<code>LXC</code>，转而使用自行开发的 libcontainer ，从<code>1.11</code>版本开始，则进一步演进为使用 runC 和 containerd 。</p>
<h3 id="Docker架构概述"><a href="#Docker架构概述" class="headerlink" title="Docker架构概述"></a>Docker架构概述</h3><h4 id="Docker在Linux环境下的架构"><a href="#Docker在Linux环境下的架构" class="headerlink" title="Docker在Linux环境下的架构"></a>Docker在Linux环境下的架构</h4><p><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-01.png" alt="Docker架构概述"><br><strong>Docker客户端工具层</strong><br>用于与Docker Engine交互和管理容器化应用。</p>
<ul>
<li>Docker客户端(Docker Client): 用于与Docker守护进程（Docker Engine）进行通信，发送命令来管理容器、镜像等。</li>
<li>Docker Compose: 用于定义和运行多容器Docker应用程序的工具。</li>
<li>Docker Registry: 存储Docker镜像的仓库，如Docker Hub。</li>
<li>Docker Swarm: 用于管理Docker集群，实现容器编排和扩展。</li>
</ul>
<p><strong>Docker Engine层</strong> </p>
<ul>
<li>REST接口(REST Interface): Docker Engine通过RESTful API暴露其功能，供客户端工具调用。</li>
<li>Docker Engine: Docker的核心组件，负责构建、运行和管理容器。</li>
<li>libcontainerd, libnetwork, graph, plugins: Docker Engine内部的模块，分别负责容器运行时管理、网络管理、镜像管理和插件扩展。</li>
</ul>
<p><strong>容器运行时层</strong></p>
<ul>
<li>containerd + runc: <code>containerd</code>是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。<code>runc</code>是一个 Linux 命令行工具，用于根据 OCI容器运行时规范创建和运行容器。</li>
</ul>
<p><strong>操作系统层</strong><br>操作系统(Operating System): Docker依赖于操作系统的底层功能来实现容器化。 为容器提供资源隔离和文件系统管理。 </p>
<ul>
<li>控制组(Control Groups - cgroups): 用于限制、记录和隔离进程组的资源使用（如CPU、内存、I&#x2F;O）。</li>
<li>命名空间(Namespaces - Pid, net, ipc, mnt, uts): 提供进程隔离，使每个容器拥有独立的进程ID、网络、IPC、挂载点和主机名等。</li>
<li>分层能力(Layer Capabilities): 利用联合文件系统（如AUFS, btrfs, vfs, zfs, DeviceMapper）实现镜像的分层存储和共享。</li>
<li>其他操作系统功能(Other OS Functionality): Docker还利用了操作系统的其他功能来实现容器的运行和管理。</li>
</ul>
<p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得<code>Docker</code>技术比虚拟机技术更为轻便、快捷。</p>
<p>下图比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-02.webp" alt="Virtual Machines"><br><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-03.webp" alt="Docker"></p>
<h4 id="Docker-工作原理与组件交互"><a href="#Docker-工作原理与组件交互" class="headerlink" title="Docker 工作原理与组件交互"></a>Docker 工作原理与组件交互</h4><p><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-04.svg" alt="Docker 架构"><br><strong>客户端（Client）</strong>：用户通过<code>docker build</code>、<code>docker pull</code>和<code>docker run</code>等命令与Docker守护进程（Docker daemon）进行交互，执行容器操作。</p>
<p><strong>Docker宿主机（DOCKER_HOST）</strong>：包含Docker守护进程（Docker daemon），负责管理容器（Containers）和镜像（Images）。它从镜像创建并运行容器。</p>
<p><strong>Docker守护进程(Docker Daemon)</strong>：在主机上运行的核心组件，负责管理<strong>Docker容器</strong>的<strong>生命周期</strong>，包括构建、运行、分发容器等。</p>
<p><strong>镜像（Images）</strong>：是只读的模板，用于创建Docker容器，其中包含了应用程序及其运行所需的所有依赖项。</p>
<p><strong>注册中心（Registry）</strong>：是存储和分发Docker镜像的地方，例如Docker Hub，用户可以从中拉取（pull）或推送（push）镜像。</p>
<h3 id="为什么使用Docker"><a href="#为什么使用Docker" class="headerlink" title="为什么使用Docker"></a>为什么使用Docker</h3><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<ul>
<li><strong>更高效的利用系统资源。</strong><ul>
<li>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</li>
</ul>
</li>
<li><strong>更快速的启动时间。</strong><ul>
<li>传统的虚拟机技术启动应用服务往往需要数分钟，而<code>Docker</code>容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</li>
</ul>
</li>
<li><strong>一致的运行环境</strong><ul>
<li>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而<code>Docker</code>的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</li>
</ul>
</li>
<li><strong>持续交付和部署</strong><ul>
<li>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</li>
<li>使用<code>Docker</code>可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过<strong>Dockerfile</strong>来进行镜像构建，并结合 **持续集成(Continuous Integration)**系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 **持续部署(Continuous Delivery&#x2F;Deployment)**系统进行自动部署。</li>
<li>使用<code>Dockerfile</code>使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</li>
</ul>
</li>
<li><strong>更轻松的迁移</strong><ul>
<li>由于<code>Docker</code>确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code>可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</li>
</ul>
</li>
<li><strong>更轻松的维护和扩展</strong><ul>
<li><code>Docker</code>使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code>团队同各个开源项目团队一起维护了一大批高质量的 <strong>官方镜像</strong>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</li>
</ul>
</li>
<li><strong>对比传统虚拟机总结</strong><table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为<code>MB</code></td>
<td>一般为<code>GB</code></td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（<code>Image</code>）</h3><p>操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker</strong> 镜像（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 <code>Ubuntu 18.04</code> 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像</strong> 一个<strong>只读的模板</strong>，是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p>
<h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 <strong>Docker</strong> 设计时，就充分利用 <strong>Union FS</strong> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h4 id="核心概念：镜像的唯一标识"><a href="#核心概念：镜像的唯一标识" class="headerlink" title="核心概念：镜像的唯一标识"></a>核心概念：镜像的唯一标识</h4><p>首先，要明白一个 Docker 镜像<strong>不是通过一个名字，而是通过其加密哈希值（Image ID）来唯一标识的</strong>。像 <code>nginx:latest</code> 这样的标签（Tag）只是一个对人类友好的、可变的别名，它<strong>指向</strong>某个特定的 Image ID。</p>
<ul>
<li><code>nginx:latest</code> -&gt; (指向) -&gt; <code>镜像A（ID: abcd1234...）</code></li>
<li>如果发布了新版本，<code>nginx:latest</code> 可以改为指向 -&gt; <code>镜像B（ID: efgh5678...）</code><br>同一个镜像可以有多个标签（即多个名字），例如：<br>一个镜像既可以叫 <code>my-app:version1.0</code>，也可以同时叫 <code>my-app:latest</code>。这两个标签指向的是同一个 Image ID。</li>
</ul>
<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（<code>Container</code>）</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <strong>命名空间</strong> 。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 <strong>ID</strong> 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全</p>
<p>镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 <strong>Docker</strong> 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <strong>数据卷（Volume）</strong>、或者 <strong>绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="仓库（Docker-Repository）"><a href="#仓库（Docker-Repository）" class="headerlink" title="仓库（Docker Repository）"></a>仓库（<code>Docker Repository</code>）</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，如果需要在其它服务器上使用这个镜像，就需要一个集中的存储、分发镜像的服务，<code>Docker Registry</code> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <code>Ubuntu 镜像</code>为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 <strong>Docker Registry</strong> 多用户环境下的用户名，后者则往往是对应的软件名。</p>
<h4 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h4><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。</p>
<p>常用的有：官方的 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>,这也是默认的 Registry；Red Hat 的 <a href="">Quay.io</a>；Google 的 <a target="_blank" rel="noopener" href="https://quay.io/repository/">Google Container Registry</a>，<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a>的镜像使用的就是这个服务；代码托管平台 GitHub推出的 <a target="_blank" rel="noopener" href="https://docs.github.com/zh/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io</a>。</p>
<p>国内的有： <a target="_blank" rel="noopener" href="https://c.163.com/hub#/m/library/">网易云镜像服务</a>、<a target="_blank" rel="noopener" href="https://hub.daocloud.io/">DaoCloud 镜像市场</a>、<a target="_blank" rel="noopener" href="https://cn.aliyun.com/product/acr?from_alibabacloud=">阿里云镜像库</a>等。</p>
<h4 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h4><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/registry/">Docker Registry</a>镜像，可以直接使用做为私有 Registry 服务。</p>
<h2 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>使用<code>docker pull</code>命令可以从 Docker 镜像仓库获取镜像，格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<p>选项可以使用<code>docker pull --help</code>命令查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull --<span class="built_in">help</span></span><br><span class="line">Usage:  docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">Download an image from a registry</span><br><span class="line"></span><br><span class="line">Aliases:</span><br><span class="line">  docker image pull, docker pull</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images <span class="keyword">in</span> the repository <span class="comment"># 下载仓库中所有带标签的镜像</span></span><br><span class="line">      --disable-content-trust   Skip image verification (default <span class="literal">true</span>) <span class="comment"># 跳过镜像验证（默认 true）</span></span><br><span class="line">      --platform string         Set platform <span class="keyword">if</span> server is multi-platform capable <span class="comment"># 如果服务器支持多平台，则设置平台</span></span><br><span class="line">  -q, --quiet                   Suppress verbose output <span class="comment"># 抑制详细输出</span></span><br></pre></td></tr></table></figure>
<p>镜像名称的格式:</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 <strong>Docker Hub</strong>(<code>docker.io</code>)。</li>
<li>仓库名：这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 <strong>Docker Hub</strong>，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>docker run</code> 命令，以镜像为基础启动并运行一个容器。格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run [选项] IMAGE [命令] [参数...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash</span><br><span class="line"></span><br><span class="line">$ docker run -dp 3000:3000 getting-started</span><br></pre></td></tr></table></figure>
<p>命令解释：</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 <strong>Shell</strong>，因此用的是 <code>bash</code>。</li>
<li><code>-d</code>：<strong>detach</strong>，即分离模式，后台运行容器,后台运行（守护模式）</li>
<li><code>-p [宿主机端口]:[容器端口]</code>：端口映射，将容器的端口映射到宿主机上</li>
<li><code>--name</code>：为容器指定一个名字</li>
<li><code>-v [宿主机目录]:[容器目录]</code>：挂载数据卷，实现数据持久化</li>
<li><code>-it</code>：交互模式运行（通常与 <code>/bin/bash</code> 连用）</li>
</ul>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p><code>docker image ls</code>命令 列出所有镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line">ubuntu               18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu               bionic              329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>
<p>列表包含 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<ul>
<li><strong>镜像 ID</strong> 是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。</li>
<li><strong>镜像摘要</strong> 是镜像的哈希值，可以用来验证镜像是否被篡改。也是唯一标识。</li>
</ul>
<h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>63.3MB</code>，但是在 <a target="_blank" rel="noopener" href="https://hub.docker.com/layers/library/ubuntu/bionic/images/sha256-32776cc92b5810ce72e77aca1d949de1f348e1d281d3f00ebcc22a3adcdc9f42">Docker Hub</a>显示的却是 <code>25.47 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 <strong>Docker</strong> 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 <strong>Docker</strong> 使用 <strong>Union FS</strong>，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker system <span class="built_in">df</span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          13        10        2.566GB   1.732GB (67%)</span><br><span class="line">Containers      37        18        860.2kB   442.4kB (51%)</span><br><span class="line">Local Volumes   2         0         1.523GB   1.523GB (100%)</span><br><span class="line">Build Cache     9         0         737MB     737MB</span><br></pre></td></tr></table></figure>

<h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>
<p><code>docker pull</code> 和 <code>docker build</code> 都可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为   的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用<code>docker image prune</code>命令删除。</p>
<h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，<strong>Docker</strong> 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure>
<p>这样会看到很多无标签的镜像，与虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p>
<ul>
<li>根据仓库名列出镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu              bionic              329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>
<ul>
<li>列出特定的某个镜像，也就是说指定仓库名和标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu:18.04</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>
<ul>
<li><code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前已经使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span> -f since=mongo:3.2</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</span><br></pre></td></tr></table></figure>
<p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p>
<p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f label=com.example.version=0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h4><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 <strong>ID</strong> 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -q</span><br><span class="line">674181320f4f</span><br><span class="line">9abc6cf6aea7</span><br><span class="line">fdd1722efdcc</span><br><span class="line">c47449f3e751</span><br><span class="line">399aa50f4d13</span><br></pre></td></tr></table></figure>
<p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 <strong>ID</strong> 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 <strong>Docker</strong> 命令行使用过程中非常常见。</p>
<p>使用<a target="_blank" rel="noopener" href="https://gohugo.io/templates/introduction/">Go 的模板语法</a>可以重构返回的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span></span><br><span class="line">674181320f4f: node</span><br><span class="line">9abc6cf6aea7: prom/prometheus</span><br><span class="line">fdd1722efdcc: docker/desktop-kubernetes</span><br><span class="line">115d77efe6e2: docker/desktop-storage-provisioner</span><br><span class="line">141c253bc4c3: busybox</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以表格等距显示，并且有标题行，和默认一样，不过自己定义列</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> --format <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span></span><br><span class="line">IMAGE ID       REPOSITORY                                TAG</span><br><span class="line">674181320f4f   node                                      20-alpine</span><br><span class="line">9abc6cf6aea7   prom/prometheus                           latest</span><br><span class="line">7ecf567ea070   docker/desktop-vpnkit-controller          dc331cb22850be0cdd97c84a9cfecaf44a1afb6e</span><br><span class="line">115d77efe6e2   docker/desktop-storage-provisioner        v2.0</span><br><span class="line">141c253bc4c3   busybox                                   1.28</span><br></pre></td></tr></table></figure>

<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>使用 <code>docker image rm</code> 命令删除本地的镜像。格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>

<h4 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h4><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                                TAG                    IMAGE ID       CREATED         SIZE</span><br><span class="line">node                                      20-alpine              674181320f4f   2 months ago    191MB</span><br><span class="line">prom/prometheus                           latest                 9abc6cf6aea7   3 months ago    411MB</span><br><span class="line">registry.k8s.io/coredns/coredns           v1.11.3                9caabbf6238b   13 months ago   81.8MB</span><br><span class="line">registry.k8s.io/pause                     3.10                   ee6521f290b2   15 months ago   786kB</span><br><span class="line">docker/desktop-storage-provisioner        v2.0                   115d77efe6e2   4 years ago     56MB</span><br><span class="line">busybox                                   1.28                   141c253bc4c3   7 years ago     2.14MB</span><br></pre></td></tr></table></figure>
<p>可以用镜像的完整 <strong>ID</strong>，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 <strong>ID</strong>。更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 <strong>ID</strong>，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<p>例如，现在要删除 <code>node:20-alpine</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用短 ID 删除</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> 674</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更精确的是使用 镜像摘要 删除镜像</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> node --digests <span class="comment"># 获取摘要</span></span><br><span class="line">REPOSITORY   TAG         DIGEST                                                                    IMAGE ID       CREATED        SIZE</span><br><span class="line">node         20-alpine   sha256:674181320f4f94582c6182eaa151bf92c6744d478be0f1d12db804b7d59b2d11   674181320f4f   2 months ago   191MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 镜像摘要 删除镜像</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> node@sha256:674181320f4f94582c6182eaa151bf92c6744d478be0f1d12db804b7d59b2d11</span><br></pre></td></tr></table></figure>

<h4 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h4><h5 id="Untagged-取消标签"><a href="#Untagged-取消标签" class="headerlink" title="Untagged (取消标签)"></a>Untagged (取消标签)</h5><p><code>Untagged</code> 意味着<strong>移除了一个指向某个特定镜像层的标签（引用）</strong>。<br>Docker 并没有立即删除镜像的数据本身，它只是把“名字”（标签）从那个镜像上拿掉了。这类似于在文件系统中删除一个文件的“快捷方式”，而文件本体还留在硬盘上。</p>
<ul>
<li>当删除一个<strong>有唯一标签</strong>的镜像时（例如 <code>docker rmi nginx:latest</code>），这个操作首先就是 <code>Untagged</code>。</li>
<li>当删除一个<strong>共享镜像的多个标签中的某一个</strong>时（例如，一个镜像有 <code>my-app:1.0</code> 和 <code>my-app:latest</code> 两个标签，只删了 <code>my-app:1.0</code>），Docker 只会执行 <code>Untagged</code>，因为还有另一个标签（<code>my-app:latest</code>）在引用着底层的镜像数据。</li>
</ul>
<h5 id="Deleted-删除镜像层"><a href="#Deleted-删除镜像层" class="headerlink" title="Deleted (删除镜像层)"></a>Deleted (删除镜像层)</h5><p><code>Deleted</code> 意味着 Docker <strong>真正地删除了镜像的某一层数据</strong>，释放了磁盘空间。<br>只有当某个镜像层<strong>没有任何标签引用它</strong>，并且<strong>没有任何容器（包括已停止的容器）依赖它</strong>时，Docker 的垃圾回收机制才会真正地删除该层的数据。<br>镜像是由多个<strong>只读层（Layers）</strong> 组成的。<code>Deleted</code> 输出会显示被删除的每一层的 SHA256 哈希值。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><ol>
<li>删除一个独立的镜像（最常见）<br>一个镜像 nginx:latest，没有其他标签指向它，也没有容器基于它运行。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi nginx:latest</span><br><span class="line">Untagged: nginx:latest</span><br><span class="line">Untagged: nginx@sha256:...（一些摘要信息）</span><br><span class="line">Deleted: sha256:abcd1234...（第一层）</span><br><span class="line">Deleted: sha256:efgh5678...（第二层）</span><br><span class="line">Deleted: sha256:ijkl9012...（第三层）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>过程：Docker 首先 <code>Untagged</code>，移除了 <code>nginx:latest</code> 这个标签。由于这个镜像已经没有标签指向它，并且没有被任何容器使用，所以 Docker 接着将它的所有镜像层都 <code>Deleted</code>，释放了空间。</li>
</ul>
<ol start="2">
<li>删除一个共享镜像的某个标签<br>构建一个镜像，并给它打上了两个标签：<code>my-app:1.0</code> 和 <code>my-app:latest</code>。它们指向同一个 Image ID。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先删除其中一个标签</span></span><br><span class="line">$ docker rmi my-app:1.0</span><br><span class="line">Untagged: my-app:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像并没有被真正删除，因为 my-app:latest 还在引用它</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">my-app       latest    xxxxxxxx       ...           ...</span><br></pre></td></tr></table></figure>
<ul>
<li>过程：Docker 只是执行了 <code>Untagged</code>，移除了 <code>my-app:1.0</code> 这个标签。但镜像本身（Image ID）因为还有 <code>my-app:latest</code> 这个标签在引用，所以它的数据层不会被 Deleted。</li>
</ul>
<ol start="3">
<li>删除一个正在被容器使用的镜像<br>一个镜像 <code>ubuntu:20.04</code>，并且曾经用它运行过一个容器（即使容器现在已经停止）。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi ubuntu:20.04</span><br><span class="line">Error response from daemon: conflict: unable to remove repository reference <span class="string">&quot;ubuntu:20.04&quot;</span> (must force) - container 7a3b8c9d0e1a is using its referenced image 94e814e2efa8</span><br></pre></td></tr></table></figure>
<ul>
<li>过程：Docker <strong>既不会</strong> <code>Untagged</code> <strong>也不会</strong> <code>Deleted</code>，而是直接报错。因为它发现仍有容器（<code>7a3b8c9d0e1a</code>）依赖于这个镜像（<code>94e814e2efa8</code>）。这是一种保护机制，防止误删导致依赖它的容器出问题。</li>
<li>解决方法：必须先删除依赖它的容器，才能删除镜像。或者使用强制参数 <code>-f</code>（但通常不推荐，除非你很清楚在做什么）。</li>
</ul>
<h5 id="总结与类比"><a href="#总结与类比" class="headerlink" title="总结与类比"></a>总结与类比</h5><table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td><code>Untagged</code></td>
<td>移除一个<strong>名字（引用）</strong></td>
<td>从图书馆目录系统中<strong>移除一本书的索引卡</strong>。书还在书架上，但别人通过目录找不到它了。</td>
</tr>
<tr>
<td><code>Deleted</code></td>
<td>移除<strong>数据本身</strong></td>
<td>把那本书<strong>从书架上拿走并销毁</strong>。空间被释放。</td>
</tr>
</tbody></table>
<blockquote>
<p><code>Untagged</code> 是解除标签和镜像的关联，是删除过程的第一步。<br><code>Deleted</code> 是真正删除数据，只有在<strong>无标签引用</strong>且<strong>无容器依赖</strong>时才会发生。<br>如果只看到 <code>Untagged</code> 而没有看到 <code>Deleted</code>，说明这个镜像还在被别的标签或容器使用着，它的数据并没有被真正删除，也不会释放磁盘空间。</p>
</blockquote>
<h4 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h4><p>可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有仓库名为 redis 的镜像</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q redis)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> -q redis ｜ xargs docker image <span class="built_in">rm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有在 mongo:3.2 之前的镜像</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> $(docker image <span class="built_in">ls</span> -q -f before=mongo:3.2)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image <span class="built_in">ls</span> -q --filter <span class="string">&quot;before=mongo:3.2&quot;</span> | xargs docker image <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>
<ul>
<li>·docker image ls·: 列出镜像。</li>
<li><code>-q</code>: 安静模式，只输出镜像ID。</li>
<li><code>|</code>: 管道符，将前一个命令的标准输出，作为后一个命令的标准输入。</li>
<li><code>xargs</code>: 从标准输入接收参数，并将这些参数作为另一个命令的命令行参数来执行。</li>
</ul>
<h3 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h3><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。</p>
<p>运行一个容器的时候（如果不使用卷的话），任何文件修改都会被记录于容器存储层里。而 <code>Docker</code> 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code> 的语法格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ docker commit \</span><br><span class="line">    --author <span class="string">&quot;south &lt;south@gmail.com&gt;&quot;</span> \</span><br><span class="line">    --message <span class="string">&quot;修改了默认网页&quot;</span> \</span><br><span class="line">    webserver \</span><br><span class="line">    nginx:v2</span><br><span class="line">sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</span><br></pre></td></tr></table></figure>
<p><code>--author</code> 是指定修改的作者，<code>--message</code> 是记录本次修改的内容，可以留空。</p>
<p>可以用 <code>docker history</code> 具体查看镜像内的历史记录，会发现新增了刚提交的这一层。</p>
<h4 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 <code>docker commit</code></h4><p>使用<code>docker commit</code>命令会有大量的无关内容被添加进来，将会导致镜像极为臃肿。除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。</p>
<p>所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p>
<h3 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h3><p><strong>Dockerfile</strong> 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>

<h4 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h4><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p>
<p>在 <a target="_blank" rel="noopener" href="https://hub.docker.com/search?q=&type=image&image_filter=official">Docker Hub</a>上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/nginx/"><code>nginx</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/redis/"><code>redis</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/mongo/"><code>mongo</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/mysql/"><code>mysql</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/httpd/"><code>httpd</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/php/"><code>php</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/tomcat/"><code>tomcat</code></a>等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/node/"><code>node</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/openjdk/"><code>openjdk</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/python/"><code>python</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/ruby/"><code>ruby</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/golang/"><code>golang</code></a>等。可以在其中寻找一个最符合最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/ubuntu/"><code>ubuntu</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/debian/"><code>debian</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/centos/"><code>centos</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/fedora/"><code>fedora</code></a>、<a target="_blank" rel="noopener" href="https://hub.docker.com/_/alpine/"><code>alpine</code></a>等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，<strong>Docker</strong> 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果以 <code>scratch</code> 为基础镜像的话，意味着不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 <strong>Linux</strong> 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <code>Go 语言</code>开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 <strong>Go</strong> 是特别适合容器微服务架构的语言的原因之一。</p>
<h4 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h4><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><strong>shell</strong> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>exec</strong> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p><strong>Dockerfile</strong> 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误示例</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure>
<p>上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>
<blockquote>
<p><strong>Union FS</strong> 是有最大层数限制的，比如 <strong>AUFS</strong>，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line"><span class="keyword">FROM</span> debian:stretch</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/redis install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span></span><br></pre></td></tr></table></figure>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 <code>redis</code> 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 <strong>Dockerfile</strong> 的时候，要经常提醒自己，这并不是在写 <strong>Shell</strong> 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。<strong>Dockerfile</strong> 支持 <strong>Shell</strong> 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。<strong>因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉</strong>。</p>
<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>在 <code>Dockerfile</code> 文件所在目录执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure>
<p>从命令的输出结果中，可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p>
<p>这里使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>
<p>在这里指定了最终镜像的名称 <code>-t nginx:v3</code>。</p>
<h4 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h4><p><code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，用于指定 <strong>上下文路径</strong>。<code>docker build</code> 命令会将该目录下的内容打包交给 <strong>Docker</strong> 引擎以帮助构建镜像。</p>
<p><code>docker build</code> 的工作原理: <strong>Docker</strong> 在运行时分为 <strong>Docker</strong> 引擎（也就是服务端守护进程）和客户端工具。<strong>Docker</strong> 的引擎提供了一组 <strong>REST API</strong>，被称为 <strong>Docker Remote API</strong>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 <strong>API</strong> 与 <strong>Docker</strong> 引擎交互，从而完成各种功能。因此，虽然表面上好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（<strong>Docker 引擎</strong>）完成。也因为这种 <strong>C&#x2F;S</strong> 设计，让操作远程服务器的 <strong>Docker</strong> 引擎变得轻而易举。</p>
<p>为了让服务端获取到本地的文件，使用上下文的概念。当构建的时候，指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 <strong>Docker</strong> 引擎。这样 <strong>Docker</strong> 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure>
<p><code>Dockerfile</code>里这样写，这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是相对路径。这也是为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，<strong>Docker</strong> 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 <strong>Docker</strong> 引擎的。可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<h4 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h4><p><code>docker build</code> 还支持从 <strong>URL</strong> 构建，比如可以直接从 <strong>Git repo</strong> 中构建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world</span><br><span class="line"></span><br><span class="line">Step 1/3 : FROM scratch</span><br><span class="line"> ---&gt;</span><br><span class="line">Step 2/3 : COPY hello /</span><br><span class="line"> ---&gt; ac779757d46e</span><br><span class="line">Step 3/3 : CMD [<span class="string">&quot;/hello&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d2a513a760ed</span><br><span class="line">Removing intermediate container d2a513a760ed</span><br><span class="line"> ---&gt; 038ad4142d2b</span><br><span class="line">Successfully built 038ad4142d2b</span><br></pre></td></tr></table></figure>
<p>这行命令指定了构建所需的 <strong>Git repo</strong>，并且指定分支为 <code>master</code>，构建目录为 <code>/amd64/hello-world/</code>，然后 <strong>Docker</strong> 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<h4 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果所给出的 <strong>URL</strong> 不是个 <strong>Git repo</strong>，而是个 <code>tar</code> 压缩包，那么 <strong>Docker</strong> 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<h4 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build - &lt; Dockerfile</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="built_in">cat</span> Dockerfile | docker build -</span><br></pre></td></tr></table></figure>
<p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 <strong>Dockerfile</strong> 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p>
<h4 id="标准输入中读取上下文压缩包进行构建"><a href="#标准输入中读取上下文压缩包进行构建" class="headerlink" title="标准输入中读取上下文压缩包进行构建"></a>标准输入中读取上下文压缩包进行构建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>
<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
<h3 id="其它制作镜像的方式"><a href="#其它制作镜像的方式" class="headerlink" title="其它制作镜像的方式"></a>其它制作镜像的方式</h3><p>除了标准的使用 Dockerfile 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p>
<h4 id="从-rootfs-压缩包导入"><a href="#从-rootfs-压缩包导入" class="headerlink" title="从 rootfs 压缩包导入"></a>从 rootfs 压缩包导入</h4><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p>
<p>压缩包可以是本地文件、远程 <strong>Web</strong> 文件，甚至是从标准输入中得到。压缩包将会在镜像 <code>/</code> 目录展开，并直接作为镜像第一层提交。</p>
<p>比如创建一个 <a target="_blank" rel="noopener" href="https://openvz.org/">OpenVZ</a>的 Ubuntu 16.04 模板的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker import \</span><br><span class="line">    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \</span><br><span class="line">    openvz/ubuntu:16.04</span><br><span class="line"></span><br><span class="line">Downloading from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz</span><br><span class="line">sha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213</span><br></pre></td></tr></table></figure>
<p>这条命令自动下载了 <code>ubuntu-16.04-x86_64.tar.gz</code> 文件，并且作为根文件系统展开导入，并保存为镜像 <code>openvz/ubuntu:16.04</code>。</p>
<p>导入成功后，可以用 <code>docker image ls</code> 看到这个导入的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> openvz/ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">openvz/ubuntu       16.04               412b8fc3e3f7        55 seconds ago      505MB</span><br></pre></td></tr></table></figure>
<p>如果查看其历史的话，会看到描述中有导入的文件链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> openvz/ubuntu:16.04</span><br><span class="line">IMAGE               CREATED              CREATED BY          SIZE                COMMENT</span><br><span class="line">f477a6e18e98        About a minute ago                       214.9 MB            Imported from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="Docker-镜像的导入和导出-docker-save-和-docker-load"><a href="#Docker-镜像的导入和导出-docker-save-和-docker-load" class="headerlink" title="Docker 镜像的导入和导出 docker save 和 docker load"></a>Docker 镜像的导入和导出 docker save 和 docker load</h4><p><strong>Docker</strong> 还提供了 <code>docker save</code> 和 <code>docker load</code> 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 <strong>Docker Registry</strong> 时的做法，现在已经不推荐，镜像迁移应该直接使用 <strong>Docker Registry</strong>，无论是直接使用 <strong>Docker Hub</strong> 还是使用内网私有 <strong>Registry</strong> 都可以。</p>
<h5 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h5><p>使用 <code>docker save</code> 命令可以将镜像保存为归档文件。</p>
<p>比如保存这个 <code>alpine</code> 镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> alpine</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">alpine              latest              baa5d63471ea        5 weeks ago         4.803 MB</span><br></pre></td></tr></table></figure>
<p>保存镜像的命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker save alpine -o filename</span><br><span class="line">$ file filename</span><br><span class="line">filename: POSIX tar archive</span><br></pre></td></tr></table></figure>
<p>这里的 <code>filename</code> 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件</p>
<blockquote>
<p>注意：如果同名则会覆盖（没有警告）</p>
</blockquote>
<p>若使用 <code>gzip</code> 压缩：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save alpine | gzip &gt; alpine-latest.tar.gz</span><br></pre></td></tr></table></figure>
<p>然后将 <code>alpine-latest.tar.gz</code> 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i alpine-latest.tar.gz</span><br><span class="line">Loaded image: alpine:latest</span><br></pre></td></tr></table></figure>
<p>如果结合这两个命令以及 <code>ssh</code> 甚至 <code>pv</code> 的话，利用 <strong>Linux</strong> 强大的管道，可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; <span class="string">&#x27;cat | docker load&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h4><p>每个镜像都由很多层次构成，<strong>Docker</strong> 使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UnionFS">Union FS</a>将这些不同的层结合到一个镜像中去。</p>
<p>通常 <strong>Union FS</strong> 有两个用途, 一方面可以实现不借助 <strong>LVM</strong>、<strong>RAID</strong> 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，<strong>Live CD</strong> 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p>
<p><strong>Docker</strong> 在 <strong>OverlayFS</strong> 上构建的容器也是利用了类似的原理。</p>
<h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<h3 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h3><p>使用<code>docker ps</code> 命令或 <code>docker container ls</code> 命令可以列出当前正在运行的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID   IMAGE                        COMMAND                  CREATED        STATUS        PORTS     NAMES</span><br><span class="line">028c7ac354c8   115d77efe6e2                 <span class="string">&quot;/storage-provisione…&quot;</span>   21 hours ago   Up 21 hours             k8s_storage-provisioner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE                        COMMAND                  CREATED        STATUS        PORTS     NAMES</span><br><span class="line">028c7ac354c8   115d77efe6e2                 <span class="string">&quot;/storage-provisione…&quot;</span>   22 hours ago   Up 22 hours             k8s_storage-provisioner</span><br></pre></td></tr></table></figure>
<p>使用<code>docker ps -a</code> 命令或 <code>docker container ls -a</code> 命令可以列出所有的容器。</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>主要命令是<code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/echo <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/#</span><br></pre></td></tr></table></figure>
<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/# <span class="built_in">pwd</span></span><br><span class="line">/</span><br><span class="line">root@af8bae53bdd3:/# <span class="built_in">ls</span></span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从 <strong>registry</strong> 下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。</p>
<h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><p>更多的时候，需要让 <strong>Docker</strong> 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>容器会把输出的结果 (<strong>STDOUT</strong>) 打印到宿主机上面</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure>
<p>此时容器会在后台运行并不会把输出的结果 (<strong>STDOUT</strong>) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注</strong>： 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 <strong>id</strong>，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:18.04  /bin/sh -c <span class="string">&#x27;while tr  2 minutes ago  Up 1 minute        agitated_wright</span></span><br></pre></td></tr></table></figure>
<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>要终止正在运行的容器，可以通过 <code>docker container stop</code> 命令。当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>可以使用<code>docker container ls -a</code> 命令查看终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">&quot;/bin/bash&quot;</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br></pre></td></tr></table></figure>
<p>删除所有停止状态的容器可以使用<code>docker container prune</code>命令。<br>启动终止状态的容器可以使用<code>docker container start</code>命令。<br><code>docker container restart</code> 命令会将一个运行状态的容器终止然后重启容器。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>使用 <code>-d</code> 参数时，容器启动后会进入后台运行，如果需要进入到容器操作，可以使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐使用<code>docker exec</code> 命令。</p>
<h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line">$ docker attach 243c</span><br><span class="line">root@243c32535da7:/#</span><br></pre></td></tr></table></figure>
<p><em>注意</em>： 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><p><code>docker exec</code> 后边可以跟多个参数，这里简单介绍 <code>-i</code> <code>-t</code> 参数。<br>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有 <strong>Linux</strong> 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到 <strong>Linux</strong> 命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span><br><span class="line">root@69d137adef7a:/#</span><br></pre></td></tr></table></figure>
<p>如果从这个 stdin 中 exit，不会导致容器的停止。</p>
<p>可以使用<code>docker exec --help</code>命令查看其他参数。</p>
<h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>使用<code>docker export</code> 命令将容器导出为 <strong>tar</strong> 文件，该文件包含容器的配置、数据卷、网络配置等等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:18.04        <span class="string">&quot;/bin/bash&quot;</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span><br><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>

<h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过指定 URL 或者某个目录来导入</span></span><br><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>
<p><em>注：既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">rm</span> trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure>
<p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。<strong>Docker</strong> 会发送 <code>SIGKILL</code> 信号给容器。</p>
<p>使用 <code>docker container prune</code> 可以清除所有处于终止状态的容器。</p>
<h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>仓库地址 <code>docker.io/ubuntu</code>，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p>
<h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>目前 <strong>Docker</strong> 官方维护了一个公共仓库 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，其中已经包括了数量超过 <a target="_blank" rel="noopener" href="https://hub.docker.com/search/?type=image">11,519,000</a>的镜像。大部分需求都可以通过在 <strong>Docker Hub</strong> 中直接下载镜像来实现。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>可以在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 <strong>Docker</strong> 账号。</p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 <strong>Docker Hub</strong>。</p>
<p>通过 <code>docker logout</code> 退出登录。</p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker search centos</span><br><span class="line">NAME                           DESCRIPTION                                     STARS     OFFICIAL</span><br><span class="line">centos                         DEPRECATED; The official build of CentOS.       7780      [OK]</span><br><span class="line">corpusops/centos               centos corpusops baseimage                      0</span><br><span class="line">dockette/centos                My Custom CentOS Dockerfiles                    1</span><br><span class="line">eclipse/centos                 CentOS based minimal stack with only git and…   1</span><br><span class="line">centos/postgresql-10-centos7   PostgreSQL is an advanced Object-Relational …   21</span><br><span class="line">centos/redis-5-centos8                                                         0</span><br></pre></td></tr></table></figure>
<p>返回镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）。</p>
<!-- 是否自动构建 （`AUTOMATED`） -->

<p>根据是否是官方提供，可将镜像分为两类。</p>
<ul>
<li>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 <strong>Docker</strong> 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</li>
<li>另一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 <strong>Docker Hub</strong> 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 <strong>ansible</strong> 用户。</li>
</ul>
<p>查找的时可以通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p>
<p>下载镜像到本地：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">7a0437f04f83: Pull complete</span><br><span class="line">Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br></pre></td></tr></table></figure>

<h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 <strong>Docker Hub</strong>。</p>
<p>以下命令中的 <code>username</code> 为 <strong>Docker</strong> 账号用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">$ docker push username/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">$ docker search username</span><br><span class="line"></span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><p><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-05.png" alt="Docker容器与主机文件系统和内存之间的三种数据管理方式"></p>
<ul>
<li><code>bind mount（绑定挂载）</code>：将宿主机文件系统上的文件或目录直接挂载到容器中，实现宿主机与容器之间的数据共享和持久化。</li>
<li><code>volume（数据卷）</code>：由Docker管理的数据存储区域，可以独立于容器存在，实现数据的持久化和在不同容器间的共享。</li>
<li><code>tmpfs mount（临时文件系统挂载）</code>：将数据存储在宿主机的内存中，提供快速的读写性能，但数据是非持久化的，容器停止后数据会丢失。</li>
<li><code>Docker area（Docker区域）</code>：文件系统中的特定区域，用于存储Docker相关的数据，例如镜像层和容器的可写层。</li>
</ul>
<h3 id="volume（数据卷）"><a href="#volume（数据卷）" class="headerlink" title="volume（数据卷）"></a>volume（数据卷）</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 <strong>UFS</strong>，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。即：数据卷挂载不是简单的合并操作，而是一种“覆盖”或“初始化”行为，其最终内容取决于数据卷本身是否为空。</p>
</blockquote>
</li>
</ul>
<p><strong>Linux下的 <code>mount</code> 操作</strong>: 当把一个设备（比如U盘）挂载到一个非空目录时，该目录原有的文件会被隐藏，访问这个目录只会看到新挂载设备的内容。当卸载设备后，原有的文件又会重新出现。</p>
<p><strong>总结与类比</strong>:</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>行为</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td><strong>挂载</strong>一个<strong>空卷</strong>到容器非空目录</td>
<td>Docker <strong>复制</strong>镜像中的文件到数据卷，再挂载。</td>
<td>你买了一个<strong>空的</strong>新U盘，插到电脑上，电脑自动把“我的文档”里的文件<strong>拷贝</strong>了一份到U盘里。以后你访问“我的文档”，实际上是在访问U盘。</td>
</tr>
<tr>
<td><strong>挂载</strong>一个<strong>非空卷</strong>到容器非空目录</td>
<td>Docker <strong>直接挂载</strong>，数据卷的内容完全覆盖（隐藏）镜像中原内容。</td>
<td>你买了一个<strong>存满了</strong>电影的U盘，插到电脑上。此时访问U盘对应的盘符，只能看到电影，原来电脑上这个盘符里的文件都被<strong>暂时隐藏</strong>了。</td>
</tr>
</tbody></table>
<h4 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h4><p>格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create [卷名]</span><br></pre></td></tr></table></figure>
<p>查看所有的 <code>数据卷</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume <span class="built_in">ls</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>     minikube</span><br><span class="line"><span class="built_in">local</span>     todo-mysql-data</span><br></pre></td></tr></table></figure>
<p>在主机里使用以下命令查看指定 <code>数据卷</code> 的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect minikube</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2025-06-13T10:21:48Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Labels&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;created_by.minikube.sigs.k8s.io&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">      <span class="string">&quot;name.minikube.sigs.k8s.io&quot;</span>: <span class="string">&quot;minikube&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/minikube/_data&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;minikube&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">    <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/usr/share/nginx/html \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<h4 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><p>使用 <code>docker inspect [容器名称或ID]</code> 命令可以查看容器的信息。</p>
<p><code>数据卷</code> 信息在 <strong>“Mounts” Key</strong> 下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/usr/share/nginx/html&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><p>使用<code>docker volume rm [数据卷名称]</code> 命令可以删除数据卷。</p>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，<strong>Docker</strong> 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除<code>数据卷</code>。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p><code>docker volume prune</code> 命令可以删除所有未使用的数据卷。</p>
<h4 id="核心特性与工作原理"><a href="#核心特性与工作原理" class="headerlink" title="核心特性与工作原理"></a>核心特性与工作原理</h4><ol>
<li><strong>生命周期独立</strong>。据卷的生命周期与任何使用它的容器<strong>完全分离</strong>。</li>
</ol>
<ul>
<li>创建容器时可以创建新卷，也可以使用已有卷。</li>
<li>停止或删除容器不会自动删除与之关联的数据卷。数据卷必须使用 <code>docker volume rm</code> 或 <code>docker volume prune</code> 命令显式删除。</li>
</ul>
<ol start="2">
<li><strong>存储在宿主机上，由Docker管理</strong>。数据卷物理上存储在 Docker 宿主机的某个目录中（通常是 <code>/var/lib/docker/volumes/</code>）。</li>
</ol>
<ul>
<li>不需要关心它的具体路径，只需通过赋予的<strong>名称</strong>来操作它。这提供了很好的抽象和可移植性。例如，一个名为 <code>my_db_data</code> 的卷，其真实路径可能是 <code>/var/lib/docker/volumes/my_db_data/_data</code>。</li>
</ul>
<ol start="3">
<li><strong>初始化行为（与Bind Mount的关键区别）</strong>。这是数据卷一个非常有用且智能的特性：</li>
</ol>
<ul>
<li>如果将一个<strong>空的、新创建的数据卷</strong>挂载到一个<strong>容器内非空的目录</strong>（例如，一个数据库镜像的默认数据目录 <code>/var/lib/mysql</code>），Docker 会自动将容器目录中的<strong>初始内容复制（拷贝）到数据卷中</strong>。</li>
<li>这样，新容器启动时就有了一份可用的初始数据（如空的数据库表结构），保证了服务的正确启动。</li>
</ul>
<ol start="4">
<li><strong>支持多种卷驱动程序</strong>。数据卷支持使用不同的<strong>驱动程序（Drivers）</strong>，这赋予了它强大的扩展性：</li>
</ol>
<ul>
<li><strong>默认驱动（local）</strong>：数据存储在宿主机本地。</li>
<li><strong>第三方驱动</strong>：如 <code>sshfs</code>, <code>ceph</code>, <code>nfs</code> 等，可以将数据卷存储在远程主机或云存储上，从而实现跨主机的数据共享和持久化。</li>
</ul>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><h5 id="匿名卷（Anonymous-Volumes）"><a href="#匿名卷（Anonymous-Volumes）" class="headerlink" title="匿名卷（Anonymous Volumes）"></a>匿名卷（Anonymous Volumes）</h5><p>在 Dockerfile 或 <code>docker run</code> 命令中只指定容器内的路径，不指定卷名。Docker 会自动生成一个随机哈希值作为卷名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile 中</span></span><br><span class="line">VOLUME /var/lib/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令中</span></span><br><span class="line">docker run -d -v /var/lib/mysql mysql:8.0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>缺点</strong>：难以管理和记忆，不推荐手动使用。</li>
</ul>
<h5 id="命名卷（Named-Volumes）-最常用"><a href="#命名卷（Named-Volumes）-最常用" class="headerlink" title="命名卷（Named Volumes）- 最常用"></a>命名卷（Named Volumes）- 最常用</h5><p>在 <code>docker run</code> 命令中同时指定卷名和容器内的路径。这是<strong>生产环境的推荐做法</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -v 标志</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql-db \</span><br><span class="line">  -v mysql_data:/var/lib/mysql \  <span class="comment"># &lt;卷名&gt;:&lt;容器内路径&gt;</span></span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=secret \</span><br><span class="line">  mysql:8.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用更明确的 --mount 标志（推荐）</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name mysql-db \</span><br><span class="line">  --mount <span class="built_in">source</span>=mysql_data,target=/var/lib/mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=secret \</span><br><span class="line">  mysql:8.0</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>mysql_data</code> 卷不存在，Docker 会自动创建它。</li>
<li>由于是新建的空卷，Docker 会将 MySQL 镜像中 <code>/var/lib/mysql</code> 目录的初始数据复制到卷中。</li>
</ul>
<h5 id="通过容器填充（–volumes-from）"><a href="#通过容器填充（–volumes-from）" class="headerlink" title="通过容器填充（–volumes-from）"></a>通过容器填充（–volumes-from）</h5><p>一个容器可以将其所有的数据卷挂载点“共享”给另一个容器。这常用于<strong>备份工具容器</strong>或<strong>sidecar模式</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个使用数据卷的容器</span></span><br><span class="line">docker run -d --name web-server -v app_data:/app nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另一个容器（如备份工具），来访问web-server容器的所有卷</span></span><br><span class="line">docker run --<span class="built_in">rm</span> --volumes-from web-server -v $(<span class="built_in">pwd</span>):/backup alpine \</span><br><span class="line">   tar czf /backup/archive.tar.gz /app</span><br></pre></td></tr></table></figure>
<ul>
<li>这个例子中，备份容器可以访问 <code>web-server</code> 容器的 <code>/app</code> 卷（即 <code>app_data</code>），并将其内容打包备份到宿主机的当前目录。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>数据卷是 Docker 生态中管理持久化数据的基石。</strong></p>
<ul>
<li><strong>对于生产环境</strong>：几乎所有的有状态服务（如MySQL, Redis, PostgreSQL）都应该使用<strong>命名卷</strong>来存储数据，以确保数据安全、可迁移且易于管理。</li>
<li>它的<strong>核心优势</strong>在于由 Docker 统一管理，提供了命名抽象、生命周期控制和可移植性，让你不再需要关心数据具体存储在宿主机哪个角落。<br>简单来说，<strong>当你需要数据在容器之外存活时，就应该使用数据卷。</strong></li>
</ul>
<h3 id="挂载主机目录-Bind-mounts-绑定挂载"><a href="#挂载主机目录-Bind-mounts-绑定挂载" class="headerlink" title="挂载主机目录 (Bind mounts - 绑定挂载)"></a>挂载主机目录 (Bind mounts - 绑定挂载)</h3><p>绑定挂载允许将宿主机文件系统上的任意一个目录或文件直接挂载到容器内的指定路径。</p>
<ul>
<li><strong>核心</strong>：它建立的是宿主机路径与容器路径的<strong>直接映射</strong>。</li>
<li><strong>类比</strong>：类似于在 Linux 中创建一个<strong>软链接</strong>或<strong>符号链接</strong>。在容器内对挂载目录的操作，会<strong>直接反映</strong>在宿主机的对应目录上，反之亦然。</li>
</ul>
<p>语法：使用 <code>-v</code> 或 <code>--mount</code> 标志都可以创建绑定挂载，推荐使用更明确易懂的 <code>--mount</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -v 标志（旧式，但更简洁）</span></span><br><span class="line">docker run -v /宿主机/路径:/容器内/路径 镜像名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 --mount 标志（新式，语法更清晰）</span></span><br><span class="line">docker run --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/宿主机/路径,target=/容器内/路径 镜像名</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type=bind</code>: 明确指定挂载类型为“绑定挂载”。</li>
<li><code>source</code> 或 <code>src</code>: <strong>宿主机上的源路径</strong>。必须是绝对路径，且路径必须已存在，否则Docker会报错。</li>
<li><code>target</code> 或 <code>destination</code> 或 <code>dst</code>: <strong>容器内的目标路径</strong>。如果路径不存在，Docker 会在容器内自动创建它。</li>
</ul>
<p>Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html:ro \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/usr/share/nginx/html,<span class="built_in">readonly</span> \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p><strong>绑定挂载的核心是直接、灵活地将宿主机目录暴露给容器。</strong></p>
<ul>
<li><strong>优点</strong>：极致灵活、性能直接、易于理解和调试（文件就在你指定的地方）。</li>
<li><strong>缺点</strong>：路径与宿主机耦合，移植性差（Dockerfile或脚本中的路径在其他机器上可能不存在）。</li>
</ul>
<h4 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h4><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it \</span><br><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span><br><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:18.04 \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/# <span class="built_in">history</span></span><br><span class="line">1  <span class="built_in">ls</span></span><br><span class="line">2  diskutil list</span><br></pre></td></tr></table></figure>
<p>这样就可以记录在容器输入过的命令了</p>
<h3 id="绑定挂载-与-命名卷-的区别"><a href="#绑定挂载-与-命名卷-的区别" class="headerlink" title="绑定挂载 与 命名卷 的区别"></a>绑定挂载 与 命名卷 的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>绑定挂载 (Bind Mount)</th>
<th>命名卷 (Named  Volume)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储位置</strong></td>
<td>宿主机<strong>自定义路径</strong></td>
<td>Docker<strong>管理区域</strong> (<code>/var/lib/docker/volumes/)</code></td>
</tr>
<tr>
<td><strong>可移植性</strong></td>
<td><strong>差</strong>。路径与特定宿主机强绑定。</td>
<td><strong>好</strong>。只需指定卷名，Docker自动管理路径。</td>
</tr>
<tr>
<td><strong>备份迁移</strong></td>
<td>容易（直接操作宿主机文件系统）。</td>
<td>需要Docker命令辅助。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>直接访问宿主机文件系统，性能<strong>取决于宿主机存储</strong>。</td>
<td>在Linux上可能有轻微开销，但通常性能很好。</td>
</tr>
<tr>
<td><strong>用例</strong></td>
<td><strong>开发环境</strong>（代码同步、配置管理）、挂载系统文件（如&#x2F;etc&#x2F;localtime）。</td>
<td><strong>生产环境</strong>（数据库数据、应用数据）、需要Docker管理备份的场景。</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td><strong>不会</strong>用容器内容初始化宿主机路径。</td>
<td>如果卷为空，<strong>会</strong>用容器镜像的内容初始化卷。</td>
</tr>
</tbody></table>
<h2 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p>
<h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>要让外部访问容器内部运行的网络应用，可以通过 <code>-P</code> 或 <code>-p </code>参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，<strong>Docker</strong> 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 <strong>NGINX</strong> 默认页面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P nginx:alpine</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span> -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES</span><br><span class="line">fae320d08268        nginx:alpine        <span class="string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</span><br></pre></td></tr></table></figure>
<p>可以通过 docker logs 命令来查看访问记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs fa</span><br><span class="line">172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 612 <span class="string">&quot;-&quot;</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="指定映射端口"><a href="#指定映射端口" class="headerlink" title="指定映射端口"></a>指定映射端口</h4><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h5 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h5><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h5 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h5><p>使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 <strong>localhost</strong> 地址 <strong>127.0.0.1</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<h5 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h5><p>使用 <code>ip::containerPort</code> 绑定 <strong>localhost</strong> 的任意端口到容器的 <strong>80</strong> 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>
<h5 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h5><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>容器有自己的内部网络和 <strong>ip</strong> 地址（使用 <code>docker inspect</code> 查看，<strong>Docker</strong> 还可以有一个可变的网络配置。）</li>
<li><code>-p</code> 标记可以多次使用来绑定多个端口</li>
</ul>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    -p 443:443 \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><h4 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h4><p><strong>Docker</strong> 默认使用 <strong>bridge</strong> 网络模式，即创建一个虚拟网桥，将容器加入该网桥，并分配 <strong>IP</strong> 地址。<code>overlay</code> 网络类型用于 <strong>Swarm mode</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 参数指定 <strong>Docker</strong> 网络类型。</p>
<h5 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h5><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure>
<p><code>--network</code> 参数指定容器连接到哪个网络。</p>
<h4 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h4><p><strong>Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具。</strong> 用于简化多容器应用的定义、配置和运行。</p>
<ul>
<li><strong>核心思想</strong>：<strong>“代码即基础设施”</strong>。使用一个名为 <code>docker-compose.yml </code>的 <strong>YAML</strong> 文件来配置应用所需的所有服务、网络、数据卷等。</li>
<li><strong>核心命令</strong>：通过一个简单的命令 <code>docker compose up</code>，Compose 就能根据配置文件，自动创建并启动所有定义好的资源，将多个互相关联的容器组织成一个完整的应用栈。</li>
<li><strong>解决问题</strong>：在开发和测试环境中，手动使用 <code>docker run</code> 命令来启动一个个容器并配置它们之间的连接非常繁琐且容易出错。Compose 解决了这个问题。</li>
</ul>
<blockquote>
<p>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。<br>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。<br>一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。<code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
</blockquote>
<h5 id="核心概念与工作流程"><a href="#核心概念与工作流程" class="headerlink" title="核心概念与工作流程"></a>核心概念与工作流程</h5><ol>
<li><strong>定义</strong>：在 <code>docker-compose.yml</code> 文件中定义应用所需的组件（称为“服务”），每个服务对应一个容器。还可以定义网络、卷等资源。</li>
<li><strong>运行</strong>：在包含 <code>docker-compose.yml</code> 文件的目录下，执行 <code>docker compose up</code> 命令。</li>
<li><strong>创建</strong>：Compose 会解析 YAML 文件，自动：<ul>
<li>创建指定的<strong>网络</strong>（默认会创建一个专属网络）。</li>
<li>创建指定的<strong>数据卷</strong>。</li>
<li><strong>构建或拉取</strong>所需的镜像。</li>
<li>按正确的依赖顺序<strong>启动所有服务（容器）</strong>，并将它们连接到同一网络。</li>
</ul>
</li>
<li><strong>管理</strong>：使用 <strong>docker compose</strong> 命令族来统一管理整个应用栈的生命周期（启动、停止、查看状态、查看日志等）。</li>
</ol>
<h5 id="核心语法与-docker-compose-yml-文件详解"><a href="#核心语法与-docker-compose-yml-文件详解" class="headerlink" title="核心语法与 docker-compose.yml 文件详解"></a>核心语法与 <code>docker-compose.yml</code> 文件详解</h5><p>一个典型的 Compose 文件结构如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本号（现在通常省略，使用最新版本模式）</span></span><br><span class="line"><span class="comment"># 以前为了兼容旧版本，需要添加该字段，明确告诉 Docker Compose 希望使用哪个版本的语法来解释这个文件</span></span><br><span class="line"><span class="comment"># 从 Docker Compose 版本 1.27.0+ 开始，引入了一个新概念：Compose Specification。核心思想：Compose 文件格式被标准化为一个开放的规范，不再与 Docker Compose 工具的特定版本强绑定。</span></span><br><span class="line"><span class="comment"># 省略 version 键时，Docker Compose 会自动使用最新版本的语法规则（即 Compose Specification）来解析你的文件。这被称为“最新版本模式”</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义你的应用由哪些服务组成</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 服务一：Web 应用</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="comment"># 从当前目录的 Dockerfile 构建镜像</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="comment"># 映射端口：主机端口:容器端口</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:5000&quot;</span></span><br><span class="line">    <span class="comment"># 挂载数据卷：将主机上的代码目录挂载到容器，用于开发时实时更新</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">    <span class="comment"># 设置环境变量</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DATABASE_URL=postgresql://db:5432</span></span><br><span class="line">    <span class="comment"># 定义依赖：Compose 会先启动 redis 和 db 服务</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 服务二：Redis 缓存</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># 使用公共镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br><span class="line">    <span class="comment"># 将容器数据持久化到命名卷</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_data:/data</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 服务三：PostgreSQL 数据库</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_DB=mydb</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_USER=user</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=secret</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/postgresql/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义本应用栈中要用到的所有数据卷，Compose 会自动创建它们</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span></span><br><span class="line">  <span class="attr">redis_data:</span></span><br></pre></td></tr></table></figure>
<p>关键配置项说明：</p>
<ul>
<li><code>build: .</code>：指定从当前目录的 Dockerfile 构建镜像。<ul>
<li><code>context</code>: 指定构建镜像的目录。</li>
<li><code>dockerfile</code>：指定构建镜像的 <code>Dockerfile</code> 文件。</li>
<li><code>args:</code>：指定构建镜像的参数。</li>
<li><code>cache_from</code>: 指定构建镜像的缓存来源。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">webapp:</span><br><span class="line">  build:</span><br><span class="line">    context: ./dir</span><br><span class="line">    dockerfile: Dockerfile-alternate</span><br><span class="line">    args:</span><br><span class="line">      buildno: 1</span><br><span class="line">    cache_from:</span><br><span class="line">      - alpine:latest</span><br><span class="line">      - corp/web_app:3.14</span><br></pre></td></tr></table></figure>

<ul>
<li><code>image: name</code>：指定使用的现成镜像。</li>
<li><code>ports: [&quot;HOST:CONTAINER&quot;]</code>：端口映射。</li>
<li><code>volumes: [&quot;source:target&quot;]</code>：挂载卷，可以是命名卷、匿名卷或绑定挂载。</li>
<li><code>environment: &#123;KEY: VALUE&#125;</code>：设置容器内的环境变量。</li>
<li><code>depends_on: [service_name]</code>：定义服务之间的启动依赖关系（注意：它只控制启动顺序，不等待服务真正“健康”）。</li>
<li><code>networks: [network_name]</code>：将服务连接到自定义网络（默认所有服务都会加入一个Compose创建的网络，无需手动配置）。</li>
</ul>
<blockquote>
<p>更多语法参考：<a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/compose/compose_file/#">Docker Compose 语法</a></p>
</blockquote>
<h5 id="常用-Docker-Compose-命令"><a href="#常用-Docker-Compose-命令" class="headerlink" title="常用 Docker Compose 命令"></a>常用 Docker Compose 命令</h5><p>在包含 <code>docker-compose.yml</code> 文件的目录下执行：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>常用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker compose up</code></td>
<td>创建并启动所有服务</td>
<td><strong>启动整个应用</strong></td>
</tr>
<tr>
<td><code>docker compose up -d</code></td>
<td>在<strong>后台</strong>创建并启动所有服务</td>
<td>生产环境或长期运行</td>
</tr>
<tr>
<td><code>docker compose run</code></td>
<td>在指定服务上执行一个命令</td>
<td>测试服务</td>
</tr>
<tr>
<td><code>docker compose down</code></td>
<td><strong>停止并移除</strong>所有容器、网络</td>
<td>清理环境</td>
</tr>
<tr>
<td><code>docker compose down -v</code></td>
<td>停止并移除所有容器、网络和<strong>数据卷</strong></td>
<td><strong>彻底</strong>清理环境</td>
</tr>
<tr>
<td><code>docker compose ps</code></td>
<td>列出本Compose项目中的所有容器</td>
<td>查看服务状态</td>
</tr>
<tr>
<td><code>docker compose logs</code></td>
<td>查看所有服务的日志输出</td>
<td>调试应用</td>
</tr>
<tr>
<td><code>docker compose logs [service]</code></td>
<td>查看特定服务的日志</td>
<td>调试某个服务</td>
</tr>
<tr>
<td><code>docker compose stop</code></td>
<td>停止所有服务，但不移除容器</td>
<td>暂停应用</td>
</tr>
<tr>
<td><code>docker compose start</code></td>
<td>启动已停止的服务</td>
<td>重新启动应用</td>
</tr>
<tr>
<td><code>docker compose exec [service] [cmd]</code></td>
<td>在运行中的服务容器内执行命令</td>
<td>进入容器，如 <code>docker compose exec db bash</code></td>
</tr>
<tr>
<td><code>docker compose build </code></td>
<td>重新构建服务的镜像</td>
<td>Dockerfile 变更后</td>
</tr>
</tbody></table>
<ul>
<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li><code>--verbose</code> 输出更多调试信息。</li>
<li><code>-v, --version</code> 打印版本并退出。</li>
</ul>
<p><code>docker compose up</code>命令选项： </p>
<ul>
<li><code>-d</code> 在后台运行服务容器。</li>
<li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li>
<li><code>--no-deps</code> 不启动服务所链接的容器。</li>
<li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li>
<li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li>
<li><code>--no-build</code> 不自动构建缺失的服务镜像。</li>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<blockquote>
<p>更多命令参考：<a target="_blank" rel="noopener" href="https://vuepress.mirror.docker-practice.com/compose/commands/">Docker Compose 命令</a></p>
</blockquote>
<h5 id="典型工作流程（以开发为例）"><a href="#典型工作流程（以开发为例）" class="headerlink" title="典型工作流程（以开发为例）"></a>典型工作流程（以开发为例）</h5><ol>
<li><strong>定义应用依赖</strong>：编写 <code>Dockerfile</code> 来定义应用环境。</li>
<li><strong>编写编排配置</strong>：编写 <code>docker-compose.yml</code> 文件，定义应用的所有服务（web, db, cache等）。</li>
<li><strong>一键启动</strong>：在终端运行 <code>docker compose up</code>。Compose 会拉取镜像、构建应用镜像、创建网络和卷，并启动所有服务。</li>
<li><strong>开发与调试</strong>：在本地修改代码（因为用了绑定挂载，代码变更会立即同步到容器中），查看日志 (<code>docker compose logs</code>)，调试应用。</li>
<li><strong>一键停止</strong>：开发完成后，运行 <code>docker compose down</code> 来清理所有容器和网络。如果需要保留数据，就不要加 <code>-v</code> 参数。</li>
</ol>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><strong>Docker Compose 的核心价值在于</strong>：</p>
<ul>
<li><strong>简化复杂度</strong>：用一个文件和一条命令管理多个容器。</li>
<li><strong>提高可重现性</strong>：确保在任何机器上（开发、测试、CI&#x2F;CD环境）都能以完全相同的方式启动应用栈。</li>
<li><strong>提升开发体验</strong>：是本地开发的“神器”，极大地简化了依赖服务（如数据库、消息队列）的搭建和连接。</li>
</ul>
<p>它主要面向<strong>开发、测试和单机部署</strong>场景。对于更复杂的多机集群部署，则需要使用 <strong>Docker Swarm</strong> 或 <strong>Kubernetes</strong>。但 Compose 文件通常可以作为学习这些更高级编排系统的基础。</p>
<h3 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h3><p>容器如何解析域名：当容器内的应用程序尝试访问一个域名（如 <code>www.google.com</code> 或另一个容器的服务名 <code>my-db</code>）时，它会发起一个 DNS 查询。这个查询的流程和目的地是由容器的 DNS 配置决定的。</p>
<h4 id="默认的-DNS-配置"><a href="#默认的-DNS-配置" class="headerlink" title="默认的 DNS 配置"></a>默认的 DNS 配置</h4><p>Docker 为容器提供了一套开箱即用的 DNS 解析机制，非常智能和实用。</p>
<ol>
<li><strong>默认 DNS 服务器：宿主机作为转发器</strong><br>默认情况下，Docker 会告诉容器使用宿主机的 <strong>IP</strong> 地址（通常是 <code>127.0.0.11</code>，这是 Docker 内置的 DNS 转发器）作为其 DNS 服务器。</li>
</ol>
<ul>
<li><strong>流程</strong>：<code>容器内App</code> -&gt; 查询 <code>127.0.0.11</code> -&gt; <code>Docker Daemon</code> -&gt; <code>宿主机DNS配置</code> -&gt; <code>互联网DNS</code></li>
<li><strong>好处</strong>：<ul>
<li><strong>一致性</strong>：容器会继承宿主机的 DNS 配置，行为与宿主机一致。</li>
<li><strong>容器服务发现</strong>：Docker DNS 服务器知道当前主机上所有容器的 <strong>IP</strong> 地址，可以实现<strong>容器名解析</strong>。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>内置服务发现：容器名解析</strong><br>这是 Docker 网络最强大的功能之一。在<strong>用户自定义的桥接网络</strong>中，Docker 提供了一个内置的 DNS 服务器，允许容器通过<strong>容器名</strong>或<strong>服务名</strong>（在 Docker Compose 中）直接互相访问。</li>
</ol>
<p>示例：创建一个自定义网络并运行两个容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建自定义网络</span></span><br><span class="line">docker network create mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行一个名为 &#x27;nginx&#x27; 的容器，加入 mynet 网络</span></span><br><span class="line">docker run -d --name nginx --network mynet nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行一个临时测试容器，也加入 mynet 网络</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --network mynet alpine ping nginx</span><br></pre></td></tr></table></figure>
<p>在 <code>alpine</code> 容器中，你可以直接 <code>ping nginx</code>。Docker 的内置 DNS 会自动将 <code>nginx</code> 解析为对应容器的 IP 地址。</p>
<h4 id="自定义容器的-DNS-配置"><a href="#自定义容器的-DNS-配置" class="headerlink" title="自定义容器的 DNS 配置"></a>自定义容器的 DNS 配置</h4><p>可以通过多种方式覆盖 Docker 的默认 DNS 行为。</p>
<ol>
<li><strong>在 <code>docker run</code> 时通过参数配置</strong><br>这是最直接的方式。<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>--dns &lt;IP_ADDRESS&gt;</code></td>
<td>指定自定义的 DNS 服务器</td>
<td><code>--dns 8.8.8.8 </code></td>
</tr>
<tr>
<td><code>--dns-search &lt;DOMAIN&gt;</code></td>
<td>指定 DNS 搜索域</td>
<td><code>--dns-search example.com</code></td>
</tr>
<tr>
<td><code>--dns-opt &lt;OPTION&gt;</code></td>
<td>指定 DNS 解析器选项</td>
<td><code>--dns-opt attempts:3 </code></td>
</tr>
<tr>
<td><code>--hostname &lt;HOSTNAME&gt;</code> <code>--h &lt;HOSTNAME&gt;</code></td>
<td>设置容器的主机名，会影响到 <code>hostname -f</code> 的返回结果</td>
<td><code>--hostname mycontainer</code> <code>--h mycontainer</code></td>
</tr>
<tr>
<td><code>--add-host &lt;HOST:IP&gt;</code></td>
<td>手动添加一条记录到容器的 <code>/etc/hosts</code> 文件</td>
<td><code>--add-host db.local:192.168.1.100</code></td>
</tr>
</tbody></table>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> \</span><br><span class="line">  --dns 1.1.1.1 \                    <span class="comment"># 使用 Cloudflare 的 DNS</span></span><br><span class="line">  --dns 8.8.8.8 \                    <span class="comment"># 添加 Google DNS 作为备用</span></span><br><span class="line">  --dns-search mycompany.internal \  <span class="comment"># 设置搜索域，访问 &#x27;db&#x27; 会尝试 &#x27;db.mycompany.internal&#x27;</span></span><br><span class="line">  --dns-opt <span class="built_in">timeout</span>:2 \              <span class="comment"># 设置 DNS 查询超时为 2 秒</span></span><br><span class="line">  --add-host my-custom-host:10.10.10.10 \ <span class="comment"># 手动添加主机映射</span></span><br><span class="line">  alpine <span class="built_in">cat</span> /etc/resolv.conf        <span class="comment"># 查看容器最终的 DNS 配置</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>修改 Docker 守护进程配置（全局默认）</strong><br>修改 <code>/etc/docker/daemon.json</code> 文件（Linux 系统），可以设置所有容器的<strong>默认</strong> DNS 配置。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;8.8.8.8&quot;</span><span class="punctuation">,</span> <span class="string">&quot;1.1.1.1&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dns-search&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;global.example.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dns-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;timeout:2&quot;</span><span class="punctuation">,</span> <span class="string">&quot;attempts:3&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>修改后需要重启 Docker 服务才能生效：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>此后，所有新创建的容器都会默认使用这些 DNS 配置（除非被 <code>docker run</code> 的参数覆盖）。</p>
<h4 id="配置文件：-etc-resolv-conf"><a href="#配置文件：-etc-resolv-conf" class="headerlink" title="配置文件：/etc/resolv.conf"></a>配置文件：<code>/etc/resolv.conf</code></h4><p>容器内部的 DNS 解析行为最终是由 <code>/etc/resolv.conf</code> 文件决定的。Docker 会在容器启动时自动生成这个文件。</p>
<p>可以通过 <code>docker exec</code> 查看这个文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> &lt;container_id&gt; <span class="built_in">cat</span> /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">nameserver 127.0.0.11    <span class="comment"># Docker 内置 DNS 转发器的地址</span></span><br><span class="line">options ndots:0          <span class="comment"># DNS 解析选项</span></span><br><span class="line">search localdomain       <span class="comment"># 搜索域</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>nameserver</code>：指明了容器使用的 DNS 服务器地址。</li>
<li><code>search</code>：定义了搜索域列表。如果访问的主机名不带点（如 <code>ping db</code>），系统会依次尝试 <code>db</code>、<code>db.search_domain1</code>、<code>db.search_domain2</code>。</li>
<li><code>options</code>：用于微调解析器的行为，最常见的是 <code>ndots</code>。</li>
</ul>
<p><strong>关于 <code>ndots</code> 选项</strong><br>这是一个高级但重要的选项。它规定了一个域名中必须包含<strong>多少个点（.）</strong>，系统才会在尝试搜索域之前<strong>首先直接查询</strong>。</p>
<ul>
<li><strong>默认值</strong>：Docker 通常设置为 <code>ndots:0</code>，意味着任何非空域名都会先直接查询。</li>
<li><strong>常见值</strong>：很多系统默认是 <code>ndots:1</code>。这意味着像 <code>api.service.consul</code> 这样的名字（有2个点）会被直接查询，而像 <code>redis</code> 这样的名字（0个点）会先加上搜索域（如 <code>redis.cluster.local</code>）进行查询。</li>
</ul>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>配置场景</th>
<th>推荐方法</th>
<th>作用域</th>
</tr>
</thead>
<tbody><tr>
<td><strong>默认行为</strong></td>
<td>无需配置</td>
<td>使用宿主机DNS，支持自定义网络的服务发现</td>
</tr>
<tr>
<td><strong>为单个容器定制</strong></td>
<td><code>docker run --dns ...</code></td>
<td>只影响该容器</td>
</tr>
<tr>
<td><strong>为所有容器设置默认值</strong></td>
<td>修改 <code>/etc/docker/daemon.json</code></td>
<td>全局影响，可作为公司策略</td>
</tr>
<tr>
<td><strong>硬编码解析</strong></td>
<td><code>docker run --add-host ...</code></td>
<td>适用于开发、测试或绕过DNS</td>
</tr>
</tbody></table>
<ul>
<li>在生产环境中，通常建议显式设置 <code>--dns</code> 指向可靠的内网或公共 DNS（如 <code>8.8.8.8</code>），而不是完全依赖宿主机配置。</li>
<li>充分利用 Docker <code>自定义网络的服务发现</code>功能，这是实现微服务之间通信的最佳方式。</li>
<li>遇到网络问题时，首先使用<code>cat /etc/resolv.conf</code> 和 <code>ping</code>。</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用:</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件&#x2F;目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /usr/src/app/</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 <strong>Go</strong> 的 <a target="_blank" rel="noopener" href="https://pkg.go.dev/path/filepath#Match">filepath.Match</a>规则，如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hom?.txt /mydir/</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p><strong>注意</strong>：使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 <strong>Git</strong> 进行管理的时候。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，<strong>Docker</strong> 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果要修改权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。<br>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在 <strong>Docker</strong> 官方的 <a target="_blank" rel="noopener" href="https://docs.docker.com/build/building/best-practices/">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是需要自动解压缩的场合。</p>
<p>注意，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=bin files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=1 files* /mydir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> --<span class="built_in">chown</span>=10:11 files* /mydir/</span></span><br></pre></td></tr></table></figure>

<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p><strong>Docker</strong> 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 <strong>JSON</strong> 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在实际执行中，会将其变更为：</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$HOME</span>&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>这就是为什么可以使用环境变量的原因，因为这些环境变量会被 <code>shell</code> 进行解析处理。</p>
<p><strong>Docker</strong> 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>错误示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> service nginx start  <span class="comment"># 容器执行后就立即退出</span></span></span><br></pre></td></tr></table></figure>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 <strong>upstart</strong> 来以后台守护进程形式启动 <code>nginx</code> 服务。而 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式两种。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">&quot;&lt;CMD&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol>
<li>让镜像变成像命令一样使用</li>
</ol>
<p>假设需要一个得知自己当前公网 <strong>IP</strong> 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>假如使用 <code>docker build -t myip . </code>来构建镜像的话，如果我们需要查询当前公网 <strong>IP</strong>，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：36.170.44.64  来自于：中国 四川 成都  移动</span><br></pre></td></tr></table></figure>
<p>看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果希望显示 <strong>HTTP</strong> 头信息，就需要加上 <code>-i</code> 参数。那么可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in <span class="variable">$PATH</span>\&quot;\n&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>可以看到可执行文件找不到的报错，<code>executable file not found</code>。跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果希望加入 <code>-i</code> 这参数，就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http://myip.ipip.net -i</span><br></pre></td></tr></table></figure>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>这次尝试直接使用 <code>docker run myip -i</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：36.170.44.64  来自于：中国 四川 成都  移动</span><br><span class="line"></span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 09 Sep 2025 04:13:08 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">Content-Length: 67</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: WAF</span><br><span class="line">Access-Control-Allow-Headers: *</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: *</span><br><span class="line">X-Request-Id: 8528bc292eef4f9ef656601b5a3cb160</span><br><span class="line">X-Cache: BYPASS</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line">当前 IP：36.170.44.64  来自于：中国 四川 成都  移动</span><br></pre></td></tr></table></figure>
<p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了预期的效果。</p>
<ol start="2">
<li>应用运行前的准备工作</li>
</ol>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 <code>mysql</code> 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.4</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> addgroup -S redis &amp;&amp; adduser -S -G redis redis</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6379</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>可以看到其中为了 <strong>redis</strong> 服务创建了 <strong>redis</strong> 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">	find . \! -user redis -<span class="built_in">exec</span> <span class="built_in">chown</span> redis <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line">	<span class="built_in">exec</span> gosu redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis <span class="built_in">id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root)</span><br></pre></td></tr></table></figure>

<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>设置环境变量，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。格式： </p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span> DEBUG=on \</span><br><span class="line">    NAME=<span class="string">&quot;Happy Feet&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 <strong>Shell</strong> 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="built_in">sha256sum</span> -c - \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span></span><br></pre></td></tr></table></figure>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p>
<p>从这个指令列表里可以感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> <code>中的</code> ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>灵活的使用 <code>ARG</code> 指令，能够在不修改 <strong>Dockerfile</strong> 的情况下，构建出不同的镜像。</p>
<p><strong>ARG</strong> 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"><span class="comment"># 无法输出 $&#123;DOCKER_USERNAME&#125; 变量的值</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法：</span></span><br><span class="line"><span class="comment"># 只在 FROM 中生效</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"><span class="comment"># 要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>对于多阶段构建，尤其要注意这个问题</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个变量在每个 FROM 中都生效</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine  <span class="comment"># DOCKER_USERNAME = library</span></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library2</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span>  <span class="comment"># DOCKER_USERNAME = library2</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine  <span class="comment"># DOCKER_USERNAME = library</span></span><br><span class="line"><span class="comment"># 在FROM 之后使用变量，必须在每个阶段分别指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library3</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span>  <span class="comment"># DOCKER_USERNAME = library3</span></span></span><br></pre></td></tr></table></figure>
<p><strong>Dockerfile</strong> 两个 <code>FROM</code> 指令都可以使用 <code>$&#123;DOCKER_USERNAME&#125;</code>，对于在各个阶段中使用的变量都必须在每个阶段分别指定。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于 <strong>卷(volume)</strong> 中，为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，可以事先指定某些目录挂载为 <strong>匿名卷</strong>，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br></pre></td></tr></table></figure>
<p>这里的<code> /data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>
<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式: <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 <strong>Dockerfile</strong> 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以<strong>方便配置映射</strong>；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会<strong>自动随机映射 <code>EXPOSE</code> 的端口</strong>。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式: <code>WORKDIR &lt;工作目录路径&gt;</code></p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<p>错误示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>
<p>将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 <strong>Shell</strong> 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>
<p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p><strong>注意</strong>: <code>USER</code> 只是帮助切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="keyword">USER</span> redis</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 <strong>TTY</strong> 缺失的环境下经常出错。建议使用 <a target="_blank" rel="noopener" href="https://github.com/tianon/gosu">gosu</a>。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 <strong>Docker</strong> 应该如何进行判断容器的状态是否正常，这是 <strong>Docker 1.12</strong> 引入的新指令。</p>
<p>在没有 <code>HEALTHCHECK</code> 指令前，<strong>Docker</strong> 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，<strong>Docker</strong> 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，<strong>Docker</strong> 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p>
<p>假设有个镜像是个最简单的 <code>Web</code> 服务，希望增加健康检查来判断其 <code>Web</code> 服务是否在正常工作，可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure>
<p>这里设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<ul>
<li><code>curl</code>：一个强大的命令行工具，用于传输数据（这里用于发起 HTTP 请求）。</li>
<li><code>-f</code> 或 <code>--fail</code>：让 <code>curl</code> 在服务器返回错误状态码（如 404, 500）时<strong>返回一个非零的退出码</strong>，而不是输出错误页面内容。这对于健康检查至关重要，因为需要根据退出码判断成功与否。</li>
<li><code>-s</code> 或 <code>--silent</code>：让 <code>curl</code> 以<strong>静默模式</strong>运行，不输出进度、错误等任何额外信息，避免健康检查日志变得混乱。</li>
<li><code>http://localhost/</code>：这是要检查的目标 URL。它假设容器内运行的应用程序（例如一个 Web 服务器）正在监听 80 端口，并且根路径（<code>/</code>）可以返回一个成功的 HTTP 响应（如 200 OK）。</li>
<li><code>||</code>：Linux 中的<strong>逻辑或</strong>操作符。意思是：如果 <code>||</code> 前面的命令<strong>执行失败</strong>（返回非零退出码），则执行 <code>||</code> 后面的命令。</li>
<li><code>exit 1</code>：这是一个 <strong>Shell</strong> 命令，表示<strong>以状态码 1 退出</strong>。在 Unix&#x2F;Linux 系统中，退出码 <strong>0</strong> 代表<strong>成功</strong>，任何<strong>非零值</strong>都代表<strong>失败</strong>。</li>
</ul>
<p><strong>整个 <code>CMD</code> 的逻辑是</strong>：尝试用 <code>curl</code> 访问 <code>http://localhost/</code>。如果访问成功（服务正常响应），<code>curl</code> 自己会返回 0，整个命令就成功了。如果访问失败（服务无响应、返回错误码或超时），<code>curl -f</code> 会返回非零值，这时就会执行 <code>exit 1</code>，确保整个健康检查命令的最终退出码是非零的（失败）。</p>
<p>可以使用 <code>docker inspect</code> 命令查看详细的健康状态历史记录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> &lt;container-name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="LABEL-指令"><a href="#LABEL-指令" class="headerlink" title="LABEL 指令"></a>LABEL 指令</h3><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>可以用一些标签来申明镜像的作者、文档地址等：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;South&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.documentation=<span class="string">&quot;https://xiangnan321.github.io&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>具体可以参考 <a target="_blank" rel="noopener" href="https://github.com/opencontainers/image-spec/blob/master/annotations.md">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p>
<h3 id="SHELL-指令"><a href="#SHELL-指令" class="headerlink" title="SHELL 指令"></a>SHELL 指令</h3><p>格式：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p>
<p><strong><code>SHELL</code> 指令可以定制 Docker 容器构建和运行时所使用的“命令解释器”及其默认行为。</strong> <code>SHELL</code> 指令用于更<strong>改 Docker 在执行 <code>RUN</code>、<code>CMD</code> 和 <code>ENTRYPOINT</code> 指令时使用的默认 shell</strong>。</p>
<p>在 Linux 系统中，默认的 shell 通常是 <code>/bin/s</code>h。在 Windows 容器中，默认的 shell 是 <code>cmd /S /C</code>。<code>SHELL</code> 指令允许你覆盖这个默认行为。</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ol>
<li>切换默认 Shell 程序</li>
</ol>
<p>不同的 shell 有不同的特性和语法。最常见的切换是从 <code>/bin/sh</code>（通常是轻量级的 <code>dash</code>）切换到功能更丰富的 <code>/bin/bash</code>。</p>
<ul>
<li><code>/bin/sh</code> <strong>(dash)</strong>：更轻量、更快速，符合 POSIX 标准，但功能较少（例如不支持数组、某些字符串操作等）。</li>
<li><code>/bin/bash</code>：功能强大，支持很多扩展特性（如 <code>[[ ]]</code> 条件判断、进程替换 &lt;<code>()</code>、数组等），但体积更大。</li>
</ul>
<p>示例：使用 Bash 的特性, 假设想在 Dockerfile 中使用 Bash 的 <code>[[</code> 条件判断，这是 <code>sh</code> 不支持的。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不设置 SHELL，默认用 /bin/sh，下面的命令会失败</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">if</span> [[ -f /app/config ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;Config exists&quot;</span>; <span class="keyword">fi</span></span></span><br><span class="line"><span class="comment"># 错误：/bin/sh: [[: not found</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 SHELL 指令将默认 shell 改为 bash</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">if</span> [[ -f /app/config ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;Config exists&quot;</span>; <span class="keyword">fi</span></span></span><br><span class="line"><span class="comment"># 成功执行</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>为 Shell 设置默认参数</li>
</ol>
<p>可以使用 <code>SHELL</code> 指令为所有后续的 shell 命令设置默认参数，最常见的是 <code>-e</code>（出错退出）和 <code>-x</code>（调试模式）。</p>
<p>示例：为所有 RUN 命令设置 <code>-e</code> 和 <code>-x</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置默认 shell 为 bash，并默认带上 -e (出错退出) 和 -x (打印命令) 参数</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-e&quot;</span>, <span class="string">&quot;-x&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;This command will be printed&quot;</span> <span class="comment"># 会自动加上 -x 效果</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> nonexistent-command <span class="comment"># 命令失败会自动退出构建（-e 效果）</span></span></span><br></pre></td></tr></table></figure>
<p>这比在每个 <code>RUN</code> 指令前手动加 <code>set -ex</code> 要简洁得多。</p>
<ol start="3">
<li>在 Windows 容器中切换 Shell</li>
</ol>
<p>这在 Windows 容器中更为常见，可以在 <code>cmd</code>、<code>powershell</code> 等之间切换。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是 [&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;powershell&quot;</span>, <span class="string">&quot;-command&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在可以使用 PowerShell 命令了</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> Write-Host <span class="string">&quot;Hello from PowerShell&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> Get-Process</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p><strong><code>SHELL</code> 指令会影响到 Dockerfile 中所有在它之后出现的 <code>RUN</code>、<code>CMD</code> 和 <code>ENTRYPOINT</code> 指令</strong>，直到被另一个 <code>SHELL</code> 指令覆盖为止。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认使用 /bin/sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$0</span> <span class="comment"># 输出：sh</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 bash（Alpine 需要先安装 bash）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache bash</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$0</span> <span class="comment"># 输出：bash</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 它会影响后面的 CMD</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;This is still executed with bash because it&#x27;s passed to the shell&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>重要提示：<code>SHELL</code> 指令<strong>不会</strong>影响 <code>CMD</code> 和 <code>ENTRYPOINT</code> 的 <strong>exec 形式</strong>（JSON 数组格式），如果它们使用的是 <strong>shell 形式</strong>（纯字符串），则会受影响。</p>
</blockquote>
<p>实际应用示例:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 场景：在 Alpine 镜像中使用 Bash 特性。 Alpine Linux 以其小巧著称，默认使用 sh (ash)</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 安装 bash</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用 SHELL 指令将默认 shell 改为 bash</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 现在可以使用 bash 特性了</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [[ <span class="string">&quot;abc&quot;</span> == <span class="string">&quot;abc&quot;</span> ]] &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;They are equal&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数组等高级功能</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> fruits=(<span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;cherry&quot;</span>) &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;First fruit: <span class="variable">$&#123;fruits[0]&#125;</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景：统一设置严格错误处理</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置所有后续 shell 命令：使用 bash，遇到错误立即退出，并显示执行过程</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-eux&quot;</span>, <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;pipefail&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Starting complex operation...&quot;</span></span></span><br><span class="line"><span class="comment"># 如果这些步骤中的任何一步失败，整个构建都会立即停止</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install -y some-package &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    configure-something &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    clean-up</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -e: 出错退出</span></span><br><span class="line"><span class="comment"># -u: 使用未定义变量时报错</span></span><br><span class="line"><span class="comment"># -x: 打印执行的命令</span></span><br><span class="line"><span class="comment"># -o pipefail: 确保管道命令中任何一个失败，整个管道就失败</span></span><br></pre></td></tr></table></figure>

<h3 id="ONBUILD-延迟执行指令"><a href="#ONBUILD-延迟执行指令" class="headerlink" title="ONBUILD 延迟执行指令"></a>ONBUILD 延迟执行指令</h3><p><code>ONBUILD</code> 指令是一个<strong>延迟执行</strong>的指令。它不会在构建当前镜像时执行，而是会在<strong>另一个 Dockerfile 以当前镜像为基础镜像（<code>FROM</code>）时</strong>，在那个下游构建过程中触发执行。可以把它想象成在镜像中埋下了一个“触发器”或“回调函数”，当这个镜像被用作“父镜像”时，这个触发器就会被激活。<br><strong><code>ONBUILD</code> 能创建一个“智能的”基础镜像，当别人继承它时，它能自动指导下一步该如何构建。</strong></p>
<p>格式： <code>ONBUILD &lt;其它指令&gt;</code> 。 <code>&lt;其它指令&gt;</code> 可以是几乎任何其他的 Dockerfile 指令，最常见的是：</p>
<ul>
<li><code>ONBUILD RUN ...</code></li>
<li><code>ONBUILD COPY ...</code></li>
<li><code>ONBUILD ADD ...</code></li>
</ul>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>主要目的是<strong>创建可复用的、模板化的基础镜像，用于标准化构建流程。</strong></p>
<p>示例： 创建一个专门用于构建 Python Web 应用的基础镜像。这个镜像已经配置好了所有依赖，但每个应用都有自己的源代码需要被复制进去。</p>
<ol>
<li>基础镜像的 Dockerfile (python-web-builder.Dockerfile):</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 安装公共依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install flask gunicorn</span></span><br><span class="line"><span class="comment"># 设置“触发器”：当有人用我时，请把当前目录的代码复制到 /app 里</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure>
<p>构建这个基础镜像：<code>docker build -t my-python-builder -f python-web-builder.Dockerfile .</code></p>
<ol start="2">
<li>应用项目的 Dockerfile (Dockerfile):</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用上面创建的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> my-python-builder</span><br><span class="line"><span class="comment"># 不需要写 COPY . /app 和 RUN pip install...</span></span><br><span class="line"><span class="comment"># ONBUILD 指令会自动在这里执行！</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;app:app&quot;</span>, <span class="string">&quot;-b&quot;</span>, <span class="string">&quot;0.0.0.0:8000&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li><strong>避免重复</strong>：每个应用项目的 Dockerfile 变得非常简洁，无需重复编写相同的代码复制和依赖安装命令。</li>
<li><strong>强制标准化</strong>：确保了所有基于该模板的项目都遵循相同的构建流程。</li>
<li>关<strong>注点分离</strong>：基础镜像的维护者负责通用设置，应用开发者只需关心自己的代码。</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><strong>记录阶段</strong>：当构建包含 <code>ONBUILD</code> 的镜像（称之为 <code>基础镜像</code>）时，Docker 不会执行 ONBUILD 后面的指令，而是<strong>将这些指令记录下来</strong>，存储在镜像的元数据中。</li>
<li><strong>触发阶段</strong>：当另一个 Dockerfile 使用 <code>FROM &lt;基础镜像&gt;</code> 时，在构建这个<strong>下游镜像</strong>的过程中，Docker 会在执行完 <code>FROM</code> 指令后，立即自动执行所有在基础镜像中记录的 <code>ONBUILD</code> 指令。</li>
</ol>
<p>执行顺序类比： 下游镜像的构建过程相当于：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-python-builder</span><br><span class="line"><span class="comment"># &lt;-- 在这里，Docker 会自动插入所有来自 my-python-builder 的 ONBUILD 指令</span></span><br><span class="line"><span class="comment"># ONBUILD COPY . /app</span></span><br><span class="line"><span class="comment"># ONBUILD RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;app:app&quot;</span>, <span class="string">&quot;-b&quot;</span>, <span class="string">&quot;0.0.0.0:8000&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="查看和管理-ONBUILD-指令"><a href="#查看和管理-ONBUILD-指令" class="headerlink" title="查看和管理 ONBUILD 指令"></a>查看和管理 <code>ONBUILD</code> 指令</h4><p>使用 <code>docker inspect</code> 命令来查看一个镜像中设置了哪些 <code>ONBUILD</code> 触发器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker inspect my-python-builder --format=<span class="string">&#x27;&#123;&#123;json .ContainerConfig.OnBuild&#125;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者查看更完整的元信息：</span></span><br><span class="line">docker inspect my-python-builder</span><br><span class="line"><span class="comment"># 在输出的 JSON 中，找到 ContainerConfig.OnBuild 字段，它会列出所有延迟执行的指令。</span></span><br></pre></td></tr></table></figure>

<h4 id="注意事项和最佳实践"><a href="#注意事项和最佳实践" class="headerlink" title="注意事项和最佳实践"></a>注意事项和最佳实践</h4><ol>
<li><strong>谨慎使用</strong>：<code>ONBUILD</code> 指令具有“魔法”效果，可能会让不熟悉该基础镜像的开发者感到困惑。必须清晰地文档化基础镜像的 <code>ONBUILD</code> 行为。</li>
<li><strong>不能嵌套</strong>：<code>ONBUILD</code> 指令不能触发另一个 <code>ONBUILD</code>。即，在 <code>ONBUILD</code> 后面不能跟 <code>ONBUILD</code>。</li>
<li><strong>有限制的指令</strong>：<code>FROM</code>, <code>MAINTAINER</code>, 以及另一个 <code>ONBUILD</code> <strong>不能</strong>作为 <code>ONBUILD</code> 的触发器。这是为了防止产生无限递归的定义。</li>
<li><strong>用途明确</strong>：<code>ONBUILD</code> 最适合用于<strong>构建环境的镜像</strong>，而不是用于<strong>运行时的应用程序镜像</strong>。例如，一个包含编译器、构建工具的基础镜像很适合使用 <code>ONBUILD</code> 来拷贝源代码并执行编译。</li>
<li><strong>一次性的构建器模式</strong>：一种常见模式是创建一个专门用于构建的“ builder ”镜像，其中包含 <code>ONBUILD</code> 指令来执行编译。应用程序的最终运行镜像则使用一个更小的、不含 <code>ONBUILD</code> 的运行时基础镜像（如 <code>alpine</code>），仅复制构建好的成品（如二进制文件）。</li>
</ol>
<h4 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h4><ul>
<li><strong>语言运行环境</strong>：如上述 Python、Node.js（<code>ONBUILD COPY . /src</code> <code>ONBUILD RUN npm install</code>）、Ruby 等基础镜像。</li>
<li><strong>静态网站生成器</strong>：一个已安装 Hugo、Hexo 等工具的基础镜像，<code>ONBUILD COPY . /site</code> 来复制源文件，<code>ONBUILD RUN generate</code> 来生成静态页面。</li>
<li><strong>通用构建器</strong>：一个包含了构建工具（如 <code>make</code>, <code>gcc</code>）的镜像，<code>ONBUILD</code> 指令负责拷贝代码并执行编译。</li>
</ul>
<h3 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h3><h4 id="Docker-17-05-版本之前"><a href="#Docker-17-05-版本之前" class="headerlink" title="Docker 17.05 版本之前"></a>Docker 17.05 版本之前</h4><p>Docker 17.05 版本之前 Docker 镜像时，通常会采用两种方式：</p>
<h5 id="全部放入一个-Dockerfile"><a href="#全部放入一个-Dockerfile" class="headerlink" title="全部放入一个 Dockerfile"></a>全部放入一个 Dockerfile</h5><p>将所有的构建过程编包含在一个 <code>Dockerfile</code> 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p>
<ul>
<li>镜像层次多，镜像体积较大，部署时间变长</li>
<li>源代码存在泄露的风险</li>
</ul>
<p>例如，编写 <code>app.go</code> 文件，该程序输出 <code>Hello World!</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写 <code>Dockerfile.one</code> 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">cp</span> /go/src/github.com/go/helloworld/app /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t go/helloworld:1 -f Dockerfile.one .</span><br></pre></td></tr></table></figure>

<h5 id="分散到多个-Dockerfile"><a href="#分散到多个-Dockerfile" class="headerlink" title="分散到多个 Dockerfile"></a>分散到多个 Dockerfile</h5><p>事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p>
<p>例如，编写 <code>Dockerfile.build</code> 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br></pre></td></tr></table></figure>
<p>编写 <code>Dockerfile.copy</code> 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>新建 <code>build.sh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> Building go/helloworld:build</span><br><span class="line"></span><br><span class="line">docker build -t go/helloworld:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract go/helloworld:build</span><br><span class="line">docker <span class="built_in">cp</span> extract:/go/src/github.com/go/helloworld/app ./app</span><br><span class="line">docker <span class="built_in">rm</span> -f extract</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Building go/helloworld:2</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy</span><br><span class="line"><span class="built_in">rm</span> ./app</span><br></pre></td></tr></table></figure>
<p>现在运行脚本即可构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> +x build.sh</span><br><span class="line"></span><br><span class="line">$ ./build.sh</span><br></pre></td></tr></table></figure>
<p>对比两种方式生成的镜像大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY      TAG    IMAGE ID        CREATED         SIZE</span><br><span class="line">go/helloworld   2      f7cf3465432c    22 seconds ago  6.47MB</span><br><span class="line">go/helloworld   1      f55d3e16affc    2 minutes ago   295MB</span><br></pre></td></tr></table></figure>

<h4 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>为解决以上问题，<code>Docker v17.05</code> 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p>
<p>例如，编写 Dockerfile 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用一个包含 Go 编译工具的镜像作为基础 golang:alpine：官方 Golang 镜像的 Alpine Linux 版本，非常小巧。 </span></span><br><span class="line"><span class="comment"># as builder：为此构建阶段命名（别名为 builder）。这是多阶段构建的关键，允许后续阶段通过此名称引用它</span></span><br><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Git。 apk：Alpine Linux 的包管理工具。 --no-cache：安装软件包时不缓存包索引，以减小镜像层大小。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并安装项目的依赖库。 go get：Go 语言的包获取命令。 -d：只下载（Download），不编译和安装。</span></span><br><span class="line"><span class="comment"># -v：显示详细的输出（Verbose）。 github.com/go-sql-driver/mysql：一个流行的 Go MySQL 数据库驱动。这表明 app.go 是一个需要连接 MySQL 的应用程序。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将宿主机的应用程序源代码文件 app.go 复制到当前容器的工作目录。</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 Go 代码，生成一个静态链接的二进制文件。</span></span><br><span class="line"><span class="comment"># CGO_ENABLED=0：禁用 CGO。这意味着程序将不会链接到 C 库，从而生成完全静态的二进制文件，可以在任何 Linux 环境（包括没有 C 库的 alpine）中运行。 GOOS=linux：明确指定目标操作系统为 Linux。 </span></span><br><span class="line"><span class="comment"># -a：强制重新编译所有包，确保依赖也是静态链接的。 -installsuffix cgo：将输出文件安装到一个带有 cgo 后缀的目录中，与启用 CGO 的构建分开，避免混淆。</span></span><br><span class="line"><span class="comment"># -o app：指定输出的可执行文件名为 app。 `.`：编译当前目录的代码。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启一个全新的、干净的构建阶段。alpine:latest：使用最基础的 Alpine Linux 镜像，体积非常小（约 5MB）。 as prod：为此阶段命名（别名为 prod）。</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 CA 证书包。 ca-certificates：包含公认的根证书颁发机构（CA）的证书。如果应用程序需要与外部 HTTPS 服务（如 MySQL 数据库、API 等）进行安全通信，这是必需的。没有它，SSL/TLS 握手会失败。</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将工作目录设置为 root 用户的家目录。</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多阶段构建的精髓！ --from=0 或 --from=builder：从之前的 builder 阶段（索引为 0 的第一个阶段）复制文件，而不是从宿主机复制。</span></span><br><span class="line"><span class="comment"># `.`：目标路径，当前工作目录（即 /root/）。 效果：最终的生产镜像 (prod) 只包含了 builder 阶段的成果（app 文件），而完全不包含 builder 阶段的所有中间层（Go 编译器、Git、源代码等）。</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动时默认执行的命令。</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t go/helloworld:3 .</span><br></pre></td></tr></table></figure>
<p>对比三个镜像大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY        TAG   IMAGE ID         CREATED            SIZE</span><br><span class="line">go/helloworld     3     d6911ed9c846     7 seconds ago      6.47MB</span><br><span class="line">go/helloworld     2     f7cf3465432c     22 seconds ago     6.47MB</span><br><span class="line">go/helloworld     1     f55d3e16affc     2 minutes ago      295MB</span><br></pre></td></tr></table></figure>
<p>优势：</p>
<ul>
<li><strong>极小的镜像体积</strong>：最终镜像可能只有 10MB 左右，而如果使用完整的 <code>golang:alpine</code> 作为运行镜像，体积会超过 300MB。这减少了存储、传输和部署的开销。</li>
<li><strong>极高的安全性</strong>：攻击面大大减小。生产镜像中不包含编译器、Git、源代码等任何不必要的工具和文件，降低了被攻击的风险。</li>
<li><strong>清晰的分层</strong>：构建环境和运行环境完全分离，符合最佳实践。</li>
</ul>
<h5 id="只构建某一阶段的镜像"><a href="#只构建某一阶段的镜像" class="headerlink" title="只构建某一阶段的镜像"></a>只构建某一阶段的镜像</h5><p>可以使用 <code>as</code> 来为某一阶段命名，例如</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br></pre></td></tr></table></figure>
<p>例如当只想构建 <code>builder</code> 阶段的镜像时，增加 <code>--target=builder</code> 参数即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --target builder -t username/imagename:tag .</span><br></pre></td></tr></table></figure>

<h5 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h5><p>上面例子中使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，也可以复制任意镜像中的文件。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br></pre></td></tr></table></figure>


<h3 id="构建多种系统架构支持的-Docker-镜像-–-docker-manifest-命令"><a href="#构建多种系统架构支持的-Docker-镜像-–-docker-manifest-命令" class="headerlink" title="构建多种系统架构支持的 Docker 镜像 – docker manifest 命令"></a>构建多种系统架构支持的 Docker 镜像 – docker manifest 命令</h3><p><code>manifest</code> 命令。用于管理多平台镜像清单的高级工具，对于需要支持多种 CPU 架构（如 AMD64, ARM64）的场景至关重要。<strong>目标：实现“一次拉取，处处运行”。</strong></p>
<p><strong>镜像清单</strong>和<strong>多平台镜像</strong>。</p>
<ol>
<li><strong>镜像（Image）</strong>：通常拉取和运行的，比如 <code>nginx:latest</code>。</li>
<li><strong>清单（Manifest）</strong>：一个描述符文件，它指向另一个清单或一个真实的镜像层。它本身不是镜像，而是镜像的“目录”或“指针”。</li>
</ol>
<p><strong>单平台镜像的简单情况</strong><br>当为一种平台（例如，在 Intel&#x2F;AMD 电脑上为 Linux AMD64）构建镜像时，Docker 会创建一个<strong>镜像清单</strong>，它直接指向构成该镜像的各个层（layer）。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户请求 `nginx:latest`</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">Manifest (指向) --&gt; Layer 1, Layer 2, ... (AMD64 架构的镜像层)</span><br></pre></td></tr></table></figure>
<p><strong>多平台镜像的复杂情况（<code>manifest</code> 命令的用武之地）</strong><br>如何让同一个镜像标签（如 <code>nginx:latest</code>）支持多种平台（如 AMD64, ARM64, ARMv7）？答案是：创建一个清单列表。</p>
<p>这个清单列表包含了对不同平台特定镜像的引用。Docker 客户端会根据运行命令的机器平台，自动选择列表中对应的正确镜像。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用户请求 `nginx:latest`</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">Manifest List (清单列表)</span><br><span class="line">    |</span><br><span class="line">    |--&gt; Manifest for linux/amd64 --&gt; (AMD64 镜像层)</span><br><span class="line">    |--&gt; Manifest for linux/arm64 --&gt; (ARM64 镜像层)</span><br><span class="line">    |--&gt; Manifest for linux/arm/v7 --&gt; (ARMv7 镜像层)</span><br></pre></td></tr></table></figure>
<p><code>docker manifest</code> <strong>命令就是用来创建、查看和操作这个“清单列表”的工具。</strong></p>
<h4 id="启用-manifest-命令"><a href="#启用-manifest-命令" class="headerlink" title="启用 manifest 命令"></a>启用 <code>manifest</code> 命令</h4><p><code>docker manifest</code> 是一个实验性命令。需要先启用它才能使用。<br>在 <code>~/.docker/config.json</code> 文件（Linux&#x2F;macOS）中设置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="string">&quot;enabled&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后重启 Docker Desktop 或重新加载配置。</p>
<p>也可以通过环境变量临时启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DOCKER_CLI_EXPERIMENTAL=enabled</span><br></pre></td></tr></table></figure>
<p>验证是否启用成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker manifest --version</span><br></pre></td></tr></table></figure>

<h4 id="主要子命令详解"><a href="#主要子命令详解" class="headerlink" title="主要子命令详解"></a>主要子命令详解</h4><ol>
<li><strong><code>docker manifest create</code> - 创建清单列表</strong><br>将多个不同平台的镜像合并到一个清单列表下，并指定一个统一的标签。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker manifest create &lt;目标标签&gt; &lt;镜像1&gt; &lt;镜像2&gt; ...</span><br></pre></td></tr></table></figure>
<p>示例：为 <code>my-app:latest</code> 标签创建支持 <strong>AMD64</strong> 和 <strong>ARM64</strong> 的清单。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设已经为不同平台构建并推送了镜像</span></span><br><span class="line"><span class="comment"># - username/my-app:latest-amd64</span></span><br><span class="line"><span class="comment"># - username/my-app:latest-arm64v8</span></span><br><span class="line"></span><br><span class="line">docker manifest create username/my-app:latest \</span><br><span class="line">  username/my-app:latest-amd64 \</span><br><span class="line">  username/my-app:latest-arm64v8</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>docker manifest annotate</code> - 为清单添加注释</strong><br>在创建清单列表后，需要为列表中的每个镜像指定其对应的平台信息。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker manifest annotate &lt;目标标签&gt; &lt;镜像&gt; --os &lt;操作系统&gt; --<span class="built_in">arch</span> &lt;架构&gt; [--variant &lt;变体&gt;]</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 AMD64 镜像添加平台注释</span></span><br><span class="line">docker manifest annotate username/my-app:latest \</span><br><span class="line">  username/my-app:latest-amd64 \</span><br><span class="line">  --os linux --<span class="built_in">arch</span> amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 ARM64 镜像添加平台注释</span></span><br><span class="line">docker manifest annotate username/my-app:latest \</span><br><span class="line">  username/my-app:latest-arm64v8 \</span><br><span class="line">  --os linux --<span class="built_in">arch</span> arm64 --variant v8</span><br></pre></td></tr></table></figure>
<p>注意：较新版本的 Docker 在 <code>create</code> 时可能能自动推断平台信息，但 <code>annotate</code> 提供了更精确的控制。</p>
<ol start="3">
<li><strong><code>docker manifest push</code> - 推送清单列表到仓库</strong><br>将创建好的清单列表推送到 Docker Hub 等镜像仓库。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker manifest push username/my-app:latest</span><br></pre></td></tr></table></figure>
<p>推送后，当用户在不同平台的机器上执行 <code>docker pull username/my-app:latest</code> 时，Docker 会自动拉取适合其平台的镜像。</p>
<ol start="4">
<li><strong><code>docker manifest inspect</code> - 查看清单详情</strong><br>查看一个镜像标签的清单列表内容，这是最常用的命令之一。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker manifest inspect &lt;镜像标签&gt;</span><br></pre></td></tr></table></figure>
<p>示例：查看官方 <code>nginx:latest</code> 镜像支持的平台。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker manifest inspect nginx:latest</span><br></pre></td></tr></table></figure>
<p>输出会是一个 JSON，清晰地列出了 <code>manifests</code> 数组，其中包含每个支持的平台及其对应镜像的摘要（digest）。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;schemaVersion&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;manifests&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:...&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> xxx<span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;digest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:...&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;platform&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;architecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arm64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;variant&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v8&quot;</span></span><br><span class="line">         <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>完整工作流程示例</strong><br>假设有一个 Go 应用，需要为 AMD64 和 ARM64 架构构建镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 构建并推送不同平台的镜像</span></span><br><span class="line">docker build --platform linux/amd64 -t username/myapp:1.0-amd64 .</span><br><span class="line">docker push username/myapp:1.0-amd64</span><br><span class="line"></span><br><span class="line">docker build --platform linux/arm64 -t username/myapp:1.0-arm64 .</span><br><span class="line">docker push username/myapp:1.0-arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建清单列表</span></span><br><span class="line">docker manifest create username/myapp:1.0 \</span><br><span class="line">  username/myapp:1.0-amd64 \</span><br><span class="line">  username/myapp:1.0-arm64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加注释（如果Docker没有自动正确设置）</span></span><br><span class="line">docker manifest annotate username/myapp:1.0 username/myapp:1.0-amd64 --os linux --<span class="built_in">arch</span> amd64</span><br><span class="line">docker manifest annotate username/myapp:1.0 username/myapp:1.0-arm64 --os linux --<span class="built_in">arch</span> arm64 --variant v8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 推送清单列表</span></span><br><span class="line">docker manifest push username/myapp:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 验证</span></span><br><span class="line">docker manifest inspect username/myapp:1.0</span><br></pre></td></tr></table></figure>
<p>现在，任何用户都可以简单地运行 <code>docker run username/myapp:1.0</code>，Docker 会自动为他们选择正确的镜像。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td>manifest create</td>
<td>创建一个“清单列表”，将多个平台特定的镜像关联到一个标签下。</td>
<td>制作一本书的目录，列出不同语言的版本所在页码。</td>
</tr>
<tr>
<td>manifest annotate</td>
<td>精确指定列表中每个镜像对应的平台（OS&#x2F;Arch）。</td>
<td>在目录中注明哪一页是英文版，哪一页是中文版。</td>
</tr>
<tr>
<td>manifest push</td>
<td>将这个“目录”（清单列表）发布出去。</td>
<td>出版这本带有多语言目录的书。</td>
</tr>
<tr>
<td>manifest inspect</td>
<td>查看一个镜像标签背后支持的平台列表。</td>
<td>查看书的目录，了解它有哪些语言的版本。</td>
</tr>
</tbody></table>
<p><strong><code>docker manifest</code> 命令是构建真正跨平台容器化应用的关键工具，它让“编写一次，到处运行”的梦想在容器世界成为现实。</strong></p>
<h3 id="Docker-Buildx"><a href="#Docker-Buildx" class="headerlink" title="Docker Buildx"></a>Docker Buildx</h3><p><strong>Docker Buildx 是 Docker 的下一代镜像构建工具</strong>，它基于 <a target="_blank" rel="noopener" href="https://github.com/moby/buildkit">BuildKit</a> 构建引擎，提供了比传统 <code>docker build</code> 更强大、更灵活的功能。</p>
<h4 id="核心特点："><a href="#核心特点：" class="headerlink" title="核心特点："></a>核心特点：</h4><ul>
<li><strong>多架构构建</strong>：轻松构建支持多种 CPU 架构的镜像</li>
<li><strong>并行构建</strong>：提高构建性能</li>
<li><strong>更高效的缓存机制</strong>：加快重复构建速度</li>
<li><strong>可扩展的构建器实例</strong>：支持本地和远程构建</li>
<li><strong>更安全的 Secret 管理</strong>：构建时安全地使用敏感信息</li>
</ul>
<h4 id="传统-docker-build-的局限性"><a href="#传统-docker-build-的局限性" class="headerlink" title="传统 docker build 的局限性"></a>传统 <code>docker build</code> 的局限性</h4><p>在理解 Buildx 之前，先看看传统构建的问题：</p>
<ol>
<li><strong>单架构构建</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式只能在当前机器架构上构建</span></span><br><span class="line">docker build -t my-app .</span><br><span class="line"><span class="comment"># 在 Intel Mac 上只能构建 amd64 镜像</span></span><br><span class="line"><span class="comment"># 在 M1/M2 Mac 上只能构建 arm64 镜像</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>性能限制</strong></li>
</ol>
<ul>
<li>顺序执行构建步骤</li>
<li>缓存机制相对简单</li>
<li>无法充分利用多核性能</li>
</ul>
<ol start="3">
<li>缺乏高级功能</li>
</ol>
<ul>
<li>没有安全的 secret 管理</li>
<li>构建输出格式单一</li>
<li>难以实现复杂的构建流水线</li>
</ul>
<h4 id="Docker-Buildx-的核心功能详解"><a href="#Docker-Buildx-的核心功能详解" class="headerlink" title="Docker Buildx 的核心功能详解"></a>Docker Buildx 的核心功能详解</h4><h5 id="多平台构建（最重要的功能）"><a href="#多平台构建（最重要的功能）" class="headerlink" title="多平台构建（最重要的功能）"></a>多平台构建（最重要的功能）</h5><p>Buildx 可以<strong>一次性为多个平台构建镜像</strong>，并创建统一的 manifest list。</p>
<p><strong>传统方式 vs Buildx 方式</strong></p>
<p>传统方式（繁琐）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要为每个平台单独构建并手动创建 manifest</span></span><br><span class="line">docker build --platform linux/amd64 -t my-app:amd64 .</span><br><span class="line">docker build --platform linux/arm64 -t my-app:arm64 .</span><br><span class="line">docker manifest create my-app:latest my-app:amd64 my-app:arm64</span><br><span class="line">docker manifest push my-app:latest</span><br></pre></td></tr></table></figure>

<p>Buildx 方式（简单）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一条命令构建多个平台并推送</span></span><br><span class="line">docker buildx build --platform linux/amd64,linux/arm64 \</span><br><span class="line">  -t username/my-app:latest --push .</span><br></pre></td></tr></table></figure>
<h5 id="创建和使用-Buildx-构建器"><a href="#创建和使用-Buildx-构建器" class="headerlink" title="创建和使用 Buildx 构建器"></a>创建和使用 Buildx 构建器</h5><p>Buildx 使用”构建器实例”的概念，你可以创建不同类型的构建器。</p>
<p>查看当前构建器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker buildx <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">NAME/NODE    DRIVER/ENDPOINT STATUS  PLATFORMS</span><br><span class="line">default *    docker</span><br><span class="line">  default    default         running linux/amd64, linux/386</span><br></pre></td></tr></table></figure>

<p>创建新的构建器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建支持多平台的新构建器</span></span><br><span class="line">docker buildx create --name my-builder --use</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动构建器</span></span><br><span class="line">docker buildx inspect my-builder --bootstrap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看构建器支持的平台</span></span><br><span class="line">docker buildx inspect my-builder</span><br></pre></td></tr></table></figure>

<p>创建更强大的构建器（推荐）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 docker-container 驱动，支持更多功能</span></span><br><span class="line">docker buildx create --name advanced-builder \</span><br><span class="line">  --driver docker-container \</span><br><span class="line">  --use</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动并查看平台支持</span></span><br><span class="line">docker buildx inspect --bootstrap</span><br></pre></td></tr></table></figure>

<h4 id="实际使用示例"><a href="#实际使用示例" class="headerlink" title="实际使用示例"></a>实际使用示例</h4><h5 id="基础多平台构建"><a href="#基础多平台构建" class="headerlink" title="基础多平台构建"></a>基础多平台构建</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache curl</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app /usr/local/bin/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/app&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建并推送多平台镜像</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --platform linux/amd64,linux/arm64,linux/arm/v7 \</span><br><span class="line">  -t username/my-app:latest \</span><br><span class="line">  --push .</span><br></pre></td></tr></table></figure>
<h5 id="本地构建并导出"><a href="#本地构建并导出" class="headerlink" title="本地构建并导出"></a>本地构建并导出</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建多平台镜像但不推送，保存到本地</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --platform linux/amd64,linux/arm64 \</span><br><span class="line">  -t my-app:multiarch \</span><br><span class="line">  --output <span class="built_in">type</span>=docker .</span><br></pre></td></tr></table></figure>
<h5 id="导出到文件"><a href="#导出到文件" class="headerlink" title="导出到文件"></a>导出到文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将镜像导出为 tar 文件</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --platform linux/amd64 \</span><br><span class="line">  -t my-app:latest \</span><br><span class="line">  --output <span class="built_in">type</span>=docker,dest=./my-app.tar .</span><br></pre></td></tr></table></figure>

<h4 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h4><h5 id="安全的-Secret-管理"><a href="#安全的-Secret-管理" class="headerlink" title="安全的 Secret 管理"></a>安全的 Secret 管理</h5><p>在构建过程中安全地使用密码、API 密钥等敏感信息。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=secret,<span class="built_in">id</span>=mysecret \</span></span><br><span class="line"><span class="language-bash">  <span class="built_in">export</span> API_KEY=$(<span class="built_in">cat</span> /run/secrets/mysecret) &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">  ./script-that-needs-api-key</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建时传入 secret</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --secret <span class="built_in">id</span>=mysecret,<span class="built_in">env</span>=MY_SECRET \</span><br><span class="line">  -t my-app:secure .</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行前设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> MY_SECRET=supersecretvalue</span><br><span class="line">docker buildx build --secret <span class="built_in">id</span>=mysecret,<span class="built_in">env</span>=MY_SECRET -t my-app:secure .</span><br></pre></td></tr></table></figure>

<h5 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h5><p>优化构建缓存，加速 CI&#x2F;CD 流程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用外部缓存</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --cache-from=<span class="built_in">type</span>=registry,ref=username/my-app:latest \</span><br><span class="line">  --cache-to=<span class="built_in">type</span>=inline \</span><br><span class="line">  -t username/my-app:latest \</span><br><span class="line">  --push .</span><br></pre></td></tr></table></figure>

<h5 id="并行构建"><a href="#并行构建" class="headerlink" title="并行构建"></a>并行构建</h5><p>利用多核 CPU 加速构建：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile 中的 RUN 指令可以并行执行</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/var/cache/apk \</span></span><br><span class="line"><span class="language-bash">    apk add --no-cache gcc musl-dev &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install -r requirements.txt</span></span><br></pre></td></tr></table></figure>

<h4 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h4><p>场景 1：开发团队</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为所有开发者的不同机器架构构建镜像</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --platform linux/amd64,linux/arm64 \</span><br><span class="line">  -t my-company/app:dev \</span><br><span class="line">  --load .  <span class="comment"># 加载到本地 Docker</span></span><br></pre></td></tr></table></figure>

<p>场景 2：CI&#x2F;CD 流水线</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 CI 中构建并推送生产镜像</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --platform linux/amd64,linux/arm64 \</span><br><span class="line">  --cache-from <span class="built_in">type</span>=registry,ref=my-app:latest \</span><br><span class="line">  --cache-to <span class="built_in">type</span>=inline \</span><br><span class="line">  -t my-registry.com/my-app:<span class="variable">$&#123;CI_COMMIT_SHA&#125;</span> \</span><br><span class="line">  -t my-registry.com/my-app:latest \</span><br><span class="line">  --push .</span><br></pre></td></tr></table></figure>

<p>场景 3：开源项目发布</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布支持所有常见平台的镜像</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --platform linux/amd64,linux/arm64,linux/arm/v7,linux/s390x \</span><br><span class="line">  -t myproject/app:latest \</span><br><span class="line">  --push .</span><br></pre></td></tr></table></figure>

<h4 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h4><ol>
<li>检查 Buildx 版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx version</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看构建器状态</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx inspect --bootstrap</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>清理构建缓存</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx prune</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>如果遇到平台不支持错误</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 QEMU 模拟器支持下运行</span></span><br><span class="line">docker run --privileged --<span class="built_in">rm</span> tonistiigi/binfmt --install all</span><br></pre></td></tr></table></figure>

<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>特性</th>
<th>传统 <code>docker build</code></th>
<th>Docker Buildx</th>
</tr>
</thead>
<tbody><tr>
<td>多平台构建</td>
<td>需要手动操作</td>
<td>原生支持</td>
</tr>
<tr>
<td>构建性能</td>
<td>一般</td>
<td>并行构建，缓存优化</td>
</tr>
<tr>
<td>输出格式</td>
<td>有限</td>
<td>多种输出格式</td>
</tr>
<tr>
<td>安全性</td>
<td>基础</td>
<td>安全的 Secret 管理</td>
</tr>
<tr>
<td>灵活性</td>
<td>固定</td>
<td>可扩展的构建器</td>
</tr>
</tbody></table>
<p>什么时候使用 Docker Buildx？</p>
<ul>
<li>需要为多种 CPU 架构构建镜像</li>
<li>想要优化构建性能</li>
<li>在 CI&#x2F;CD 流水线中需要高级缓存功能</li>
<li>需要安全地处理构建时的敏感信息</li>
<li>构建复杂的多阶段镜像</li>
</ul>
<p><strong>总结：Buildx 是现代化 Docker 镜像构建的必备工具，特别是当需要支持多种硬件平台或优化构建流程时。</strong></p>
<h3 id="架构相关变量"><a href="#架构相关变量" class="headerlink" title="架构相关变量"></a>架构相关变量</h3><h4 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h4><p>这些变量可以分为两大类：</p>
<ul>
<li><strong>TARGET*</strong>：目标平台（镜像要运行的平台）</li>
<li><strong>BUILD*</strong>：构建平台（正在执行构建的主机平台）</li>
</ul>
<h4 id="详细解释具体变量"><a href="#详细解释具体变量" class="headerlink" title="详细解释具体变量"></a>详细解释具体变量</h4><h5 id="TARGETPLATFORM"><a href="#TARGETPLATFORM" class="headerlink" title="TARGETPLATFORM"></a>TARGETPLATFORM</h5><p>作用：构建目标的目标平台全称。</p>
<p>示例值：</p>
<ul>
<li><code>linux/amd64</code>（Intel&#x2F;AMD 64位）</li>
<li><code>linux/arm64</code>（ARM 64位，如 Apple M1&#x2F;M2）</li>
<li><code>linux/arm/v7</code>（ARM 32位 v7）</li>
<li><code>linux/arm/v6</code>（ARM 32位 v6）</li>
<li><code>windows/amd64</code>（Windows AMD64）</li>
<li><code>darwin/amd64</code>（macOS Intel）</li>
</ul>
<p>使用场景：当需要根据目标平台执行完全不同的操作时。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据完整平台名称选择不同的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> --platform=$TARGETPLATFORM alpine:latest</span><br></pre></td></tr></table></figure>

<h5 id="TARGETOS"><a href="#TARGETOS" class="headerlink" title="TARGETOS"></a>TARGETOS</h5><p>作用：目标平台的操作系统类型。</p>
<p>示例值：</p>
<ul>
<li><code>linux</code></li>
<li><code>windows</code></li>
<li><code>darwin</code></li>
</ul>
<p>使用场景：操作系统相关的配置。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据操作系统安装不同的软件包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$TARGETOS</span>&quot;</span> = <span class="string">&quot;linux&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        apk add --no-cache some-linux-package; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$TARGETOS</span>&quot;</span> = <span class="string">&quot;windows&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="comment"># Windows 相关的安装命令; \</span></span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure>

<h5 id="TARGETARCH"><a href="#TARGETARCH" class="headerlink" title="TARGETARCH"></a>TARGETARCH</h5><p>作用：目标平台的 CPU 架构。</p>
<p>示例值：</p>
<ul>
<li><code>amd64</code>（Intel&#x2F;AMD 64位）</li>
<li><code>arm64</code>（ARM 64位）</li>
<li><code>arm</code>（ARM 32位）</li>
<li><code>386</code>（32位 x86）</li>
<li><code>ppc64le</code>（PowerPC 64位小端）</li>
<li><code>s390x</code>（IBM System z）</li>
</ul>
<p>使用场景：架构相关的二进制文件下载和安装。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载对应架构的二进制文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://example.com/app-<span class="variable">$&#123;TARGETARCH&#125;</span>.tar.gz</span></span><br></pre></td></tr></table></figure>

<h5 id="TARGETVARIANT"><a href="#TARGETVARIANT" class="headerlink" title="TARGETVARIANT"></a>TARGETVARIANT</h5><p>作用：目标平台的架构变种。</p>
<p>示例值：</p>
<ul>
<li><code>v7</code>（ARM v7）</li>
<li><code>v6</code>（ARM v6）</li>
<li>空字符串（对于没有变种的架构）</li>
</ul>
<p>使用场景：ARM 架构的精细控制。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ARM 架构的特殊处理</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$TARGETARCH</span>&quot;</span> = <span class="string">&quot;arm&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$TARGETVARIANT</span>&quot;</span> = <span class="string">&quot;v7&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">            <span class="built_in">echo</span> <span class="string">&quot;Building for ARMv7&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$TARGETVARIANT</span>&quot;</span> = <span class="string">&quot;v6&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">            <span class="built_in">echo</span> <span class="string">&quot;Building for ARMv6&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        <span class="keyword">fi</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure>

<h5 id="BUILDPLATFORM"><a href="#BUILDPLATFORM" class="headerlink" title="BUILDPLATFORM"></a>BUILDPLATFORM</h5><p>作用：执行构建的主机平台全称。</p>
<p>示例值：</p>
<ul>
<li><code>linux/amd64</code>（在 Intel Linux 上构建）</li>
<li><code>linux/arm64</code>（在 ARM Linux 上构建）</li>
<li><code>darwin/arm64</code>（在 Apple Silicon Mac 上构建）</li>
</ul>
<p>使用场景：构建时工具的选择。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用与构建平台匹配的工具</span></span><br><span class="line"><span class="keyword">FROM</span> --platform=$BUILDPLATFORM golang:alpine AS builder</span><br></pre></td></tr></table></figure>

<h5 id="BUILDOS"><a href="#BUILDOS" class="headerlink" title="BUILDOS"></a>BUILDOS</h5><p>作用：构建主机的操作系统类型。</p>
<p>使用场景：构建环境相关的配置。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只在 Linux 构建主机上执行某些操作</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$BUILDOS</span>&quot;</span> = <span class="string">&quot;linux&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="built_in">echo</span> <span class="string">&quot;Running on Linux build machine&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span></span></span><br></pre></td></tr></table></figure>
<h5 id="BUILDARCH"><a href="#BUILDARCH" class="headerlink" title="BUILDARCH"></a>BUILDARCH</h5><p>作用：构建主机的 CPU 架构。</p>
<p>使用场景：选择构建工具的架构版本。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载适合构建主机的工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://tools.example.com/build-tool-<span class="variable">$&#123;BUILDARCH&#125;</span>.tar.gz</span></span><br></pre></td></tr></table></figure>

<h5 id="BUILDVARIANT"><a href="#BUILDVARIANT" class="headerlink" title="BUILDVARIANT"></a>BUILDVARIANT</h5><p>作用：构建主机的架构变种。</p>
<p>使用场景：构建环境的特殊处理。</p>
<h4 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h4><p>示例 1：多平台基础镜像选择</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用自动平台匹配的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> --platform=$TARGETPLATFORM alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装架构相关的软件包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$&#123;TARGETARCH&#125;</span>&quot;</span> <span class="keyword">in</span> \</span></span><br><span class="line"><span class="language-bash">        amd64) \</span></span><br><span class="line"><span class="language-bash">            apk add --no-cache amd64-specific-package ;; \</span></span><br><span class="line"><span class="language-bash">        arm64) \</span></span><br><span class="line"><span class="language-bash">            apk add --no-cache arm64-specific-package ;; \</span></span><br><span class="line"><span class="language-bash">        arm) \</span></span><br><span class="line"><span class="language-bash">            apk add --no-cache arm-specific-package ;; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">esac</span></span></span><br></pre></td></tr></table></figure>

<p>示例 2：下载平台特定的二进制文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据目标架构下载对应的二进制文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/my-app \</span></span><br><span class="line"><span class="language-bash">    <span class="string">&quot;https://github.com/user/my-app/releases/latest/download/my-app-<span class="variable">$&#123;TARGETOS&#125;</span>-<span class="variable">$&#123;TARGETARCH&#125;</span><span class="variable">$&#123;TARGETVARIANT:+<span class="variable">$&#123;TARGETVARIANT&#125;</span>&#125;</span>&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/my-app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/my-app&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>URL 生成逻辑：</p>
<ul>
<li><code>TARGETOS</code> → <code>linux</code>, <code>windows</code>, <code>darwin</code></li>
<li><code>TARGETARCH</code> → <code>amd64</code>, <code>arm64</code>, <code>arm</code></li>
<li><code>TARGETVARIANT</code> → <code>v7</code>, <code>v6</code> 或空</li>
<li>最终生成：<code>my-app-linux-armv7</code>, <code>my-app-linux-amd64</code> 等</li>
</ul>
<p>示例 3：交叉编译场景</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阶段1：在构建平台上编译</span></span><br><span class="line"><span class="keyword">FROM</span> --platform=$BUILDPLATFORM golang:alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="comment"># 交叉编译到目标平台</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> GOOS=<span class="variable">$TARGETOS</span> GOARCH=<span class="variable">$TARGETARCH</span> go build -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阶段2：使用目标平台的基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> --platform=$TARGETPLATFORM alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/app /usr/local/bin/app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/app&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>示例 4：完整的多平台 Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多平台支持的 Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> --platform=$TARGETPLATFORM alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标签，记录构建信息</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.target.platform=<span class="variable">$TARGETPLATFORM</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据架构安装不同的包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$&#123;TARGETARCH&#125;</span>&quot;</span> <span class="keyword">in</span> \</span></span><br><span class="line"><span class="language-bash">        amd64) \</span></span><br><span class="line"><span class="language-bash">            <span class="built_in">echo</span> <span class="string">&quot;Installing AMD64 optimized packages&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">            apk add --no-cache some-amd64-package ;; \</span></span><br><span class="line"><span class="language-bash">        arm64) \</span></span><br><span class="line"><span class="language-bash">            <span class="built_in">echo</span> <span class="string">&quot;Installing ARM64 optimized packages&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">            apk add --no-cache some-arm64-package ;; \</span></span><br><span class="line"><span class="language-bash">        arm) \</span></span><br><span class="line"><span class="language-bash">            <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;TARGETVARIANT&#125;</span>&quot;</span> = <span class="string">&quot;v7&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">                <span class="built_in">echo</span> <span class="string">&quot;Installing ARMv7 packages&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">                apk add --no-cache some-armv7-package; \</span></span><br><span class="line"><span class="language-bash">            <span class="keyword">else</span> \</span></span><br><span class="line"><span class="language-bash">                <span class="built_in">echo</span> <span class="string">&quot;Installing generic ARM packages&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">                apk add --no-cache some-arm-package; \</span></span><br><span class="line"><span class="language-bash">            <span class="keyword">fi</span> ;; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">esac</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载架构特定的二进制文件</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/example/tool/releases/latest/download/tool-<span class="variable">$&#123;TARGETOS&#125;</span>-<span class="variable">$&#123;TARGETARCH&#125;</span> /usr/local/bin/tool</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/tool</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制架构特定的配置文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> config-<span class="variable">$&#123;TARGETARCH&#125;</span>.toml /etc/app/config.toml</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/tool&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="构建命令示例"><a href="#构建命令示例" class="headerlink" title="构建命令示例"></a>构建命令示例</h4><p>使用这些变量进行多平台构建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建多个平台</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --platform linux/amd64,linux/arm64,linux/arm/v7 \</span><br><span class="line">  -t myapp:latest \</span><br><span class="line">  --push .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 BuildKit 内置变量</span></span><br><span class="line">docker buildx build \</span><br><span class="line">  --platform linux/amd64,linux/arm64 \</span><br><span class="line">  --build-arg TARGETPLATFORM \</span><br><span class="line">  -t myapp:latest \</span><br><span class="line">  --push .</span><br></pre></td></tr></table></figure>

<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>变量</th>
<th>类别</th>
<th>描述</th>
<th>常见值</th>
</tr>
</thead>
<tbody><tr>
<td><code>TARGETPLATFORM</code></td>
<td>目标</td>
<td>完整平台标识</td>
<td><code>linux/amd64</code>, <code>linux/arm64</code></td>
</tr>
<tr>
<td><code>TARGETOS</code></td>
<td>目标</td>
<td>操作系统</td>
<td><code>linux</code>, <code>windows</code></td>
</tr>
<tr>
<td><code>TARGETARCH</code></td>
<td>目标</td>
<td>CPU 架构</td>
<td><code>amd64</code>, <code>arm64</code>, <code>arm</code></td>
</tr>
<tr>
<td><code>TARGETVARIANT</code></td>
<td>目标</td>
<td>架构变种</td>
<td><code>v7</code>, <code>v6</code>（或空）</td>
</tr>
<tr>
<td><code>BUILDPLATFORM</code></td>
<td>构建</td>
<td>构建主机平台</td>
<td><code>linux/amd64</code>, <code>darwin/arm64</code></td>
</tr>
<tr>
<td><code>BUILDOS</code></td>
<td>构建</td>
<td>构建主机 OS</td>
<td><code>linux</code>, <code>darwin</code></td>
</tr>
<tr>
<td><code>BUILDARCH</code></td>
<td>构建</td>
<td>构建主机架构</td>
<td><code>amd64</code>, <code>arm64</code></td>
</tr>
<tr>
<td><code>BUILDVARIANT</code></td>
<td>构建</td>
<td>构建主机变种</td>
<td><code>v7</code>（或空）</td>
</tr>
</tbody></table>
<p><strong>核心价值</strong>：这些变量能够编写<strong>真正平台无关的 Dockerfile</strong>，用一个 Dockerfile 为所有支持的平台构建优化的镜像，大大简化了多平台应用的开发和分发。</p>
<h3 id="BuildKit"><a href="#BuildKit" class="headerlink" title="BuildKit"></a>BuildKit</h3><p><strong>BuildKit</strong> 是一个现代化的、并发的、高效的容器镜像构建工具包。它从 Docker 18.09 开始作为实验功能引入，现在已成为默认的构建引擎。</p>
<h4 id="与传统-Docker-Builder-的对比"><a href="#与传统-Docker-Builder-的对比" class="headerlink" title="与传统 Docker Builder 的对比"></a>与传统 Docker Builder 的对比</h4><table>
<thead>
<tr>
<th>特性</th>
<th>传统 Docker Builder</th>
<th>BuildKit</th>
</tr>
</thead>
<tbody><tr>
<td><strong>构建性能</strong></td>
<td>顺序执行，较慢</td>
<td><strong>并行执行</strong>，极快</td>
</tr>
<tr>
<td><strong>缓存机制</strong></td>
<td>简单的层缓存</td>
<td><strong>智能缓存</strong>，支持跨项目共享</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>基础</td>
<td><strong>安全的 Secret 管理</strong></td>
</tr>
<tr>
<td><strong>功能特性</strong></td>
<td>有限</td>
<td><strong>多平台构建、复杂输出格式</strong></td>
</tr>
<tr>
<td><strong>资源利用</strong></td>
<td>一般</td>
<td><strong>高效资源利用</strong></td>
</tr>
</tbody></table>
<h4 id="启用-BuildKit"><a href="#启用-BuildKit" class="headerlink" title="启用 BuildKit"></a>启用 BuildKit</h4><p>方法一：环境变量（推荐）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时启用</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_BUILDKIT=1</span><br><span class="line">docker build -t my-app .</span><br></pre></td></tr></table></figure>

<p>方法二：Daemon 配置<br>在 <code>/etc/docker/daemon.json</code> 中：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;buildkit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后重启 Docker：<code>sudo systemctl restart docker</code></p>
<p>方法三：Dockerfile 语法</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="BuildKit-的核心特性详解"><a href="#BuildKit-的核心特性详解" class="headerlink" title="BuildKit 的核心特性详解"></a>BuildKit 的核心特性详解</h4><h5 id="并行构建执行"><a href="#并行构建执行" class="headerlink" title="并行构建执行"></a>并行构建执行</h5><p>传统构建是顺序执行，BuildKit 可以并行执行独立的指令。</p>
<p>传统 Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y git</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y curl  <span class="comment"># 必须等待上一条完成</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y wget  <span class="comment"># 必须等待上一条完成</span></span></span><br></pre></td></tr></table></figure>

<p>BuildKit 优化：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/var/cache/apt \</span></span><br><span class="line"><span class="language-bash">    apt update &amp;&amp; apt install -y git curl wget</span></span><br><span class="line"><span class="comment"># 可以并行下载和安装包</span></span><br></pre></td></tr></table></figure>

<h5 id="高级缓存机制"><a href="#高级缓存机制" class="headerlink" title="高级缓存机制"></a>高级缓存机制</h5><p>BuildKit 提供了多种缓存后端和更精细的缓存控制。</p>
<p><strong>缓存挂载（Cache Mounts）</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存 pip 包，避免重复下载</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/root/.cache/pip \</span></span><br><span class="line"><span class="language-bash">    pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存 apt 包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/var/cache/apt \</span></span><br><span class="line"><span class="language-bash">    apt update &amp;&amp; apt install -y some-package</span></span><br></pre></td></tr></table></figure>

<p><strong>跨构建缓存</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建时指定缓存来源和去向</span></span><br><span class="line">docker build \</span><br><span class="line">  --cache-from=<span class="built_in">type</span>=registry,ref=myapp:latest \</span><br><span class="line">  --cache-to=<span class="built_in">type</span>=inline \</span><br><span class="line">  -t myapp:latest .</span><br></pre></td></tr></table></figure>

<h5 id="安全的-Secret-管理-1"><a href="#安全的-Secret-管理-1" class="headerlink" title="安全的 Secret 管理"></a>安全的 Secret 管理</h5><p>这是 BuildKit 的重大安全改进，可以在构建过程中安全地使用敏感信息。</p>
<p>使用示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安全地使用 secret，不会留在镜像层中</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=secret,<span class="built_in">id</span>=mysecret \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">export</span> API_KEY=$(<span class="built_in">cat</span> /run/secrets/mysecret) &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    ./script-that-needs-api-key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多 secret 使用</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=secret,<span class="built_in">id</span>=aws_key \</span></span><br><span class="line"><span class="language-bash">    --mount=<span class="built_in">type</span>=secret,<span class="built_in">id</span>=aws_secret \</span></span><br><span class="line"><span class="language-bash">    AWS_ACCESS_KEY=$(<span class="built_in">cat</span> /run/secrets/aws_key) \</span></span><br><span class="line"><span class="language-bash">    AWS_SECRET_KEY=$(<span class="built_in">cat</span> /run/secrets/aws_secret) \</span></span><br><span class="line"><span class="language-bash">    ./deploy-script</span></span><br></pre></td></tr></table></figure>

<p>构建时传入 secret：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件传入</span></span><br><span class="line">docker build --secret <span class="built_in">id</span>=mysecret,src=./secret.txt .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从环境变量传入</span></span><br><span class="line"><span class="built_in">export</span> MYSECRET=supersecret</span><br><span class="line">docker build --secret <span class="built_in">id</span>=mysecret,<span class="built_in">env</span>=MYSECRET .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Docker Compose 中</span></span><br><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    build:</span><br><span class="line">      context: .</span><br><span class="line">      secrets:</span><br><span class="line">        - mysecret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  mysecret:</span><br><span class="line">    environment: <span class="string">&quot;MYSECRET&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="多平台构建支持"><a href="#多平台构建支持" class="headerlink" title="多平台构建支持"></a>多平台构建支持</h5><p>BuildKit 原生支持多平台构建，无需复杂的 manifest 操作。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个 Dockerfile 支持所有平台</span></span><br><span class="line"><span class="keyword">FROM</span> --platform=$TARGETPLATFORM alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$TARGETARCH</span>&quot;</span> <span class="keyword">in</span> \</span></span><br><span class="line"><span class="language-bash">        amd64) <span class="built_in">echo</span> <span class="string">&quot;AMD64 build&quot;</span> ;; \</span></span><br><span class="line"><span class="language-bash">        arm64) <span class="built_in">echo</span> <span class="string">&quot;ARM64 build&quot;</span> ;; \</span></span><br><span class="line"><span class="language-bash">        arm) <span class="built_in">echo</span> <span class="string">&quot;ARM build&quot;</span> ;; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">esac</span></span></span><br></pre></td></tr></table></figure>

<p>构建命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/amd64,linux/arm64 -t myapp:latest --push .</span><br></pre></td></tr></table></figure>

<h5 id="灵活的挂载类型"><a href="#灵活的挂载类型" class="headerlink" title="灵活的挂载类型"></a>灵活的挂载类型</h5><p>BuildKit 引入了多种挂载类型，极大增强了构建灵活性。</p>
<p><strong>SSH 挂载：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在构建过程中使用 SSH 访问私有仓库</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=ssh \</span></span><br><span class="line"><span class="language-bash">    git <span class="built_in">clone</span> git@github.com:user/private-repo.git</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --ssh default -t myapp .</span><br></pre></td></tr></table></figure>

<p><strong>绑定挂载（Build Context）：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将构建上下文中的文件挂载到临时位置</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=.,target=/tmp/src \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cd</span> /tmp/src &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    npm install &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制构建结果</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /tmp/src/dist /app/dist</span></span><br></pre></td></tr></table></figure>

<p><strong>临时挂载：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时挂载，构建完成后不保留</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=tmpfs,target=/temp-cache \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cd</span> /temp-cache &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget http://example.com/large-file.tar.gz</span></span><br></pre></td></tr></table></figure>

<h4 id="BuildKit-的架构优势"><a href="#BuildKit-的架构优势" class="headerlink" title="BuildKit 的架构优势"></a>BuildKit 的架构优势</h4><h5 id="LLB（Low-Level-Builder）"><a href="#LLB（Low-Level-Builder）" class="headerlink" title="LLB（Low-Level Builder）"></a>LLB（Low-Level Builder）</h5><p>BuildKit 使用 LLB 作为中间构建定义格式：</p>
<ul>
<li><strong>可序列化的构建图</strong></li>
<li><strong>内容可寻址的缓存</strong></li>
<li><strong>精确的依赖跟踪</strong></li>
</ul>
<h5 id="前端和后端分离"><a href="#前端和后端分离" class="headerlink" title="前端和后端分离"></a>前端和后端分离</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Dockerfile] → [Frontend] → [LLB] → [Solver] → [Worker] → [Image]</span><br><span class="line">     ↓              ↓           ↓        ↓         ↓         ↓</span><br><span class="line">   用户输入        语法解析      构建图    执行器    运行环境    输出镜像</span><br></pre></td></tr></table></figure>
<p>这种架构支持多种前端：</p>
<ul>
<li>Dockerfile</li>
<li>Mockerfile</li>
<li>自定义前端</li>
</ul>
<h4 id="实际应用示例-1"><a href="#实际应用示例-1" class="headerlink" title="实际应用示例"></a>实际应用示例</h4><p>示例 1：优化的 Node.js 应用构建</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1.4</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">16</span>-alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存 package.json 和 lock 文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json package-lock.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/root/.npm \</span></span><br><span class="line"><span class="language-bash">    npm ci --only=production</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制源代码并构建</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/app/.build-cache \</span></span><br><span class="line"><span class="language-bash">    npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产阶段</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/dist /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure>

<p>示例 2：安全的 CI&#x2F;CD 构建</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.19</span>-alpine AS builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> go.mod go.sum ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod download</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=secret,<span class="built_in">id</span>=signing_key \</span></span><br><span class="line"><span class="language-bash">    --mount=<span class="built_in">type</span>=cache,target=/go/pkg/mod \</span></span><br><span class="line"><span class="language-bash">    --mount=<span class="built_in">type</span>=cache,target=/root/.cache/go-build \</span></span><br><span class="line"><span class="language-bash">    go build -ldflags=<span class="string">&quot;-s -w -X main.version=<span class="subst">$(cat /run/secrets/signing_key)</span>&quot;</span> -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /src/app /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/app&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>构建命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker build \</span><br><span class="line">  --secret <span class="built_in">id</span>=signing_key,<span class="built_in">env</span>=SIGNING_KEY \</span><br><span class="line">  --cache-from <span class="built_in">type</span>=registry,ref=myapp:latest \</span><br><span class="line">  --cache-to <span class="built_in">type</span>=inline,mode=max \</span><br><span class="line">  -t myapp:latest .</span><br></pre></td></tr></table></figure>

<p>示例 3：多阶段复杂构建</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1.4</span></span><br><span class="line"><span class="keyword">FROM</span> --platform=$BUILDPLATFORM golang:<span class="number">1.19</span>-alpine AS build</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /src</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o /bin/server .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> --platform=$BUILDPLATFORM node:<span class="number">16</span>-alpine AS assets</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /src</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/src/node_modules \</span></span><br><span class="line"><span class="language-bash">    npm install &amp;&amp; npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> adduser -D appuser</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /bin/server /bin/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=assets /src/dist /assets</span></span><br><span class="line"><span class="keyword">USER</span> appuser</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/server&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="性能优化技巧"><a href="#性能优化技巧" class="headerlink" title="性能优化技巧"></a>性能优化技巧</h4><ol>
<li>利用缓存挂载</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存 pip 包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/root/.cache/pip \</span></span><br><span class="line"><span class="language-bash">    pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存 apt 包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/var/cache/apt \</span></span><br><span class="line"><span class="language-bash">    apt update &amp;&amp; apt install -y package</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>并行下载</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行下载多个文件</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install -y wget &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget -qO file1.txt http://example.com/file1 &amp; \</span></span><br><span class="line"><span class="language-bash">    wget -qO file2.txt http://example.com/file2 &amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">wait</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最小化上下文</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .dockerignore 文件</span></span><br><span class="line">node_modules</span><br><span class="line">.git</span><br><span class="line">*.log</span><br><span class="line">Dockerfile</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure>

<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>BuildKit 的核心优势：</p>
<ol>
<li><strong>性能</strong>：并行执行、智能缓存、增量构建</li>
<li><strong>安全</strong>：安全的 Secret 管理、沙盒执行</li>
<li><strong>功能</strong>：多平台构建、灵活的挂载、复杂输出</li>
<li><strong>可扩展</strong>：插件架构、自定义前端</li>
</ol>
<p>启用 BuildKit 的收益：</p>
<ul>
<li>构建速度提升 2-10 倍</li>
<li>更安全的构建流程</li>
<li>支持现代化开发工作流</li>
<li>更好的资源利用率</li>
</ul>
<p><strong>总结：BuildKit 不是简单的性能优化，而是容器镜像构建方式的革命性升级，是现代 Docker 工作流不可或缺的组成部分。</strong></p>
<h3 id="构建缓存"><a href="#构建缓存" class="headerlink" title="构建缓存"></a>构建缓存</h3><p>Docker 使用<strong>分层存储</strong>机制，每一层都是只读的。当构建镜像时，Docker 会检查是否可以使用缓存中的层，而不是重新构建。</p>
<h4 id="核心缓存命中规则"><a href="#核心缓存命中规则" class="headerlink" title="核心缓存命中规则"></a>核心缓存命中规则</h4><h5 id="指令内容完全匹配"><a href="#指令内容完全匹配" class="headerlink" title="指令内容完全匹配"></a>指令内容完全匹配</h5><p>规则：只有当指令的<strong>内容完全相同</strong>时，才会命中缓存。</p>
<p><strong>示例 1：RUN 指令</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次构建</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y curl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次构建（相同内容）- ✅ 命中缓存</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y curl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三次构建（内容不同）- ❌ 缓存失效</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; apt install -y curl wget</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：COPY&#x2F;ADD 指令</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件内容未改变 - ✅ 命中缓存</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内容已改变（即使文件名相同）- ❌ 缓存失效  </span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /app/</span></span><br></pre></td></tr></table></figure>

<h5 id="父层缓存状态"><a href="#父层缓存状态" class="headerlink" title="父层缓存状态"></a>父层缓存状态</h5><p>规则：如果<strong>任何父层缓存失效</strong>，所有后续层的缓存都会失效。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>           <span class="comment"># 层 1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update              <span class="comment"># 层 2</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y curl     <span class="comment"># 层 3</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py /app/           <span class="comment"># 层 4</span></span></span><br></pre></td></tr></table></figure>
<p>如果：</p>
<ul>
<li><code>app.py</code> 文件改变 → 层 4 失效</li>
<li>由于层 4 失效 → 后续所有层都重新构建</li>
</ul>
<h4 id="不同指令的缓存规则详解"><a href="#不同指令的缓存规则详解" class="headerlink" title="不同指令的缓存规则详解"></a>不同指令的缓存规则详解</h4><h5 id="FROM-指令"><a href="#FROM-指令" class="headerlink" title="FROM 指令"></a>FROM 指令</h5><p><strong>缓存键</strong>：基础镜像的摘要（Digest）</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>@sha256:abcd1234...  <span class="comment"># 使用明确摘要确保一致性</span></span><br></pre></td></tr></table></figure>

<h5 id="RUN-指令"><a href="#RUN-指令" class="headerlink" title="RUN 指令"></a>RUN 指令</h5><p><strong>缓存键</strong>：指令字符串的<strong>精确匹配</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这两个指令不会共享缓存（空格不同）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl    <span class="comment"># 缓存键 A</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl    <span class="comment"># 缓存键 B（相同）</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl wget  <span class="comment"># 缓存键 C（不同）</span></span></span><br></pre></td></tr></table></figure>

<h5 id="COPY-ADD-指令"><a href="#COPY-ADD-指令" class="headerlink" title="COPY&#x2F;ADD 指令"></a>COPY&#x2F;ADD 指令</h5><p><strong>缓存键</strong>：文件的<strong>校验和</strong>（checksum）</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件内容改变 → 缓存失效</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /app/      <span class="comment"># 校验和基于 package.json 内容</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使文件名不同，内容相同也会命中缓存</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> pkg.json /app/          <span class="comment"># 如果 pkg.json 与 package.json 内容相同</span></span></span><br></pre></td></tr></table></figure>

<h5 id="ENV-ARG-LABEL-指令"><a href="#ENV-ARG-LABEL-指令" class="headerlink" title="ENV&#x2F;ARG&#x2F;LABEL 指令"></a>ENV&#x2F;ARG&#x2F;LABEL 指令</h5><p><strong>缓存键</strong>：键值对的精确匹配</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值改变 → 缓存失效</span></span><br><span class="line"><span class="keyword">ENV</span> NODE_ENV=production      <span class="comment"># 缓存键基于 &quot;NODE_ENV=production&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> NODE_ENV=development     <span class="comment"># 值改变，缓存失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARG 在构建时传入的值也影响缓存</span></span><br><span class="line"><span class="keyword">ARG</span> VERSION=<span class="number">1.0</span></span><br><span class="line"><span class="keyword">ENV</span> APP_VERSION=$VERSION     <span class="comment"># VERSION 改变会导致缓存失效</span></span><br></pre></td></tr></table></figure>

<h5 id="WORKDIR-USER-指令"><a href="#WORKDIR-USER-指令" class="headerlink" title="WORKDIR&#x2F;USER 指令"></a>WORKDIR&#x2F;USER 指令</h5><p><strong>缓存键</strong>：路径&#x2F;用户的精确匹配</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app        <span class="comment"># 路径改变 → 缓存失效</span></span></span><br><span class="line"><span class="keyword">USER</span> appuser        <span class="comment"># 用户改变 → 缓存失效</span></span><br></pre></td></tr></table></figure>

<h4 id="缓存优化策略"><a href="#缓存优化策略" class="headerlink" title="缓存优化策略"></a>缓存优化策略</h4><h5 id="策略-1：利用-Dockerfile-指令顺序"><a href="#策略-1：利用-Dockerfile-指令顺序" class="headerlink" title="策略 1：利用 Dockerfile 指令顺序"></a>策略 1：利用 Dockerfile 指令顺序</h5><p>将变化频率低的指令放在前面：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ✅ 好的顺序 - 缓存友好</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">16</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不经常变化的依赖文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json package-lock.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm ci</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经常变化的源代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;dist/index.js&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>对比不好的顺序：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ❌ 不好的顺序 - 缓存不友好</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">16</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .                          <span class="comment"># 源代码改变会导致所有缓存失效</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm ci                        <span class="comment"># 每次都要重新安装依赖</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm run build</span></span><br></pre></td></tr></table></figure>

<h5 id="策略-2：合并相关指令"><a href="#策略-2：合并相关指令" class="headerlink" title="策略 2：合并相关指令"></a>策略 2：合并相关指令</h5><p>减少层数，提高缓存效率：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ✅ 合并相关操作</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install -y curl wget &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt clean &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 不要这样（创建多个层，缓存不友好）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y curl wget</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt clean</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>

<h5 id="策略-3：使用-dockerignore"><a href="#策略-3：使用-dockerignore" class="headerlink" title="策略 3：使用 .dockerignore"></a>策略 3：使用 .dockerignore</h5><p>避免不必要的文件改变导致缓存失效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># .dockerignore</span><br><span class="line">node_modules</span><br><span class="line">.git</span><br><span class="line">*.log</span><br><span class="line">.env</span><br><span class="line">Dockerfile</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure>
<h5 id="策略-4：固定版本和摘要"><a href="#策略-4：固定版本和摘要" class="headerlink" title="策略 4：固定版本和摘要"></a>策略 4：固定版本和摘要</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ✅ 使用固定版本和摘要</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span>@sha256:abcd1234...</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y curl=7.68.0-1ubuntu2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ❌ 避免使用最新标签</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y curl</span></span><br></pre></td></tr></table></figure>

<h4 id="缓存调试技巧"><a href="#缓存调试技巧" class="headerlink" title="缓存调试技巧"></a>缓存调试技巧</h4><h5 id="查看缓存命中情况"><a href="#查看缓存命中情况" class="headerlink" title="查看缓存命中情况"></a>查看缓存命中情况</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 BuildKit 查看详细输出</span></span><br><span class="line">DOCKER_BUILDKIT=1 docker build --progress=plain .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment"># ✓ CACHED [stage-1 2/4] COPY package.json ./</span></span><br><span class="line"><span class="comment"># ✓ CACHED [stage-1 3/4] RUN npm install  </span></span><br><span class="line"><span class="comment"># ❌ [stage-1 4/4] COPY . .              # 缓存失效</span></span><br></pre></td></tr></table></figure>

<h5 id="检查层摘要"><a href="#检查层摘要" class="headerlink" title="检查层摘要"></a>检查层摘要</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看镜像层信息</span></span><br><span class="line">docker <span class="built_in">history</span> my-image:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详细层信息</span></span><br><span class="line">docker inspect my-image:latest | jq <span class="string">&#x27;.[0].RootFS.Layers&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="强制重建特定层"><a href="#强制重建特定层" class="headerlink" title="强制重建特定层"></a>强制重建特定层</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 --no-cache 参数跳过缓存</span></span><br><span class="line">docker build --no-cache -t my-app .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 BuildKit 的缓存控制</span></span><br><span class="line">docker build --build-<span class="keyword">arg</span> BUILDKIT_INLINE_CACHE=<span class="number">1</span> -t my-app .</span><br></pre></td></tr></table></figure>

<h4 id="特殊情况的缓存行为"><a href="#特殊情况的缓存行为" class="headerlink" title="特殊情况的缓存行为"></a>特殊情况的缓存行为</h4><h5 id="ADD-指令的特殊性"><a href="#ADD-指令的特殊性" class="headerlink" title="ADD 指令的特殊性"></a>ADD 指令的特殊性</h5><p><code>ADD</code> 指令除了文件内容，还会检查 URL 和归档文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL 内容改变会导致缓存失效</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://example.com/latest.tar.gz /app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使本地文件相同，如果 URL 内容改变也会失效</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://example.com/version.txt /app/version.txt</span></span><br></pre></td></tr></table></figure>

<h5 id="构建参数（ARG）的影响"><a href="#构建参数（ARG）的影响" class="headerlink" title="构建参数（ARG）的影响"></a>构建参数（ARG）的影响</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> BUILD_NUMBER=<span class="number">1</span></span><br><span class="line"><span class="comment"># BUILD_NUMBER 改变会导致从此向后的缓存失效</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Build number: <span class="variable">$BUILD_NUMBER</span>&quot;</span> &gt; /build.info</span></span><br></pre></td></tr></table></figure>

<h5 id="外部基础镜像更新"><a href="#外部基础镜像更新" class="headerlink" title="外部基础镜像更新"></a>外部基础镜像更新</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">16</span>  <span class="comment"># 如果 node:16 在仓库中更新了</span></span><br><span class="line">              <span class="comment"># 下次构建时会拉取新版本，导致缓存失效</span></span><br></pre></td></tr></table></figure>
<p>可以使用摘要锁定：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">16</span>@sha256:abcdef123456...</span><br></pre></td></tr></table></figure>

<h4 id="BuildKit-的缓存改进"><a href="#BuildKit-的缓存改进" class="headerlink" title="BuildKit 的缓存改进"></a>BuildKit 的缓存改进</h4><p>BuildKit 提供了更高级的缓存控制：</p>
<h5 id="内联缓存（Inline-Cache）"><a href="#内联缓存（Inline-Cache）" class="headerlink" title="内联缓存（Inline Cache）"></a>内联缓存（Inline Cache）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建时生成内联缓存</span></span><br><span class="line">docker build \</span><br><span class="line">  --build-arg BUILDKIT_INLINE_CACHE=1 \</span><br><span class="line">  -t my-app \</span><br><span class="line">  --cache-from my-app:previous \</span><br><span class="line">  .</span><br></pre></td></tr></table></figure>

<h5 id="外部缓存后端"><a href="#外部缓存后端" class="headerlink" title="外部缓存后端"></a>外部缓存后端</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 registry 作为缓存后端</span></span><br><span class="line">docker build \</span><br><span class="line">  --cache-from=<span class="built_in">type</span>=registry,ref=my-app:latest \</span><br><span class="line">  --cache-to=<span class="built_in">type</span>=inline \</span><br><span class="line">  -t my-app:latest \</span><br><span class="line">  .</span><br></pre></td></tr></table></figure>

<h5 id="缓存挂载"><a href="#缓存挂载" class="headerlink" title="缓存挂载"></a>缓存挂载</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存依赖目录，避免重复下载</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> --mount=<span class="built_in">type</span>=cache,target=/root/.npm \</span></span><br><span class="line"><span class="language-bash">    npm install</span></span><br></pre></td></tr></table></figure>

<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><strong>Docker 构建缓存的核心规则：</strong></p>
<ol>
<li><strong>精确匹配</strong>：指令内容必须完全一致</li>
<li><strong>文件校验</strong>：COPY&#x2F;ADD 基于文件内容校验和</li>
<li><strong>链式失效</strong>：一旦某层缓存失效，后续所有层都失效</li>
<li><strong>上下文相关</strong>：构建上下文中的文件改变影响缓存</li>
</ol>
<p><strong>最佳实践：</strong></p>
<ul>
<li>将不经常变化的指令放在 Dockerfile 前面</li>
<li>使用 .dockerignore 排除不必要文件</li>
<li>合并相关的 RUN 指令</li>
<li>固定版本和依赖</li>
<li>利用多阶段构建分离构建和运行环境</li>
</ul>
<p><strong>缓存检查顺序：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 检查指令字符串是否完全匹配</span><br><span class="line">2. 检查父层缓存状态</span><br><span class="line">3. 对于 COPY/ADD：检查文件校验和</span><br><span class="line">4. 对于 RUN：检查命令字符串</span><br><span class="line">5. 如果任何检查失败：缓存失效，重新构建该层及后续所有层</span><br></pre></td></tr></table></figure>

<h2 id="高级网络配置"><a href="#高级网络配置" class="headerlink" title="高级网络配置"></a>高级网络配置</h2><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge（网桥），可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1918">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。<br><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-06.png" alt="网桥概述"></p>
<p><strong>Linux Bridge（Linux 网桥）:</strong><br>Linux Bridge（Linux 网桥）是一个工作在 <strong>数据链路层（OSI 模型第二层）</strong> 的虚拟网络设备，用于在多个网络接口之间转发数据帧。它的功能类似于一个物理的硬件网络交换机。</p>
<ul>
<li><strong>虚拟设备</strong>：它不是一个物理硬件，而是由 Linux 内核创建和管理的软件实体。</li>
<li><strong>二层交换</strong>：它根据 MAC 地址表来决策如何转发数据帧，而不是像路由器那样使用 IP 地址。</li>
<li><strong>透明连接</strong>：当多个网络接口（无论是物理的如 <code>eth0</code>，还是虚拟的如 <code>vnet0</code>）被加入同一个网桥后，它们就像连接在同一个交换机上一样，可以直接进行二层通信。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>一个工作在二层的虚拟网络交换机</td>
</tr>
<tr>
<td>核心功能</td>
<td>MAC 地址学习、转发&#x2F;泛洪数据帧、STP、VLAN 支持</td>
</tr>
<tr>
<td>管理工具</td>
<td>现代：<code>ip route2</code> (<code>ip link</code>, <code>bridge</code>)，传统：<code>brctl</code></td>
</tr>
<tr>
<td>主要应用</td>
<td>KVM&#x2F;Xen 虚拟机网络、Docker 容器网络、连接网络命名空间</td>
</tr>
<tr>
<td>关键概念</td>
<td>将物理或虚拟接口“加入”网桥，IP 配置在网桥设备上</td>
</tr>
</tbody></table>
<p>示例：创建一个网桥 <code>br0</code>，让虚拟机能通过物理网卡 <code>enp3s0</code> 上网。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建并启用网桥</span></span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> add name br0 <span class="built_in">type</span> bridge</span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> br0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 移除物理网卡上的IP（如果有）</span></span><br><span class="line"><span class="built_in">sudo</span> ip addr flush dev enp3s0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将物理网卡加入网桥</span></span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev enp3s0 master br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 为网桥分配IP地址，并设置默认路由</span></span><br><span class="line"><span class="built_in">sudo</span> ip addr add 192.168.1.100/24 dev br0</span><br><span class="line"><span class="built_in">sudo</span> ip route add default via 192.168.1.1 dev br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 配置KVM使用br0作为虚拟机的网络接口</span></span><br><span class="line"><span class="comment"># 在 virt-manager 中或使用 `virsh` 命令时，选择网络源为 &quot;Bridge br0&quot;</span></span><br></pre></td></tr></table></figure>
<p>完成以上步骤后，任何连接到 <code>br0</code> 的虚拟机都会从路由器（<code>192.168.1.1</code>）那里获取 <strong>IP</strong> 地址，就像直接插在局域网里一样。</p>
<h3 id="Docker-网络相关的命令"><a href="#Docker-网络相关的命令" class="headerlink" title="Docker 网络相关的命令"></a>Docker 网络相关的命令</h3><p>其中有些命令选项只有在 <strong>Docker</strong> 服务启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</li>
<li><code>--bip=CIDR</code> 定制 <code>docker0</code> 的掩码</li>
<li><code>-H SOCKET...</code> 或 <code>--host=SOCKET...</code> <strong>Docker</strong> 服务端接收命令的通道</li>
<li><code>--icc=true|fals</code>e 是否支持容器之间进行通信</li>
<li><code>--ip-forward=true|false</code> 请看下文容器之间的通信</li>
<li><code>--iptables=true|false</code> 是否允许 <strong>Docker</strong> 添加 <strong>iptables</strong> 规则</li>
<li><code>--mtu=BYTES</code> 容器网络中的 <strong>MTU</strong></li>
</ul>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 <strong>Docker</strong> 服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p>
<ul>
<li><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</li>
<li><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</li>
</ul>
<p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</li>
<li><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</li>
<li><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</li>
<li><code>-p SPEC</code> 或 <code>--publish=SPEC</code> 映射容器端口到宿主主机</li>
<li><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</li>
</ul>
<h3 id="容器访问控制"><a href="#容器访问控制" class="headerlink" title="容器访问控制"></a>容器访问控制</h3><p>容器的访问控制，主要通过 <strong>Linux</strong> 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 <strong>Linux</strong> 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h4 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h4><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sysctl</span> net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sysctl</span> -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure>
<p>如果在启动 <strong>Docker</strong> 服务的时候设定 <code>--ip-forward=true</code>, <strong>Docker</strong> 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p>
<h4 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h4><blockquote>
<p>注：本章描述的是 <strong>Docker</strong> 早期版本的网络安全模型，理解它有助于掌握底层原理，但在实际应用中，建议使用更现代的自定义网络方案。</p>
</blockquote>
<h5 id="核心概念梳理"><a href="#核心概念梳理" class="headerlink" title="核心概念梳理"></a>核心概念梳理</h5><ul>
<li><code>docker0</code> <strong>网桥</strong>：Docker 默认创建的虚拟网络交换机，所有 Docker 容器默认都连接到这里。</li>
<li><code>iptables</code>：Linux 系统的防火墙工具，负责控制网络数据包的流向。</li>
<li><code>--icc</code>：Inter-Container Communication（容器间通信）的缩写，一个 Docker 守护进程的配置选项。</li>
</ul>
<h5 id="允许所有容器间访问（默认模式，-icc-true）"><a href="#允许所有容器间访问（默认模式，-icc-true）" class="headerlink" title="允许所有容器间访问（默认模式，--icc=true）"></a>允许所有容器间访问（默认模式，<code>--icc=true</code>）</h5><p>这是 Docker 的<strong>默认行为</strong>。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上，不同容器之间是允许网络互通的。<br><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-07.webp" alt="网络拓扑图"></p>
<p>实际操作验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动两个容器</span></span><br><span class="line">docker run -d --name web nginx:alpine</span><br><span class="line">docker run -it --name client alpine:latest sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 client 容器中访问 web 容器（能成功）</span></span><br><span class="line">/ <span class="comment"># ping web  # 或者直接 ping 172.17.0.2</span></span><br><span class="line">/ <span class="comment"># wget -qO- http://web</span></span><br></pre></td></tr></table></figure>
<p>iptables 规则：<br>当 <code>--icc=true</code>（默认值）时，Docker 会在 iptables 的 <code>FORWARD</code> 链中添加一条<strong>允许所有</strong>的规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -nL FORWARD</span><br><span class="line">Chain FORWARD (policy DROP)  <span class="comment"># 默认策略是DROP</span></span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DOCKER-USER  all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">DOCKER-ISOLATION-STAGE-1  all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            <span class="comment"># ← 这条规则允许容器间通信</span></span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>安全问题</strong>：在这种模式下，任何容器都可以访问任何其他容器的任何端口，存在安全风险。</p>
<h5 id="完全禁止容器间访问（-icc-false）"><a href="#完全禁止容器间访问（-icc-false）" class="headerlink" title="完全禁止容器间访问（--icc=false）"></a>完全禁止容器间访问（<code>--icc=false</code>）</h5><p>为了增强安全性，可以禁用默认的容器间通信。</p>
<p>配置方法：在 <code>/etc/docker/daemon.json</code>中添加 <code>&quot;icc&quot;: false</code>。 然后重启 Docker 服务：<code>sudo systemctl restart docker</code><br><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-08.webp" alt="网络拓扑图"></p>
<p>iptables 规则变化：<br>启用 <code>--icc=false</code> 后，Docker 会修改规则，<strong>拒绝所有容器间的流量</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -nL FORWARD</span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DOCKER-USER  all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">DOCKER-ISOLATION-STAGE-1  all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0            <span class="comment"># ← 新增的DROP规则，禁止通信</span></span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在容器之间完全无法通信：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动两个容器测试</span></span><br><span class="line">docker run -d --name web nginx:alpine</span><br><span class="line">docker run -it --name client alpine:latest sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 client 容器中访问 web 容器（会失败）</span></span><br><span class="line">/ <span class="comment"># ping web  # 超时，无法连接</span></span><br><span class="line">/ <span class="comment"># wget -qO- http://web  # 超时，无法连接</span></span><br></pre></td></tr></table></figure>

<h5 id="通过-link-允许特定容器间访问（白名单方式）"><a href="#通过-link-允许特定容器间访问（白名单方式）" class="headerlink" title="通过 --link 允许特定容器间访问（白名单方式）"></a>通过 <code>--link</code> 允许特定容器间访问（白名单方式）</h5><p><strong>配置 Docker 禁止默认通信（<code>--icc=false</code>）, 使用 <code>--link</code> 创建白名单规则</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动一个web容器</span></span><br><span class="line">docker run -d --name web nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动client容器，并链接到web容器</span></span><br><span class="line">docker run -it --<span class="built_in">link</span> web:web-server --name client alpine:latest sh</span><br></pre></td></tr></table></figure>
<p>iptables 规则变化：<br>当使用 <code>--link</code> 后，Docker 会在 iptables 中为这两个容器添加<strong>精确的允许规则</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -nL FORWARD</span><br><span class="line">Chain FORWARD (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80  <span class="comment"># ← 允许client访问web的80端口</span></span><br><span class="line">ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80  <span class="comment"># ← 允许web回应client</span></span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0            <span class="comment"># ← 仍然禁止其他所有通信</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>规则解释：</p>
<ul>
<li><code>ACCEPT tcp -- 172.17.0.3 172.17.0.2 tcp dpt:80</code>：允许从 client (172.17.0.3) 到 web (172.17.0.2) 的 80 端口的访问。</li>
<li><code>ACCEPT tcp -- 172.17.0.2 172.17.0.3 tcp spt:80</code>：允许 web 容器回应 client 容器的请求。</li>
</ul>
<p>测试效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 client 容器中（现在可以访问了）</span></span><br><span class="line">/ <span class="comment"># ping web-server  # 可以解析域名</span></span><br><span class="line">/ <span class="comment"># wget -qO- http://web-server:80  # 可以访问80端口</span></span><br><span class="line">/ <span class="comment"># wget -qO- http://web-server:8080  # 但访问其他端口仍然被拒绝</span></span><br></pre></td></tr></table></figure>

<h3 id="映射容器端口到宿主主机的实现"><a href="#映射容器端口到宿主主机的实现" class="headerlink" title="映射容器端口到宿主主机的实现"></a>映射容器端口到宿主主机的实现</h3><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h4 id="容器访问外部实现"><a href="#容器访问外部实现" class="headerlink" title="容器访问外部实现"></a>容器访问外部实现</h4><p>容器所有到外部网络的连接，源地址都会被 <strong>NAT</strong> 成本地系统的 <strong>IP</strong> 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> iptables -t nat -nL</span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中，上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。<strong>MASQUERADE</strong> 跟传统 <strong>SNAT</strong> 的好处是它能动态从网卡获取地址。</p>
<h4 id="外部访问容器实现"><a href="#外部访问容器实现" class="headerlink" title="外部访问容器实现"></a>外部访问容器实现</h4><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 <code>iptable</code> 的 <strong>nat</strong> 表中添加相应的规则。</p>
<p>使用 <code>-P</code> 时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nL</span><br><span class="line">...</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>
<p>使用 <code>-p 80:80</code> 时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -nL</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>这里的规则映射了 0.0.0.0，意味着将接受主机来自所有接口的流量。用户可以通过 <code>-p IP:host_port:container_port</code> 或 <code>-p IP::port</code> 来指定允许访问容器的主机上的 <strong>IP</strong>、接口等，以制定更严格的规则。</li>
<li>如果希望永久绑定到某个固定的 <strong>IP</strong> 地址，可以在 <strong>Docker</strong> 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义网桥"><a href="#自定义网桥" class="headerlink" title="自定义网桥"></a>自定义网桥</h3><p>除了默认的 <code>docker0</code> 网桥，用户也可以指定网桥来连接各个容器。<br>在启动 <strong>Docker</strong> 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。<br>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> systemctl stop docker</span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 down</span><br><span class="line">$ <span class="built_in">sudo</span> brctl delbr docker0</span><br></pre></td></tr></table></figure>
<p>然后创建一个网桥 <code>bridge0</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> brctl addbr bridge0</span><br><span class="line">$ <span class="built_in">sudo</span> ip addr add 192.168.5.1/24 dev bridge0</span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev bridge0 up</span><br></pre></td></tr></table></figure>
<p>查看确认网桥创建并启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show bridge0</span><br><span class="line">4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.5.1/24 scope global bridge0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>在 <strong>Docker</strong> 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 <strong>Docker</strong> 默认桥接到创建的网桥上。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>启动 <strong>Docker</strong> 服务。<br>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。<br>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 <strong>IP</strong> 地址配置和路由信息。</p>
<h3 id="编辑网络配置文件"><a href="#编辑网络配置文件" class="headerlink" title="编辑网络配置文件"></a>编辑网络配置文件</h3><p><strong>Docker</strong> 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p>
<p>但是这些修改是<strong>临时</strong>的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p>
<h3 id="示例：创建一个点到点连接"><a href="#示例：创建一个点到点连接" class="headerlink" title="示例：创建一个点到点连接"></a>示例：创建一个点到点连接</h3><p>有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。<br>解决办法很简单：创建一对 <code>peer</code> 接口，分别放到两个容器中，配置成点到点链路类型即可。<br>首先启动 2 个容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --<span class="built_in">rm</span> --net=none base /bin/bash</span><br><span class="line">root@1f1f4c1f931a:/#</span><br><span class="line">$ docker run -i -t --<span class="built_in">rm</span> --net=none base /bin/bash</span><br><span class="line">root@12e343489d2f:/#</span><br></pre></td></tr></table></figure>
<p>找到进程号，然后创建网络命名空间的跟踪文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 1f1f4c1f931a</span><br><span class="line">2989</span><br><span class="line">$ docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 12e343489d2f</span><br><span class="line">3004</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /var/run/netns</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /proc/2989/ns/net /var/run/netns/2989</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /proc/3004/ns/net /var/run/netns/3004</span><br></pre></td></tr></table></figure>
<p>创建一对 <code>peer</code> 接口，然后配置路由</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> A netns 2989</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 2989 ip addr add 10.1.1.1/32 dev A</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 2989 ip <span class="built_in">link</span> <span class="built_in">set</span> A up</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 2989 ip route add 10.1.1.2/32 dev A</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> B netns 3004</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip addr add 10.1.1.2/32 dev B</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip <span class="built_in">link</span> <span class="built_in">set</span> B up</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip route add 10.1.1.1/32 dev B</span><br></pre></td></tr></table></figure>
<p>现在这 2 个容器就可以相互 <strong>ping</strong> 通，并成功建立连接。点到点链路不需要子网和子网掩码。<br>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。<br>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p>
<h4 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h4><p>命令的目的： <strong>在两个独立的网络命名空间（可以理解为两个隔离的”网络房间”，比如两个 Docker 容器）之间建立点对点的网络连接。</strong></p>
<p><strong>创建 veth pair（虚拟网线）</strong>:</p>
<p><code>sudo ip link add A type veth peer name B</code>: <strong>作用</strong>：创建一对虚拟的以太网设备，就像制作一根虚拟的网线。</p>
<ul>
<li><code>A</code> 和 <code>B</code> 是这对设备的两端名称</li>
<li><code>type veth peer</code> 表示创建 veth 对等设备</li>
<li><strong>比喻</strong>：就像制作一根网线，一端标记为 <code>A</code>，另一端标记为 <code>B</code>。在一端发送数据，另一端就能收到。<br>执行后状态：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主机根命名空间：</span><br><span class="line">A &lt;---&gt; B（两个虚拟网卡，直接相连</span><br></pre></td></tr></table></figure>

<p><strong>配置第一个命名空间（2989）的网络</strong>:</p>
<p><code>sudo ip link set A netns 2989</code>:  <strong>作用</strong>：将 veth 设备的一端 <code>A</code> 移动到网络命名空间 <code>2989</code> 中。</p>
<ul>
<li><code>netns 2989</code>：网络命名空间的 PID（进程ID），通常对应一个容器的进程。</li>
<li><strong>比喻</strong>：将网线的 <code>A</code> 端拉到第一个”房间”（命名空间 2989）里面。</li>
</ul>
<p><code>sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A</code>: <strong>作用</strong>：在命名空间 2989 内，为设备 <code>A</code> 分配 <strong>IP</strong> 地址 <code>10.1.1.1</code>。</p>
<ul>
<li><code>ip netns exec 2989</code>：在命名空间 2989 内部执行命令</li>
<li><code>ip addr add 10.1.1.1/32</code>：添加 IP 地址，<code>/32</code> 表示单机地址（只有自己）</li>
<li><strong>比喻</strong>：给第一个房间里的网线端口分配一个电话号码 <code>10.1.1.1</code>。</li>
</ul>
<p><code>sudo ip netns exec 2989 ip link set A up</code>: <strong>作用</strong>：在命名空间 2989 内，启动网络设备 <code>A</code>。</p>
<ul>
<li><strong>比喻</strong>：打开第一个房间网线端口的电源开关。</li>
</ul>
<p><code>sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A</code>: <strong>作用</strong>：在命名空间 2989 内，添加路由规则：访问 <code>10.1.1.2</code> 的流量都通过设备 <code>A</code> 发送。</p>
<ul>
<li><strong>比喻</strong>：告诉第一个房间：”如果你想打电话给 10.1.1.2，就用 A 这个电话线。”</li>
</ul>
<p>此时状态：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命名空间 2989：</span><br><span class="line">设备 A: IP=10.1.1.1/32，状态 UP</span><br><span class="line">路由：10.1.1.2/32 → 设备 A</span><br><span class="line"></span><br><span class="line">主机根命名空间：</span><br><span class="line">只剩下设备 B（A 已经被移走了）</span><br></pre></td></tr></table></figure>

<p><strong>配置第二个命名空间（3004）的网络</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> B netns 3004</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip addr add 10.1.1.2/32 dev B</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip <span class="built_in">link</span> <span class="built_in">set</span> B up</span><br><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 3004 ip route add 10.1.1.1/32 dev B</span><br></pre></td></tr></table></figure>
<p>作用同上。</p>
<p><strong>最终网络拓扑</strong></p>
<p>完成后，两个命名空间通过 veth pair 直接相连：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">命名空间 2989 (PID 2989)         命名空间 3004 (PID 3004)</span><br><span class="line">     ↓                               ↓</span><br><span class="line">设备 A (10.1.1.1/32) &lt;---&gt; 设备 B (10.1.1.2/32)</span><br><span class="line">     ↑                               ↑</span><br><span class="line">路由：10.1.1.2 → dev A       路由：10.1.1.1 → dev B</span><br></pre></td></tr></table></figure>

<h4 id="与-Docker-的关系"><a href="#与-Docker-的关系" class="headerlink" title="与 Docker 的关系"></a>与 Docker 的关系</h4><p><strong>这就是 Docker 容器网络的底层实现！</strong></p>
<ul>
<li><strong>网络命名空间 ≈ Docker 容器</strong></li>
<li><strong>veth pair ≈ Docker 容器连接到 docker0 网桥的虚拟网卡</strong></li>
<li>在 Docker 中，这个过程是自动完成的：<ul>
<li>创建容器时自动创建新的网络命名空间</li>
<li>自动创建 veth pair，一端在容器内（eth0），一端在主机上并连接到 docker0 网桥</li>
<li>自动分配 IP 地址和路由规则</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>概念</th>
<th>解释</th>
<th>比喻</th>
</tr>
</thead>
<tbody><tr>
<td>网络命名空间</td>
<td>隔离的网络环境</td>
<td>独立的房间</td>
</tr>
<tr>
<td>veth pair</td>
<td>成对的虚拟网络设备</td>
<td>一根网线的两端</td>
</tr>
<tr>
<td>ip netns exec</td>
<td>在指定命名空间内执行命令</td>
<td>进入某个房间操作</td>
</tr>
<tr>
<td>ip link set netns</td>
<td>将网络设备移动到指定命名空间</td>
<td>把网线插头插到某个房间</td>
</tr>
<tr>
<td>ip route add</td>
<td>添加路由规则</td>
<td>设置电话号码拨打规则</td>
</tr>
</tbody></table>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>评估 <strong>Docker</strong> 的安全性时，主要考虑三个方面:</p>
<ul>
<li>由内核的命名空间和控制组机制提供的容器内在安全</li>
<li><strong>Docker</strong> 程序（特别是服务端）本身的抗攻击性</li>
<li>内核安全性的加强机制对容器安全性的影响</li>
</ul>
<h3 id="内核命名空间"><a href="#内核命名空间" class="headerlink" title="内核命名空间"></a>内核命名空间</h3><p><strong>Docker</strong> 容器和 <strong>LXC</strong> 容器很相似，所提供的安全特性也差不多。当用 <code>docker run</code> 启动一个容器时，在后台 <strong>Docker</strong> 为容器创建了一个独立的命名空间和控制组集合。</p>
<p>命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其它容器发现和作用。</p>
<p>每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 <strong>sockets</strong> 或接口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他容器交互。当指定公共端口或使用 <strong>links</strong> 来连接 2 个容器时，容器就可以相互通信了（可以根据配置来限制通信的策略）。</p>
<p>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样。</p>
<p>内核命名空间从 2.6.15 版本（2008 年 7 月发布）之后被引入，数年间，这些机制的可靠性在诸多大型生产系统中被实践验证。</p>
<p>实际上，命名空间的想法和设计提出的时间要更早，最初是为了在内核中引入一种机制来实现 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenVZ">OpenVZ</a> 的特性。 而 <strong>OpenVZ</strong> 项目早在 2005 年就发布了，其设计和实现都已经十分成熟。</p>
<h3 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h3><p>控制组是 <strong>Linux</strong> 容器机制的另外一个关键组件，负责实现资源的审计和限制。</p>
<p>它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、<strong>CPU</strong>、磁盘 <strong>IO</strong> 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p>
<p>尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（<strong>DDOS</strong>）攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的 <strong>PaaS</strong>）上，控制组十分重要。例如，当某些应用程序表现异常的时候，可以保证一致地正常运行和性能。</p>
<p>控制组机制始于 2006 年，内核从 2.6.24 版本开始被引入。</p>
<h3 id="Docker服务端的防护"><a href="#Docker服务端的防护" class="headerlink" title="Docker服务端的防护"></a>Docker服务端的防护</h3><p>运行一个容器或应用程序的核心是通过 <strong>Docker</strong> 服务端。<strong>Docker</strong> 服务的运行目前需要 <strong>root</strong> 权限，因此其安全性十分关键。</p>
<p>首先，确保只有可信的用户才可以访问 <strong>Docker</strong> 服务。<strong>Docker</strong> 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制。例如，恶意用户启动容器的时候将主机的根目录<code>/</code>映射到容器的 <code>/host</code> 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了。事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享主机根文件系统到虚拟机系统。</p>
<p>这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 <strong>web</strong> 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器。</p>
<p>为了加强对服务端的保护，<strong>Docker</strong> 的 <strong>REST API</strong>（客户端用来跟服务端通信）在 0.5.2 之后使用本地的 <strong>Unix</strong> 套接字机制替代了原先绑定在 127.0.0.1 上的 <strong>TCP</strong> 套接字，因为后者容易遭受跨站脚本攻击。现在用户使用 <strong>Unix</strong> 权限检查来加强套接字的访问安全。</p>
<p>用户仍可以利用 <strong>HTTP</strong> 提供 <strong>REST API</strong> 访问。建议使用安全机制，确保只有可信的网络或 <strong>VPN</strong>，或证书保护机制（例如受保护的 <strong>stunnel</strong> 和 <strong>ssl</strong> 认证）下的访问可以进行。此外，还可以使用 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/protect-access/">HTTPS 和证书</a> 来加强保护。</p>
<p>最近改进的 <strong>Linux</strong> 命名空间机制将可以实现使用非 <strong>root</strong> 用户来运行全功能的容器。这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。</p>
<p>终极目标是改进 2 个重要的安全特性：</p>
<ul>
<li>将容器的 <strong>root</strong> 用户 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/userns-remap/">映射到本地主机上的非 root 用户</a>，减轻容器和主机之间因权限提升而引起的安全问题；</li>
<li>允许 <strong>Docker</strong> 服务端在 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/rootless/">非 root 权限(rootless 模式) </a>下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</li>
</ul>
<p>最后，建议采用专用的服务器来运行 <strong>Docker</strong> 和相关的管理服务（例如管理服务比如 <strong>ssh</strong> 监控和进程监控、管理工具 <strong>nrpe</strong>、<strong>collectd</strong> 等）。其它的业务服务都放到容器中去运行。</p>
<h3 id="内核能力机制"><a href="#内核能力机制" class="headerlink" title="内核能力机制"></a>内核能力机制</h3><p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/capabilities.7.html">能力机制（Capability）</a>是 <strong>Linux</strong> 内核一个强大的特性，可以提供细粒度的权限访问控制。 <strong>Linux</strong> 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上。</p>
<p>例如，一个 <strong>Web</strong> 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 <strong>root</strong> 权限。那么它只需要被授权 <code>net_bind_service</code> 能力即可。此外，还有很多其他的类似能力来避免进程获取 <strong>root</strong> 权限。</p>
<p>默认情况下，<strong>Docker</strong> 启动的容器被严格限制只允许使用内核的一部分能力。</p>
<p>使用能力机制对加强 <strong>Docker</strong> 容器的安全有很多好处。通常，在服务器上会运行一堆需要特权权限的进程，包括有 <strong>ssh</strong>、<strong>cron</strong>、<strong>syslogd</strong>、硬件管理工具模块（例如负载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进程都由容器以外的支持系统来进行管理。</p>
<ul>
<li>ssh 访问被主机上ssh服务来管理；</li>
<li>cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；</li>
<li>日志系统可由 Docker 或第三方服务管理；</li>
<li>硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；</li>
<li>网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。</li>
</ul>
<p>从上面的例子可以看出，大部分情况下，容器并不需要“真正的” <strong>root</strong> 权限，容器只需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。</p>
<ul>
<li>完全禁止任何 mount 操作；</li>
<li>禁止直接访问本地主机的套接字；</li>
<li>禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</li>
<li>禁止模块加载。</li>
</ul>
<p>这样，就算攻击者在容器中取得了 <strong>root</strong> 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p>
<p>默认情况下，<strong>Docker</strong>采用 <strong>白名单</strong> 机制，禁用必需功能之外的其它权限。 当然，用户也可以根据自身需求来为 <strong>Docker</strong> 容器启用额外的权限。</p>
<h3 id="其它安全特性"><a href="#其它安全特性" class="headerlink" title="其它安全特性"></a>其它安全特性</h3><p>除了能力机制之外，还可以利用一些现有的安全机制来增强使用 <strong>Docker</strong> 的安全性，例如 <strong>TOMOYO</strong>, <strong>AppArmor</strong>, <strong>Seccomp</strong>, <strong>SELinux</strong>, <strong>GRSEC</strong> 等。</p>
<p><strong>Docker</strong> 当前默认只启用了能力机制。用户可以采用多种方案来加强 <strong>Docker</strong> 主机的安全，例如：</p>
<ul>
<li>在内核中启用 <strong>GRSEC</strong> 和 <strong>PAX</strong>，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且，启用该特性不需要 <strong>Docker</strong> 进行任何配置。</li>
<li>使用一些有增强安全特性的容器模板，比如带 <strong>AppArmor</strong> 的模板和 <strong>Redhat</strong> 带 <strong>SELinux</strong> 策略的模板。这些模板提供了额外的安全特性。</li>
<li>用户可以自定义访问控制机制来定制安全策略。</li>
</ul>
<p>跟其它添加到 <strong>Docker</strong> 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 <strong>Docker</strong> 内核情况下就可以加固现有的容器。</p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>总体来看，<strong>Docker</strong> 容器还是十分安全的，特别是在容器内不使用 <strong>root</strong> 权限来运行进程的话。</p>
<p>另外，用户可以使用现有工具，比如 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/apparmor/">Apparmor</a> , <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/seccomp/">Seccomp</a> , SELinux, GRSEC 来增强安全性；甚至自己在内核中实现更复杂的安全机制。</p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p><strong>Docker</strong> 底层的核心技术包括 <strong>Linux</strong> 上的<strong>命名空间（Namespaces）</strong>、<strong>控制组（Control groups）</strong>、<strong>Union 文件系统（Union file systems）<strong>和</strong>容器格式（Container format）</strong>。</p>
<p>传统的虚拟机通过在宿主主机中运行 <strong>hypervisor</strong> 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。 例如，以宿主机和虚拟机系统都为 <strong>Linux</strong> 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</p>
<p>在操作系统中，包括<strong>内核</strong>、<strong>文件系统</strong>、<strong>网络</strong>、<strong>PID</strong>、<strong>UID</strong>、<strong>IPC</strong>、<strong>内存</strong>、<strong>硬盘</strong>、<strong>CPU</strong> 等等，所有的资源都是应用进程直接共享的。 要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。 前者相对容易实现一些，后者则需要宿主机系统的深入支持。</p>
<p>随着 <strong>Linux</strong> 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。这种机制就是<strong>容器（Container）</strong>，利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。</p>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p><strong>Docker</strong> 采用了 <code>C/S</code> 架构，包括客户端和服务端。<strong>Docker</strong> 守护进程（<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p>
<p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p>
<p><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-04.svg" alt="Docker 架构"></p>
<p><a href="#Docker-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92">查看Docker 架构说明</a></p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间是 Linux 内核的一个特性，用于对全局系统资源进行隔离和封装</strong>。 每个命名空间中的进程都认为自己独享系统资源，看不到其他命名空间的进程和资源。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p>
<p>比喻：就像一栋大楼里的不同房间，每个房间（命名空间）里的人只能看到自己房间内的东西，不知道其他房间的存在。</p>
<h4 id="PID-命名空间（Process-ID）"><a href="#PID-命名空间（Process-ID）" class="headerlink" title="PID 命名空间（Process ID）"></a>PID 命名空间（Process ID）</h4><p><strong>作用：进程隔离。</strong> 隔离进程 ID 号空间，不同 PID 命名空间中的进程可以有相同的 PID。</p>
<ul>
<li>在主机上，每个进程有唯一的 PID（如 1, 2, 3…）</li>
<li>在每个 PID 命名空间内，进程 PID 也是从 1 开始编号</li>
<li>命名空间内的进程看不到主机或其他命名空间的进程</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在主机上查看进程</span></span><br><span class="line">ps aux | <span class="built_in">head</span></span><br><span class="line"><span class="comment"># PID 1: systemd (主机初始化进程)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器内查看进程</span></span><br><span class="line">docker run -it alpine ps aux</span><br><span class="line"><span class="comment"># PID 1: 容器自己的初始化进程（如 /bin/sh）</span></span><br><span class="line"><span class="comment"># 看不到主机的 systemd (PID 1)</span></span><br></pre></td></tr></table></figure>
<p><strong>Docker 中的应用：</strong></p>
<ul>
<li>容器内的进程认为自己的 PID 是 1</li>
<li><code>docker top &lt;container&gt;</code> 显示的是主机视角的 PID</li>
<li>实现进程树的隔离</li>
</ul>
<h4 id="NET-命名空间（Network）"><a href="#NET-命名空间（Network）" class="headerlink" title="NET 命名空间（Network）"></a>NET 命名空间（Network）</h4><p><strong>作用：网络隔离。</strong> 每个网络命名空间有自己的网络设备、IP 地址、路由表、防火墙规则等。</p>
<ul>
<li>独立的网络栈：网卡、端口、IP 地址等</li>
<li>默认只有 loopback 设备（lo）</li>
<li>通过 <code>veth pair</code> 与主机或其他命名空间连接</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机网络设备</span></span><br><span class="line">ip addr show</span><br><span class="line"><span class="comment"># 1: lo, 2: eth0, 3: docker0...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器内网络设备</span></span><br><span class="line">docker run -it alpine ip addr show</span><br><span class="line"><span class="comment"># 1: lo, 2: eth0@ifxxx (虚拟设备)</span></span><br><span class="line"><span class="comment"># 有自己的 IP 地址（如 172.17.0.2）</span></span><br></pre></td></tr></table></figure>
<p><strong>Docker 中的应用：</strong></p>
<ul>
<li>每个容器有独立的 <strong>IP</strong> 地址和端口空间</li>
<li>容器可以绑定到 <code>80</code> 端口而不会冲突</li>
<li>通过 <code>docker0</code> 网桥实现容器间通信</li>
</ul>
<h4 id="IPC-命名空间（Inter-Process-Communication）"><a href="#IPC-命名空间（Inter-Process-Communication）" class="headerlink" title="IPC 命名空间（Inter-Process Communication）"></a>IPC 命名空间（Inter-Process Communication）</h4><p><strong>作用：进程间通信隔离。</strong> 隔离 System V IPC 和 POSIX 消息队列等进程间通信资源。</p>
<ul>
<li>隔离的信号量、消息队列、共享内存段</li>
<li>不同 IPC 命名空间的进程无法通过这些机制通信</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机上创建信号量</span></span><br><span class="line">ipcmk -S 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器内看不到主机的信号量</span></span><br><span class="line">docker run -it alpine ipcs -s</span><br><span class="line"><span class="comment"># ------ Semaphore Arrays --------</span></span><br><span class="line"><span class="comment"># 空（看不到主机创建的）</span></span><br></pre></td></tr></table></figure>
<p><strong>Docker 中的应用：</strong></p>
<ul>
<li>防止容器内的进程意外访问主机或其他容器的共享内存</li>
<li>保证容器间 <strong>IPC</strong> 通信的隔离性</li>
</ul>
<h4 id="MNT-命名空间（Mount）"><a href="#MNT-命名空间（Mount）" class="headerlink" title="MNT 命名空间（Mount）"></a>MNT 命名空间（Mount）</h4><p><strong>作用：文件系统挂载点隔离。</strong> 每个 MNT 命名空间有独立的文件系统挂载点视图。</p>
<ul>
<li>独立的根文件系统（rootfs）挂载点</li>
<li>挂载&#x2F;卸载操作只影响当前命名空间</li>
<li>可以实现 <strong>chroot</strong> 类似的效果，但更安全</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机挂载点</span></span><br><span class="line">mount | grep /dev/sda</span><br><span class="line"><span class="comment"># /dev/sda1 on / type ext4 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器内挂载点</span></span><br><span class="line">docker run -it alpine mount</span><br><span class="line"><span class="comment"># 只有容器自己的挂载点，看不到主机的</span></span><br></pre></td></tr></table></figure>
<p><strong>Docker 中的应用：</strong></p>
<ul>
<li>为每个容器提供独立的根文件系统</li>
<li>容器可以挂载自己的 <strong>volumes</strong> 而不影响主机</li>
<li>实现文件系统的隔离</li>
</ul>
<h4 id="UTS-命名空间（UNIX-Time-sharing-System）"><a href="#UTS-命名空间（UNIX-Time-sharing-System）" class="headerlink" title="UTS 命名空间（UNIX Time-sharing System）"></a>UTS 命名空间（UNIX Time-sharing System）</h4><p><strong>作用：主机名和域名隔离。</strong> 允许每个容器有自己的主机名和 NIS 域名。</p>
<ul>
<li>独立的 <code>nodename</code>（主机名）和 <code>domainname</code></li>
<li>通过 <code>sethostname()</code>, <code>setdomainname()</code> 系统调用设置</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机主机名</span></span><br><span class="line">hostname</span><br><span class="line"><span class="comment"># my-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器并设置主机名</span></span><br><span class="line">docker run -it --hostname my-container alpine hostname</span><br><span class="line"><span class="comment"># my-container（容器内看到的主机名）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从主机查看容器进程</span></span><br><span class="line">docker <span class="built_in">exec</span> &lt;container&gt; hostname</span><br><span class="line"><span class="comment"># my-container</span></span><br></pre></td></tr></table></figure>
<p><strong>Docker 中的应用：</strong></p>
<ul>
<li><code>docker run --hostname</code> 为容器设置独立主机名</li>
<li>微服务中可以用主机名标识不同服务实例</li>
<li>网络服务配置更加清晰</li>
</ul>
<h4 id="USER-命名空间（User）"><a href="#USER-命名空间（User）" class="headerlink" title="USER 命名空间（User）"></a>USER 命名空间（User）</h4><p><strong>作用：用户和用户组 ID 隔离。</strong> 最复杂的命名空间，映射用户和组 ID。</p>
<ul>
<li>容器内的 root 用户（UID 0）可以映射到主机上的非 root 用户</li>
<li>增强安全性：即使容器被攻破，攻击者也是以非特权用户运行</li>
<li>用户 ID 和组 ID 在命名空间内外可以不同</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机用户</span></span><br><span class="line"><span class="built_in">id</span></span><br><span class="line"><span class="comment"># uid=1000(user) gid=1000(user)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在用户命名空间内（容器内）</span></span><br><span class="line">docker run -it --user 1000:1000 alpine <span class="built_in">id</span></span><br><span class="line"><span class="comment"># uid=0(root) gid=0(root)  # 但实际权限受限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用用户命名空间映射</span></span><br><span class="line"><span class="comment"># 容器内 uid 0 映射到主机 uid 1000</span></span><br></pre></td></tr></table></figure>
<p><strong>Docker 中的应用：</strong></p>
<ul>
<li><strong>rootless Docker</strong> 的核心技术</li>
<li>提高容器安全性</li>
<li>避免容器内的 <strong>root</strong> 拥有主机 <strong>root</strong> 权限</li>
</ul>
<h4 id="命名空间在-Docker-中的综合应用"><a href="#命名空间在-Docker-中的综合应用" class="headerlink" title="命名空间在 Docker 中的综合应用"></a>命名空间在 Docker 中的综合应用</h4><p>当启动一个容器时，<strong>Docker</strong> 会为它创建所有这些命名空间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这行命令背后创建了所有6种命名空间</span></span><br><span class="line">docker run -it --hostname myapp --user 1000:1000 -v /data:/app alpine sh</span><br></pre></td></tr></table></figure>
<p>创建的命名空间：</p>
<ol>
<li><strong>PID</strong>: 隔离进程，容器内 <strong>PID</strong> 从 1 开始</li>
<li><strong>NET</strong>: 独立的网络栈，自有 <strong>IP</strong> 和端口</li>
<li><strong>IPC</strong>: 隔离的进程间通信</li>
<li><strong>MNT</strong>: 独立的根文件系统和挂载点（包括 <code>/data → /app</code> 的挂载）</li>
<li><strong>UTS</strong>: 独立的主机名 <code>myapp</code></li>
<li><strong>USER</strong>: 用户 ID 映射，容器内 <code>root</code> 对应主机 <code>uid 1000</code></li>
</ol>
<h4 id="查看命名空间"><a href="#查看命名空间" class="headerlink" title="查看命名空间"></a>查看命名空间</h4><p>查看进程的命名空间:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程的命名空间信息</span></span><br><span class="line"><span class="built_in">ls</span> -la /proc/$$/ns/</span><br><span class="line"><span class="comment"># 输出类似：</span></span><br><span class="line"><span class="comment"># lrwxrwxrwx 1 root root 0 Jan 1 12:00 cgroup -&gt; &#x27;cgroup:[4026531835]&#x27;</span></span><br><span class="line"><span class="comment"># lrwxrwxrwx 1 root root 0 Jan 1 12:00 ipc -&gt; &#x27;ipc:[4026531839]&#x27;</span></span><br><span class="line"><span class="comment"># lrwxrwxrwx 1 root root 0 Jan 1 12:00 mnt -&gt; &#x27;mnt:[4026531840]&#x27;</span></span><br><span class="line"><span class="comment"># lrwxrwxrwx 1 root root 0 Jan 1 12:00 net -&gt; &#x27;net:[4026531993]&#x27;</span></span><br><span class="line"><span class="comment"># lrwxrwxrwx 1 root root 0 Jan 1 12:00 pid -&gt; &#x27;pid:[4026531836]&#x27;</span></span><br><span class="line"><span class="comment"># lrwxrwxrwx 1 root root 0 Jan 1 12:00 user -&gt; &#x27;user:[4026531837]&#x27;</span></span><br><span class="line"><span class="comment"># lrwxrwxrwx 1 root root 0 Jan 1 12:00 uts -&gt; &#x27;uts:[4026531838]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>查看容器的命名空间:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取容器主进程PID</span></span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> &lt;container_id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看该进程的命名空间</span></span><br><span class="line"><span class="built_in">ls</span> -la /proc/&lt;container_pid&gt;/ns/</span><br></pre></td></tr></table></figure>

<h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>命名空间</th>
<th>隔离内容</th>
<th>Docker 应用示例</th>
<th>安全重要性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>PID</strong></td>
<td>进程ID和进程树</td>
<td>容器内进程独立，PID从1开始</td>
<td>高</td>
</tr>
<tr>
<td><strong>NET</strong></td>
<td>网络设备、IP、端口</td>
<td>每个容器有独立IP和端口空间</td>
<td>高</td>
</tr>
<tr>
<td><strong>IPC</strong></td>
<td>进程间通信</td>
<td>隔离共享内存、信号量</td>
<td>中</td>
</tr>
<tr>
<td><strong>MNT</strong></td>
<td>文件系统挂载点</td>
<td>独立的根文件系统，volume挂载</td>
<td>高</td>
</tr>
<tr>
<td><strong>UTS</strong></td>
<td>主机名和域名</td>
<td><code>--hostname</code> 设置容器主机名</td>
<td>低</td>
</tr>
<tr>
<td><strong>USER</strong></td>
<td>用户和组ID</td>
<td>用户ID映射，rootless容器</td>
<td>极高</td>
</tr>
</tbody></table>
<p>这些命名空间共同构成了 <strong>Linux</strong> 容器的隔离基础，<strong>Docker</strong> 正是通过巧妙地组合使用这些命名空间，实现了轻量级、高效的应用沙箱环境。</p>
<h3 id="控制组-1"><a href="#控制组-1" class="headerlink" title="控制组"></a>控制组</h3><p>控制组（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a>）是 <strong>Linux</strong> 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<p>控制组技术最早是由 <strong>Google</strong> 的程序员在 2006 年提出，<strong>Linux</strong> 内核自 2.6.24 开始支持。</p>
<p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<h3 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h3><p>联合文件系统（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 <strong>Docker</strong> 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 <strong>Docker</strong> 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p><strong>Docker</strong> 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p><strong>Docker</strong> 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p>
<p>各 <strong>Linux</strong> 发行版 <strong>Docker</strong> 推荐使用的存储驱动如下表:</p>
<table>
<thead>
<tr>
<th><strong>Linux 发行版</strong></th>
<th>**Docker 推荐使用的存储驱动 **</th>
</tr>
</thead>
<tbody><tr>
<td>Docker on Ubuntu</td>
<td><code>overlay2</code> (16.04 +)</td>
</tr>
<tr>
<td>Docker on Debian</td>
<td><code>overlay2</code> (Debian Stretch), <code>aufs</code>, <code>devicemapper</code></td>
</tr>
<tr>
<td>Docker on CentOS</td>
<td><code>overlay2</code></td>
</tr>
<tr>
<td>Docker on Fedora</td>
<td><code>overlay2</code></td>
</tr>
</tbody></table>
<p>在可能的情况下，<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/storage/drivers/select-storage-driver/">推荐</a> 使用 <code>overlay2</code> <code>存储驱动，overlay2</code> 是目前 <strong>Docker</strong> 默认的存储驱动，以前则是 <code>aufs</code>。你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
<h3 id="容器格式"><a href="#容器格式" class="headerlink" title="容器格式"></a>容器格式</h3><p>最初，<strong>Docker</strong> 采用了 <code>LXC</code> 中的容器格式。从 0.7 版本以后开始去除 <strong>LXC</strong>，转而使用自行开发的 <a target="_blank" rel="noopener" href="https://github.com/docker-archive/libcontainer">libcontainer</a> ，从 1.11 开始，则进一步演进为使用 <a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc">runC</a> 和 <a target="_blank" rel="noopener" href="https://github.com/containerd/containerd">containerd</a> 。</p>
<h3 id="Docker-网络实现"><a href="#Docker-网络实现" class="headerlink" title="Docker 网络实现"></a>Docker 网络实现</h3><p><strong>Docker</strong> 的网络实现其实就是利用了 <strong>Linux</strong> 上的<strong>网络命名空间</strong>和<strong>虚拟网络设备（特别是 veth pair）</strong>。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包；如果不同子网之间要进行通信，需要路由机制。</p>
<p><strong>Docker</strong> 中的网络接口默认都是虚拟接口。虚拟接口的优势之一是转发效率较高。 <strong>Linux</strong> 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，速度要快很多。</p>
<p><strong>Docker</strong> 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做 <code>veth pair</code>）。</p>
<h4 id="Docker-创建容器时的网络操作"><a href="#Docker-创建容器时的网络操作" class="headerlink" title="Docker 创建容器时的网络操作"></a>Docker 创建容器时的网络操作</h4><ol>
<li><strong>创建 veth pair</strong>：一对虚拟网卡，分别放到本地主机和新容器中。</li>
<li><strong>主机端</strong>：连接到 docker0 网桥，命名为 <code>vethxxx</code></li>
<li><strong>容器端</strong>：放入容器网络命名空间，重命名为 <code>eth0</code></li>
<li><strong>分配 IP</strong>：从 docker0 网段分配地址</li>
<li><strong>配置路由</strong>：设置默认网关</li>
</ol>
<h4 id="四种网络模式"><a href="#四种网络模式" class="headerlink" title="四种网络模式"></a>四种网络模式</h4><ul>
<li><code>--net=bridge</code>：默认，连接到 docker0</li>
<li><code>--net=host</code>：共享主机网络栈</li>
<li><code>--net=container:NAME</code>：共享其他容器的网络</li>
<li><code>--net=none</code>：无网络，需要手动配置</li>
</ul>
<h4 id="手动网络配置演示"><a href="#手动网络配置演示" class="headerlink" title="手动网络配置演示"></a>手动网络配置演示</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 获取容器PID（找到容器的&quot;房间号&quot;）</span></span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> 63f36fc01b5f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建网络命名空间链接（为这个&quot;房间&quot;创建门牌号）</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /proc/<span class="variable">$pid</span>/ns/net /var/run/netns/<span class="variable">$pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建veth pair（制作虚拟网线）</span></span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> add A <span class="built_in">type</span> veth peer name B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 连接主机端到docker0网桥（把网线一端插到交换机）</span></span><br><span class="line"><span class="built_in">sudo</span> brctl addif docker0 A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 将另一端放入容器（把网线另一端拉到容器房间）</span></span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> B netns <span class="variable">$pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 在容器内配置网络（在容器房间内设置网络）</span></span><br><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev B name eth0</span><br><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip addr add 172.17.42.99/16 dev eth0</span><br><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> <span class="variable">$pid</span> ip route add default via 172.17.42.1</span><br></pre></td></tr></table></figure>

<h4 id="关键概念深度解析"><a href="#关键概念深度解析" class="headerlink" title="关键概念深度解析"></a>关键概念深度解析</h4><ol>
<li>网络命名空间（Network Namespace）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器的网络命名空间</span></span><br><span class="line"><span class="built_in">ls</span> -la /proc/2778/ns/net</span><br><span class="line"><span class="comment"># lrwxrwxrwx 1 root root 0 Jan 1 12:00 net -&gt; net:[4026532289]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过符号链接方便访问</span></span><br><span class="line"><span class="built_in">ln</span> -s /proc/2778/ns/net /var/run/netns/2778</span><br></pre></td></tr></table></figure>
<ul>
<li>每个容器有独立的网络环境</li>
<li>通过 PID 可以找到对应的网络命名空间</li>
</ul>
<ol start="2">
<li>veth pair 工作原理</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">容器内部: eth0 (172.17.42.99) </span><br><span class="line">         ↑</span><br><span class="line">      veth pair (虚拟网线)</span><br><span class="line">         ↓  </span><br><span class="line">主机: vethxxx → docker0网桥 (172.17.42.1)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>ip netns exec 命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在指定网络命名空间中执行命令</span></span><br><span class="line"><span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 2778 ip addr show</span><br><span class="line"><span class="comment"># 相当于&quot;进入&quot;容器的网络环境查看配置</span></span><br></pre></td></tr></table></figure>

<h4 id="现代-Docker-的改进"><a href="#现代-Docker-的改进" class="headerlink" title="现代 Docker 的改进"></a>现代 Docker 的改进</h4><p>以上内容基于较旧的 Docker 版本，现代 Docker 有一些变化：</p>
<ol>
<li>网络驱动体系<br>现代 Docker 使用更灵活的网络驱动：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有网络驱动</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建自定义网络</span></span><br><span class="line">docker network create my_network</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>CNM（Container Network Model）<br>Docker 现在的网络架构基于：</li>
</ol>
<ul>
<li>Sandbox：容器网络栈（网络命名空间）</li>
<li>Endpoint：网络接口（veth pair）</li>
<li>Network：网络组（网桥）</li>
</ul>
<ol start="3">
<li>更简单的网络管理</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建自定义网络</span></span><br><span class="line">docker network create --driver bridge my_bridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接容器到自定义网络</span></span><br><span class="line">docker run --network my_bridge nginx</span><br></pre></td></tr></table></figure>

<h2 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h2><p><strong>etcd</strong> 是一个高可用的、强一致性的分布式键值存储，主要用于共享配置、服务发现和协调分布式系统。它的名字源于 Unix 的 <code>/etc</code> 目录（存储配置）加上 “d”（distributed，分布式）。是现代云原生生态系统的基石。</p>
<h3 id="核心定位："><a href="#核心定位：" class="headerlink" title="核心定位："></a>核心定位：</h3><ul>
<li><strong>分布式系统的”大脑”</strong>：协调和管理分布式集群的状态</li>
<li><strong>配置的”真理之源”</strong>：存储集群的关键配置信息</li>
<li><strong>服务的”注册中心”</strong>：实现服务发现和健康检查</li>
</ul>
<h3 id="谁在使用-etcd？"><a href="#谁在使用-etcd？" class="headerlink" title="谁在使用 etcd？"></a>谁在使用 etcd？</h3><p>etcd 最著名的用户包括：</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>使用方式</th>
</tr>
</thead>
<tbody><tr>
<td>Kubernetes</td>
<td>存储所有集群状态、配置和服务发现信息</td>
</tr>
<tr>
<td>CoreDNS</td>
<td>分布式 DNS 服务的后端存储</td>
</tr>
<tr>
<td>Rook</td>
<td>云原生存储编排</td>
</tr>
<tr>
<td>OpenStack</td>
<td>多个组件的配置存储</td>
</tr>
</tbody></table>
<h3 id="etcd-的核心特性"><a href="#etcd-的核心特性" class="headerlink" title="etcd 的核心特性"></a>etcd 的核心特性</h3><p>etcd **<a target="_blank" rel="noopener" href="https://raft.github.io/">使用 Raft 共识算法</a>**确保所有节点数据一致：</p>
<ul>
<li>任何写操作必须得到大多数节点确认</li>
<li>读操作可以保证读到最新已提交的数据</li>
<li>数据在不同节点间自动同步</li>
</ul>
<h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><ul>
<li>支持多节点集群部署</li>
<li>自动故障转移和领导者选举</li>
<li>数据自动备份和恢复</li>
</ul>
<h4 id="简单可靠的-API"><a href="#简单可靠的-API" class="headerlink" title="简单可靠的 API"></a>简单可靠的 API</h4><ul>
<li>基于 HTTP&#x2F;gRPC 的 RESTful API</li>
<li>简单的键值操作（PUT&#x2F;GET&#x2F;DELETE）</li>
<li>监听键值变化（Watch）</li>
</ul>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><ul>
<li>支持 TLS 加密通信</li>
<li>基于角色的访问控制（RBAC）</li>
<li>客户端认证和授权</li>
</ul>
<h3 id="etcd-的架构"><a href="#etcd-的架构" class="headerlink" title="etcd 的架构"></a>etcd 的架构</h3><p><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-09.png" alt="etcd 集群架构图"><br>架构说明（3 节点集群示例）:</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>etcd 节点</strong></td>
<td>例如 <code>etcd-1</code>、<code>etcd-2</code>、<code>etcd-3</code>，共同组成 Raft 集群</td>
</tr>
<tr>
<td><strong>Raft 协议</strong></td>
<td>保证分布式一致性，其中一个节点为 Leader，其余为 Follower</td>
</tr>
<tr>
<td><strong>Client（客户端）</strong></td>
<td>如 <code>kube-apiserver</code> 或其他使用 etcd 的应用，通过 <code>Client Port</code> 访问集群</td>
</tr>
<tr>
<td><strong>Peer 端口（2380）</strong></td>
<td>节点之间同步数据、选举 Leader 使用</td>
</tr>
<tr>
<td><strong>Client 端口（2379）</strong></td>
<td>对外提供读写 API 接口</td>
</tr>
<tr>
<td><strong>负载均衡（可选）</strong></td>
<td>可以在集群前加负载均衡器来简化客户端连接配置</td>
</tr>
</tbody></table>
<p>流程简述</p>
<ol>
<li>所有 etcd 节点通过 <strong>Peer 端口（2380）</strong> 互相通信，形成一致性集群。</li>
<li>客户端（如 Kubernetes API Server）通过 <strong>Client 端口（2379）</strong> 与 Leader 或通过 LB 交互。</li>
<li>Raft 算法保证写操作必须多数节点确认（多数派原则），保证一致性。</li>
<li>任一节点宕机，集群仍然可用（多数派存活即可）。</li>
</ol>
<h4 id="核心组件："><a href="#核心组件：" class="headerlink" title="核心组件："></a>核心组件：</h4><ul>
<li><strong>Raft 模块</strong>：处理领导选举和日志复制</li>
<li><strong>存储引擎</strong>：使用 BoltDB 持久化数据</li>
<li><strong>WAL（Write-Ahead Log）</strong>：预写日志，确保数据不丢失</li>
<li><strong>gRPC Server</strong>：处理客户端请求</li>
</ul>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><h4 id="键值存储："><a href="#键值存储：" class="headerlink" title="键值存储："></a>键值存储：</h4><p>etcd 的数据组织类似于文件系统：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├── registry/</span><br><span class="line">│   ├── services/</span><br><span class="line">│   │   ├── web/</span><br><span class="line">│   │   │   ├── instance1 → &quot;10.0.1.1:8080&quot;</span><br><span class="line">│   │   │   └── instance2 → &quot;10.0.1.2:8080&quot;</span><br><span class="line">│   │   └── database/</span><br><span class="line">│   │       └── primary → &quot;10.0.2.1:5432&quot;</span><br><span class="line">└── configs/</span><br><span class="line">    ├── app1/</span><br><span class="line">    │   └── database_url → &quot;postgres://user:pass@10.0.2.1:5432/db&quot;</span><br><span class="line">    └── app2/</span><br><span class="line">        └── feature_flag → &quot;enabled&quot;</span><br></pre></td></tr></table></figure>
<h4 id="键的设计原则："><a href="#键的设计原则：" class="headerlink" title="键的设计原则："></a>键的设计原则：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 层次化键名，便于管理和查询</span></span><br><span class="line">/company/department/service/instance</span><br><span class="line">/tenants/tenant-a/applications/app-b/config</span><br></pre></td></tr></table></figure>

<h3 id="核心-API-操作"><a href="#核心-API-操作" class="headerlink" title="核心 API 操作"></a>核心 API 操作</h3><h4 id="基本的键值操作"><a href="#基本的键值操作" class="headerlink" title="基本的键值操作"></a>基本的键值操作</h4><h5 id="写入数据："><a href="#写入数据：" class="headerlink" title="写入数据："></a>写入数据：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 etcdctl 客户端</span></span><br><span class="line">etcdctl put /app/config/database_url <span class="string">&quot;postgres://localhost:5432/mydb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 带租约（自动过期）</span></span><br><span class="line">etcdctl put /service/web/instance1 <span class="string">&quot;10.0.1.1:8080&quot;</span> --lease=1234abcd</span><br></pre></td></tr></table></figure>

<h5 id="读取数据："><a href="#读取数据：" class="headerlink" title="读取数据："></a>读取数据：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取单个键</span></span><br><span class="line">etcdctl get /app/config/database_url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前缀查询</span></span><br><span class="line">etcdctl get /app/config/ --prefix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只获取值</span></span><br><span class="line">etcdctl get /app/config/database_url --print-value-only</span><br></pre></td></tr></table></figure>

<h5 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除单个键</span></span><br><span class="line">etcdctl del /app/config/database_url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前缀删除</span></span><br><span class="line">etcdctl del /app/config/ --prefix</span><br></pre></td></tr></table></figure>

<h4 id="Watch（监听）功能"><a href="#Watch（监听）功能" class="headerlink" title="Watch（监听）功能"></a>Watch（监听）功能</h4><p>监听键的变化，实现实时通知：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听单个键的变化</span></span><br><span class="line">etcdctl watch /app/config/database_url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听前缀下的所有变化</span></span><br><span class="line">etcdctl watch /service/ --prefix</span><br></pre></td></tr></table></figure>

<h4 id="租约（Lease）机制"><a href="#租约（Lease）机制" class="headerlink" title="租约（Lease）机制"></a>租约（Lease）机制</h4><p>实现键的自动过期，用于服务健康检查：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建租约（30秒后过期）</span></span><br><span class="line">lease_id=$(etcdctl lease grant 30 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用租约写入键</span></span><br><span class="line">etcdctl put /service/web/instance1 <span class="string">&quot;10.0.1.1:8080&quot;</span> --lease=<span class="variable">$lease_id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 续约</span></span><br><span class="line">etcdctl lease keep-alive <span class="variable">$lease_id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看租约信息</span></span><br><span class="line">etcdctl lease timetolive <span class="variable">$lease_id</span></span><br></pre></td></tr></table></figure>

<h3 id="实际应用场景-1"><a href="#实际应用场景-1" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p>场景 1：服务发现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务启动时注册自己</span></span><br><span class="line">lease_id=$(etcdctl lease grant 60 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">etcdctl put /services/web/$(hostname) <span class="string">&quot;<span class="subst">$(hostname -i)</span>:8080&quot;</span> --lease=<span class="variable">$lease_id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持续约（健康检查）</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    etcdctl lease keep-alive <span class="variable">$lease_id</span></span><br><span class="line">    <span class="built_in">sleep</span> 30</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>场景 2：分布式配置管理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储配置</span></span><br><span class="line">etcdctl put /config/app/database <span class="string">&quot;postgres://user:pass@db:5432/app&quot;</span></span><br><span class="line">etcdctl put /config/app/redis <span class="string">&quot;redis://cache:6379&quot;</span></span><br><span class="line">etcdctl put /config/app/feature_new_ui <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用监听配置变化</span></span><br><span class="line">etcdctl watch /config/app/ --prefix</span><br></pre></td></tr></table></figure>

<p>场景 3：分布式锁</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试获取锁</span></span><br><span class="line">etcdctl lock /locks/database-migration -- /bin/bash -c <span class="string">&quot;echo &#x27;Running migration...&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者手动实现</span></span><br><span class="line">lease_id=$(etcdctl lease grant 30 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> etcdctl put /locks/my-lock $(hostname) --lease=<span class="variable">$lease_id</span> --prev-kv; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Lock acquired&quot;</span></span><br><span class="line">    <span class="comment"># 执行关键操作</span></span><br><span class="line">    etcdctl del /locks/my-lock</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Failed to acquire lock&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="在-Kubernetes-中的关键作用"><a href="#在-Kubernetes-中的关键作用" class="headerlink" title="在 Kubernetes 中的关键作用"></a>在 Kubernetes 中的关键作用</h3><p>Kubernetes 严重依赖 etcd 存储所有集群状态：</p>
<h4 id="Kubernetes-在-etcd-中存储的数据："><a href="#Kubernetes-在-etcd-中存储的数据：" class="headerlink" title="Kubernetes 在 etcd 中存储的数据："></a>Kubernetes 在 etcd 中存储的数据：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/registry</span><br><span class="line">├── pods/</span><br><span class="line">│   ├── default/my-app-pod → Pod 定义和状态</span><br><span class="line">│   └── kube-system/metrics-server → 系统 Pod</span><br><span class="line">├── services/</span><br><span class="line">│   ├── default/web-service → Service 定义</span><br><span class="line">│   └── kube-system/kube-dns → DNS Service</span><br><span class="line">├── deployments/</span><br><span class="line">│   └── default/my-app → Deployment 配置</span><br><span class="line">├── configmaps/</span><br><span class="line">│   └── default/app-config → 配置信息</span><br><span class="line">├── secrets/</span><br><span class="line">│   └── default/db-credentials → 加密的敏感信息</span><br><span class="line">└── nodes/</span><br><span class="line">    ├── node-1 → 节点状态</span><br><span class="line">    └── node-2 → 节点状态</span><br></pre></td></tr></table></figure>

<p>如果没有 etcd，Kubernetes 将：</p>
<ul>
<li>无法记住集群的当前状态</li>
<li>无法协调期望状态和实际状态</li>
<li>无法进行服务发现</li>
<li>无法存储配置和密钥</li>
</ul>
<h3 id="安装和部署"><a href="#安装和部署" class="headerlink" title="安装和部署"></a>安装和部署</h3><p>单节点开发环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Docker 运行</span></span><br><span class="line">docker run -d \</span><br><span class="line">  --name etcd \</span><br><span class="line">  -p 2379:2379 \</span><br><span class="line">  -p 2380:2380 \</span><br><span class="line">  quay.io/coreos/etcd:v3.5.0 \</span><br><span class="line">  /usr/local/bin/etcd \</span><br><span class="line">  --name single-node \</span><br><span class="line">  --data-dir /etcd-data \</span><br><span class="line">  --listen-client-urls http://0.0.0.0:2379 \</span><br><span class="line">  --advertise-client-urls http://0.0.0.0:2379 \</span><br><span class="line">  --listen-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">  --initial-advertise-peer-urls http://0.0.0.0:2380 \</span><br><span class="line">  --initial-cluster single-node=http://0.0.0.0:2380 \</span><br><span class="line">  --initial-cluster-token etcd-cluster \</span><br><span class="line">  --initial-cluster-state new</span><br></pre></td></tr></table></figure>

<p>生产环境集群部署（3节点）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 节点1</span></span><br><span class="line">etcd --name infra1 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --listen-client-urls http://10.0.1.10:2379 \</span><br><span class="line">  --advertise-client-urls http://10.0.1.10:2379 \</span><br><span class="line">  --listen-peer-urls http://10.0.1.10:2380 \</span><br><span class="line">  --initial-advertise-peer-urls http://10.0.1.10:2380 \</span><br><span class="line">  --initial-cluster-token etcd-cluster \</span><br><span class="line">  --initial-cluster infra1=http://10.0.1.10:2380,infra2=http://10.0.1.11:2380,infra3=http://10.0.1.12:2380 \</span><br><span class="line">  --initial-cluster-state new</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点2和节点3类似，修改IP和名称</span></span><br></pre></td></tr></table></figure>

<h3 id="运维和监控"><a href="#运维和监控" class="headerlink" title="运维和监控"></a>运维和监控</h3><p>健康检查：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查集群健康状态</span></span><br><span class="line">etcdctl endpoint health</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查节点状态</span></span><br><span class="line">etcdctl endpoint status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群成员列表</span></span><br><span class="line">etcdctl member list</span><br></pre></td></tr></table></figure>

<p>备份和恢复：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建快照备份</span></span><br><span class="line">etcdctl snapshot save /backup/etcd-snapshot.db</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从快照恢复</span></span><br><span class="line">etcdctl snapshot restore /backup/etcd-snapshot.db \</span><br><span class="line">  --data-dir /var/lib/etcd-restored \</span><br><span class="line">  --name infra1 \</span><br><span class="line">  --initial-cluster infra1=http://10.0.1.10:2380 \</span><br><span class="line">  --initial-advertise-peer-urls http://10.0.1.10:2380</span><br></pre></td></tr></table></figure>

<p>性能监控：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看存储大小</span></span><br><span class="line">etcdctl check perf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控指标（Prometheus格式）</span></span><br><span class="line">curl http://localhost:2379/metrics</span><br></pre></td></tr></table></figure>

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>集群规模</li>
</ol>
<ul>
<li><strong>生产环境至少3节点</strong>（容忍1个节点故障）</li>
<li>5节点集群可容忍2个节点故障</li>
<li>避免偶数个节点（可能产生脑裂）</li>
</ul>
<ol start="2">
<li>硬件要求</li>
</ol>
<ul>
<li><strong>SSD 存储</strong>：etcd 对 I&#x2F;O 延迟敏感</li>
<li><strong>充足内存</strong>：存储整个数据集在内存中性能最佳</li>
<li><strong>稳定网络</strong>：低延迟网络连接</li>
</ul>
<ol start="3">
<li>安全配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 TLS 加密</span></span><br><span class="line">etcd --cert-file=/path/to/server.crt \</span><br><span class="line">     --key-file=/path/to/server.key \</span><br><span class="line">     --trusted-ca-file=/path/to/ca.crt \</span><br><span class="line">     --client-cert-auth</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>定期维护</li>
</ol>
<ul>
<li>监控存储大小增长</li>
<li>定期创建快照备份</li>
<li>监控 leader 切换频率</li>
</ul>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><strong>etcd 的核心价值：</strong></p>
<ol>
<li><strong>可靠性</strong>：基于 Raft 的强一致性保证</li>
<li><strong>简单性</strong>：清晰的键值 API，易于理解和使用</li>
<li><strong>性能</strong>：高吞吐量和低延迟</li>
<li><strong>生态系统</strong>：云原生生态的事实标准</li>
</ol>
<p><strong>适用场景：</strong></p>
<ul>
<li>✅ 分布式系统协调</li>
<li>✅ 服务发现和注册</li>
<li>✅ 配置管理</li>
<li>✅ 分布式锁</li>
<li>✅ 领导者选举</li>
</ul>
<p><strong>不适用场景：</strong></p>
<ul>
<li>❌ 大数据分析（使用 Hadoop HDFS）</li>
<li>❌ 复杂查询（使用关系数据库）</li>
<li>❌ 海量文件存储（使用对象存储）</li>
</ul>
<p><strong>总结：etcd 是现代分布式系统的”配置大脑”和”协调中心”，特别是在 Kubernetes 生态中扮演着不可或缺的角色。</strong></p>
<h2 id="Fedora-CoreOS"><a href="#Fedora-CoreOS" class="headerlink" title="Fedora CoreOS"></a>Fedora CoreOS</h2><p><strong>Fedora CoreOS</strong> 是一个轻量级的、基于容器的 Linux 发行版，专门为安全、大规模地运行容器化应用而构建。它是 CoreOS Container Linux 和 Fedora Atomic Host 的继承者。</p>
<h3 id="核心定位：-1"><a href="#核心定位：-1" class="headerlink" title="核心定位："></a>核心定位：</h3><ul>
<li><strong>不可变基础设施</strong>：系统在运行时不可修改</li>
<li><strong>自动更新</strong>：安全更新自动应用</li>
<li><strong>容器原生</strong>：一切皆容器</li>
<li><strong>最小化</strong>：只包含运行容器所需的组件</li>
</ul>
<h3 id="CoreOS-的演进历史"><a href="#CoreOS-的演进历史" class="headerlink" title="CoreOS 的演进历史"></a>CoreOS 的演进历史</h3><p>为了理解 Fedora CoreOS，需要了解它的发展历程：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CoreOS Container Linux (2013-2020)</span><br><span class="line">          ↓</span><br><span class="line">Fedora Atomic Host + CoreOS技术</span><br><span class="line">          ↓</span><br><span class="line">Fedora CoreOS (2020-现在)</span><br></pre></td></tr></table></figure>
<p>为什么需要 Fedora CoreOS？</p>
<ul>
<li>CoreOS Container Linux 已停止维护</li>
<li>需要结合 Fedora 的快速创新和 CoreOS 的运维理念</li>
<li>为 Kubernetes 和容器编排提供更好的基础</li>
</ul>
<h3 id="核心特性详解"><a href="#核心特性详解" class="headerlink" title="核心特性详解"></a>核心特性详解</h3><h4 id="不可变基础设施（Immutable-Infrastructure）"><a href="#不可变基础设施（Immutable-Infrastructure）" class="headerlink" title="不可变基础设施（Immutable Infrastructure）"></a>不可变基础设施（Immutable Infrastructure）</h4><p><strong>传统 Linux 发行版：</strong></p>
<ul>
<li>可以随意修改系统文件</li>
<li>包管理器安装软件</li>
<li>配置分散在各处</li>
</ul>
<p><strong>Fedora CoreOS：</strong></p>
<ul>
<li>系统分区是只读的</li>
<li>所有修改通过声明式配置</li>
<li>通过替换整个系统镜像来更新</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 FCOS 中，你不能这样做：</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">yum</span> <span class="string">install</span> <span class="string">nginx</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">systemctl</span> <span class="string">start</span> <span class="string">nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 而是应该：</span></span><br><span class="line"><span class="comment"># 在 Butane 配置中定义 nginx 容器</span></span><br><span class="line"><span class="comment"># 系统自动部署和运行</span></span><br></pre></td></tr></table></figure>

<h4 id="自动原子更新（rpm-ostree）"><a href="#自动原子更新（rpm-ostree）" class="headerlink" title="自动原子更新（rpm-ostree）"></a>自动原子更新（rpm-ostree）</h4><p>Fedora CoreOS 使用 <code>rpm-ostree</code> 进行系统管理：</p>
<p>工作原理：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前系统 (A) → 下载新系统 (B) → 重启切换到 B</span><br><span class="line">     ↓</span><br><span class="line">如果更新失败 → 回滚到 A</span><br></pre></td></tr></table></figure>

<p>实际操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查更新状态</span></span><br><span class="line">rpm-ostree status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动触发更新（通常自动进行）</span></span><br><span class="line">rpm-ostree upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚到上一个版本</span></span><br><span class="line">rpm-ostree rollback</span><br></pre></td></tr></table></figure>

<p>更新过程：</p>
<ol>
<li>下载新的系统镜像（原子性）</li>
<li>重启进入新版本</li>
<li>如果启动失败，自动回滚</li>
<li>保持多个可启动版本</li>
</ol>
<h4 id="声明式系统配置（Ignition）"><a href="#声明式系统配置（Ignition）" class="headerlink" title="声明式系统配置（Ignition）"></a>声明式系统配置（Ignition）</h4><p>Ignition 是在系统第一次启动时执行的配置工具，用于初始配置。</p>
<p>Butane 配置示例（Ignition 的友好格式）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variant:</span> <span class="string">fcos</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">passwd:</span></span><br><span class="line">  <span class="attr">users:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">core</span></span><br><span class="line">      <span class="attr">ssh_authorized_keys:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;ssh-rsa AAAAB3NzaC1yc2E...&quot;</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/etc/hostname</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="number">0644</span></span><br><span class="line">      <span class="attr">contents:</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">&quot;data:,myworker1&quot;</span></span><br><span class="line"><span class="attr">systemd:</span></span><br><span class="line">  <span class="attr">units:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker.service</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>转换 Butane 为 Ignition：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butane --pretty --strict config.bu &gt; config.ign</span><br></pre></td></tr></table></figure>

<h4 id="容器原生设计"><a href="#容器原生设计" class="headerlink" title="容器原生设计"></a>容器原生设计</h4><p>Fedora CoreOS 不包含传统包管理器，所有应用都通过容器运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行应用容器</span></span><br><span class="line">podman run -d --name nginx -p 80:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行系统服务容器</span></span><br><span class="line">systemctl --user start pod-nginx.service</span><br></pre></td></tr></table></figure>

<h3 id="架构组件"><a href="#架构组件" class="headerlink" title="架构组件"></a>架构组件</h3><h4 id="核心组件栈："><a href="#核心组件栈：" class="headerlink" title="核心组件栈："></a>核心组件栈：</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------------+</span><br><span class="line">|                你的容器化应用                    |</span><br><span class="line">|    (Podman, Docker, Kubernetes Pods)           |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">|              Systemd 单元                       |</span><br><span class="line">|              (管理容器服务)                      |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">|            Podman / CRI-O                      |</span><br><span class="line">|             (容器运行时)                         |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">|            Fedora CoreOS                       |</span><br><span class="line">|       (Linux 内核 + 最小化用户空间)               |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">|               硬件/云平台                        |</span><br><span class="line">+------------------------------------------------+</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内置工具：</li>
</ol>
<ul>
<li><strong>Podman</strong>：无守护进程的容器引擎（默认）</li>
<li><strong>Buildah</strong>：构建 OCI 镜像</li>
<li><strong>Skopeo</strong>：操作容器镜像仓库</li>
<li><strong>rpm-ostree</strong>：系统包管理</li>
<li><strong>Ignition</strong>：首次启动配置</li>
<li><strong>Afterburn</strong>：云平台元数据收集</li>
</ul>
<h3 id="安装和部署-1"><a href="#安装和部署-1" class="headerlink" title="安装和部署"></a>安装和部署</h3><ol>
<li>下载 Fedora CoreOS</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看最新版本</span></span><br><span class="line">curl -s https://builds.coreos.fedoraproject.org/streams/stable.json | jq <span class="string">&#x27;.architectures.x86_64.artifacts.metal.release&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载最新稳定版</span></span><br><span class="line">wget https://builds.coreos.fedoraproject.org/prod/streams/stable/builds/35.20220116.3.0/x86_64/fedora-coreos-35.20220116.3.0-metal.x86_64.raw.xz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 Ignition 配置文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.bu</span></span><br><span class="line"><span class="attr">variant:</span> <span class="string">fcos</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">passwd:</span></span><br><span class="line">  <span class="attr">users:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">core</span></span><br><span class="line">      <span class="attr">ssh_authorized_keys:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;ssh-rsa AAAAB3NzaC1yc2E...&quot;</span></span><br><span class="line">      <span class="attr">groups:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">wheel</span></span><br><span class="line">      <span class="attr">home_dir:</span> <span class="string">/home/core</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/etc/hostname</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="number">0644</span></span><br><span class="line">      <span class="attr">contents:</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">&quot;data:,my-fcos-node&quot;</span></span><br></pre></td></tr></table></figure>

<p>转换为 Ignition：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butane config.bu &gt; config.ign</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装到物理机</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 coreos-installer</span></span><br><span class="line"><span class="built_in">sudo</span> coreos-installer install /dev/sda \</span><br><span class="line">  --ignition-file config.ign \</span><br><span class="line">  --platform metal</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>云平台部署</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AWS</span></span><br><span class="line">coreos-installer download -s stable -p aws</span><br><span class="line"><span class="comment"># 使用 user-data 传递 Ignition 配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenStack</span></span><br><span class="line">coreos-installer download -s stable -p openstack</span><br></pre></td></tr></table></figure>

<h3 id="实际使用场景"><a href="#实际使用场景" class="headerlink" title="实际使用场景"></a>实际使用场景</h3><p>场景 1：Kubernetes 节点</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubernetes-node.bu</span></span><br><span class="line"><span class="attr">variant:</span> <span class="string">fcos</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">passwd:</span></span><br><span class="line">  <span class="attr">users:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">core</span></span><br><span class="line">      <span class="attr">ssh_authorized_keys:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;ssh-rsa AAAAB3NzaC1yc2E...&quot;</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/etc/kubernetes/kubelet.conf</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="number">0644</span></span><br><span class="line">      <span class="attr">contents:</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">&quot;data:,...&quot;</span></span><br><span class="line"><span class="attr">systemd:</span></span><br><span class="line">  <span class="attr">units:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubelet.service</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        [Unit]</span></span><br><span class="line"><span class="string">        Description=Kubernetes Kubelet</span></span><br><span class="line"><span class="string">        ...</span></span><br></pre></td></tr></table></figure>

<p>场景 2：容器化应用服务器</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app-server.bu</span></span><br><span class="line"><span class="attr">variant:</span> <span class="string">fcos</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">passwd:</span></span><br><span class="line">  <span class="attr">users:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">core</span></span><br><span class="line">      <span class="attr">ssh_authorized_keys:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;ssh-rsa AAAAB3NzaC1yc2E...&quot;</span></span><br><span class="line"><span class="attr">systemd:</span></span><br><span class="line">  <span class="attr">units:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myapp.service</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">contents:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        [Unit]</span></span><br><span class="line"><span class="string">        Description=My Application</span></span><br><span class="line"><span class="string">        After=network-online.target</span></span><br><span class="line"><span class="string"></span>        </span><br><span class="line">        [<span class="string">Service</span>]</span><br><span class="line">        <span class="string">Type=simple</span></span><br><span class="line">        <span class="string">ExecStart=podman</span> <span class="string">run</span> <span class="string">--rm</span> <span class="string">--name</span> <span class="string">myapp</span> <span class="string">-p</span> <span class="number">8080</span><span class="string">:8080</span> <span class="string">myregistry/app:latest</span></span><br><span class="line">        <span class="string">Restart=always</span></span><br><span class="line">        </span><br><span class="line">        [<span class="string">Install</span>]</span><br><span class="line">        <span class="string">WantedBy=multi-user.target</span></span><br></pre></td></tr></table></figure>

<p>场景 3：边缘计算设备</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># edge-device.bu</span></span><br><span class="line"><span class="attr">variant:</span> <span class="string">fcos</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">passwd:</span></span><br><span class="line">  <span class="attr">users:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">core</span></span><br><span class="line">      <span class="attr">ssh_authorized_keys:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;ssh-rsa AAAAB3NzaC1yc2E...&quot;</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/etc/edge-config.conf</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="number">0644</span></span><br><span class="line">      <span class="attr">contents:</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">&quot;data:,...&quot;</span></span><br><span class="line">  <span class="attr">disks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">device:</span> <span class="string">/dev/sdb</span></span><br><span class="line">      <span class="attr">wipe_table:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">partitions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">number:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">size_mib:</span> <span class="number">0</span>  <span class="comment"># 使用全部空间</span></span><br></pre></td></tr></table></figure>

<h3 id="与传统-Linux-发行版的对比"><a href="#与传统-Linux-发行版的对比" class="headerlink" title="与传统 Linux 发行版的对比"></a>与传统 Linux 发行版的对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>传统 Linux (Ubuntu&#x2F;CentOS)</strong></th>
<th><strong>Fedora CoreOS</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>更新方式</strong></td>
<td>包级别更新 (<code>apt/yum</code>)</td>
<td>系统镜像更新 (<code>rpm-ostree</code>)</td>
</tr>
<tr>
<td><strong>系统修改</strong></td>
<td>可任意修改</td>
<td>只读根文件系统</td>
</tr>
<tr>
<td><strong>应用部署</strong></td>
<td>包管理器或源码编译</td>
<td>容器化部署</td>
</tr>
<tr>
<td><strong>配置管理</strong></td>
<td>Ansible&#x2F;Puppet&#x2F;Chef</td>
<td>Ignition + Butane</td>
</tr>
<tr>
<td><strong>目标场景</strong></td>
<td>通用用途</td>
<td>容器编排平台节点</td>
</tr>
<tr>
<td><strong>安全模型</strong></td>
<td>相对宽松</td>
<td>最小权限原则</td>
</tr>
</tbody></table>
<h3 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h3><ol>
<li>系统状态检查</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统版本</span></span><br><span class="line"><span class="built_in">cat</span> /etc/os-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查更新状态</span></span><br><span class="line">rpm-ostree status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器状态</span></span><br><span class="line">podman ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统服务</span></span><br><span class="line">systemctl status</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>故障排查</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动日志</span></span><br><span class="line">journalctl -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Ignition 执行日志</span></span><br><span class="line">journalctl -u ignition-*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查容器日志</span></span><br><span class="line">podman logs &lt;container&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>临时调试（开发模式）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入开发模式（可写根文件系统）</span></span><br><span class="line">rpm-ostree usroverlay</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装调试工具（临时）</span></span><br><span class="line">rpm-ostree install htop net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启后恢复不可变状态</span></span><br></pre></td></tr></table></figure>

<h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>配置管理</li>
</ol>
<ul>
<li>使用 Butane 生成 Ignition 配置</li>
<li>版本控制所有配置文件</li>
<li>为不同环境（dev&#x2F;staging&#x2F;prod）创建不同配置</li>
</ul>
<ol start="2">
<li>安全实践</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安全配置示例</span></span><br><span class="line"><span class="attr">variant:</span> <span class="string">fcos</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">passwd:</span></span><br><span class="line">  <span class="attr">users:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">core</span></span><br><span class="line">      <span class="attr">ssh_authorized_keys:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;your-public-key&quot;</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">files:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/etc/ssh/sshd_config</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="number">0600</span></span><br><span class="line">      <span class="attr">contents:</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">&quot;data:,...&quot;</span></span><br><span class="line"><span class="attr">kernel_arguments:</span></span><br><span class="line">  <span class="attr">should_exist:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;mitigations=auto&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更新策略</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置自动更新</span></span><br><span class="line">systemctl <span class="built_in">enable</span> rpm-ostreed-automatic.timer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置更新窗口</span></span><br><span class="line"><span class="built_in">cat</span> /etc/rpm-ostreed.conf</span><br><span class="line"><span class="comment"># [Daemon]</span></span><br><span class="line"><span class="comment"># AutomaticUpdatePolicy=stage</span></span><br><span class="line"><span class="comment"># IdleExitTimeout=30m</span></span><br></pre></td></tr></table></figure>

<h3 id="与相关技术的比较"><a href="#与相关技术的比较" class="headerlink" title="与相关技术的比较"></a>与相关技术的比较</h3><p><strong>Fedora CoreOS vs Ubuntu</strong></p>
<ul>
<li>Ubuntu：通用目的，适合各种工作负载</li>
<li>FCOS：专门为容器优化，安全性更高</li>
</ul>
<p><strong>Fedora CoreOS vs RHEL</strong></p>
<ul>
<li>RHEL：企业级支持，传统应用</li>
<li>FCOS：云原生，自动更新，不可变基础设施</li>
</ul>
<p><strong>Fedora CoreOS vs Flatcar Linux</strong></p>
<ul>
<li>Flatcar：更接近原始 CoreOS</li>
<li>FCOS：基于 Fedora，更新更频繁</li>
</ul>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><strong>Fedora CoreOS 的核心价值：</strong></p>
<ol>
<li><strong>安全性</strong>：最小化攻击面，自动安全更新</li>
<li><strong>可靠性</strong>：原子更新，自动回滚</li>
<li><strong>一致性</strong>：不可变基础设施，消除配置漂移</li>
<li><strong>运维友好</strong>：声明式配置，减少手动操作</li>
</ol>
<p><strong>适用场景：</strong></p>
<ul>
<li>✅ Kubernetes 集群节点</li>
<li>✅ 容器化应用平台</li>
<li>✅ 边缘计算设备</li>
<li>✅ 需要高安全性的工作负载</li>
<li>✅ 大规模容器部署</li>
</ul>
<p><strong>不适用场景：</strong></p>
<ul>
<li>❌ 需要频繁修改系统配置的传统应用</li>
<li>❌ 开发环境（除非完全接受容器化）</li>
<li>❌ 需要特定版本系统库的应用</li>
</ul>
<p><strong>总结：Fedora CoreOS 是专为云原生时代设计的操作系统，它通过不可变基础设施和自动更新，为运行容器化工作负载提供了安全、可靠、一致的基础平台。</strong></p>
<h2 id="Podman"><a href="#Podman" class="headerlink" title="Podman"></a>Podman</h2><p><strong>Podman</strong>（Pod Manager）是一个开源的、无守护进程的 Linux 容器引擎，用于开发、管理和运行 OCI（Open Container Initiative）容器。被看作是 Docker 的下一代替代品。</p>
<h3 id="核心定位：-2"><a href="#核心定位：-2" class="headerlink" title="核心定位："></a>核心定位：</h3><ul>
<li><strong>无守护进程架构</strong>：不需要长期运行的后台服务</li>
<li><strong>Rootless 容器</strong>：普通用户可直接运行容器</li>
<li><strong>Docker 兼容</strong>：大部分命令与 Docker 兼容</li>
<li><strong>Pod 支持</strong>：原生支持 Kubernetes 风格的 Pod</li>
</ul>
<h3 id="Podman-与-Docker-的架构对比"><a href="#Podman-与-Docker-的架构对比" class="headerlink" title="Podman 与 Docker 的架构对比"></a>Podman 与 Docker 的架构对比</h3><p><strong>Docker 架构（有守护进程）：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户命令 → Docker CLI → Docker Daemon → 容器</span><br><span class="line">                      ↓</span><br><span class="line">              需要 root 权限，单点故障</span><br></pre></td></tr></table></figure>

<p><strong>Podman 架构（无守护进程）：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户命令 → Podman → 直接与 OCI 运行时通信 → 容器</span><br><span class="line">            ↓</span><br><span class="line">    普通用户也可直接运行</span><br></pre></td></tr></table></figure>

<h3 id="核心特性详解-1"><a href="#核心特性详解-1" class="headerlink" title="核心特性详解"></a>核心特性详解</h3><h4 id="无守护进程架构（Daemonless）"><a href="#无守护进程架构（Daemonless）" class="headerlink" title="无守护进程架构（Daemonless）"></a>无守护进程架构（Daemonless）</h4><p>这是 Podman 最显著的特点：</p>
<p>传统 Docker：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要先启动守护进程</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># CLI 与守护进程通信</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>Podman：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接执行，无需守护进程</span></span><br><span class="line">podman run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通用户也可运行</span></span><br><span class="line">podman run --user 1000:1000 alpine</span><br></pre></td></tr></table></figure>

<p><strong>优势：</strong></p>
<ul>
<li>更安全：减少攻击面</li>
<li>更稳定：无单点故障</li>
<li>更简单：不需要管理守护进程状态</li>
</ul>
<h4 id="Rootless-容器"><a href="#Rootless-容器" class="headerlink" title="Rootless 容器"></a>Rootless 容器</h4><p>普通用户无需 sudo 即可运行容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以当前用户身份运行容器</span></span><br><span class="line"><span class="built_in">whoami</span>  <span class="comment"># 输出: myuser</span></span><br><span class="line">podman run -it alpine sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器内查看用户</span></span><br><span class="line"><span class="built_in">id</span>  <span class="comment"># 显示的是 myuser 的 UID，不是 root</span></span><br></pre></td></tr></table></figure>

<p>Rootless 工作原理：</p>
<ul>
<li>使用用户命名空间（user namespace）</li>
<li>容器内的 root 映射到宿主机的非特权用户</li>
<li>通过 <code>subuid</code>&#x2F;<code>subgid</code> 分配 UID&#x2F;GID 范围</li>
</ul>
<p>配置 Rootless：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查用户命名空间支持</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/user/max_user_namespaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 subuid/subgid（通常已自动配置）</span></span><br><span class="line"><span class="built_in">cat</span> /etc/subuid</span><br><span class="line"><span class="comment"># myuser:100000:65536</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> /etc/subgid  </span><br><span class="line"><span class="comment"># myuser:100000:65536</span></span><br></pre></td></tr></table></figure>

<h4 id="Pod-支持"><a href="#Pod-支持" class="headerlink" title="Pod 支持"></a>Pod 支持</h4><p>Podman 原生支持 Kubernetes 风格的 Pod（一组共享资源的容器）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Pod</span></span><br><span class="line">podman pod create --name mypod -p 8080:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向 Pod 中添加容器</span></span><br><span class="line">podman run -d --pod mypod nginx:alpine</span><br><span class="line">podman run -d --pod mypod redis:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod</span></span><br><span class="line">podman pod <span class="built_in">ls</span></span><br><span class="line">podman pod inspect mypod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Pod 中执行命令</span></span><br><span class="line">podman <span class="built_in">exec</span> -it mypod-nginx sh</span><br></pre></td></tr></table></figure>

<p>Pod 配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pod.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 YAML 创建 Pod</span></span><br><span class="line">podman play kube pod.yaml</span><br></pre></td></tr></table></figure>

<h4 id="Systemd-集成"><a href="#Systemd-集成" class="headerlink" title="Systemd 集成"></a>Systemd 集成</h4><p>Podman 可以生成 systemd 服务文件，实现容器自启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">podman run -d --name myapp -p 8080:80 nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 systemd 服务文件</span></span><br><span class="line">podman generate systemd --name myapp --files --new</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出: container-myapp.service</span></span><br><span class="line"><span class="comment"># 启用并启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now container-myapp.service</span><br></pre></td></tr></table></figure>

<p>生成的 service 文件示例：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Podman container-myapp.service</span><br><span class="line"><span class="attr">Documentation</span>=man:podman-generate-systemd(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/podman start myapp</span><br><span class="line"><span class="attr">ExecStop</span>=/usr/bin/podman stop -t <span class="number">10</span> myapp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="基本使用命令"><a href="#基本使用命令" class="headerlink" title="基本使用命令"></a>基本使用命令</h3><p><strong>容器管理（与 Docker 高度兼容）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">podman run -it --<span class="built_in">rm</span> alpine:latest sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">podman run -d --name web -p 8080:80 nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">podman ps</span><br><span class="line">podman ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">podman <span class="built_in">exec</span> -it web bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">podman logs web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止和删除</span></span><br><span class="line">podman stop web</span><br><span class="line">podman <span class="built_in">rm</span> web</span><br></pre></td></tr></table></figure>

<p><strong>镜像管理：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">podman pull ubuntu:20.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出镜像</span></span><br><span class="line">podman images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">podman build -t myapp:latest .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送镜像</span></span><br><span class="line">podman push myapp:latest myregistry.com/myapp:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索镜像</span></span><br><span class="line">podman search nginx</span><br></pre></td></tr></table></figure>

<p><strong>网络管理：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建网络</span></span><br><span class="line">podman network create mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义网络运行容器</span></span><br><span class="line">podman run -d --name app --network mynet myapp:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">podman network <span class="built_in">ls</span></span><br><span class="line">podman network inspect mynet</span><br></pre></td></tr></table></figure>

<h3 id="高级功能-1"><a href="#高级功能-1" class="headerlink" title="高级功能"></a>高级功能</h3><h4 id="Podman-Machine（macOS-Windows）"><a href="#Podman-Machine（macOS-Windows）" class="headerlink" title="Podman Machine（macOS&#x2F;Windows）"></a>Podman Machine（macOS&#x2F;Windows）</h4><p>在非 Linux 系统上运行 Podman：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Linux 虚拟机</span></span><br><span class="line">podman machine init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动虚拟机</span></span><br><span class="line">podman machine start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">podman machine list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在虚拟机中运行容器</span></span><br><span class="line">podman run hello-world</span><br></pre></td></tr></table></figure>

<h4 id="容器健康检查"><a href="#容器健康检查" class="headerlink" title="容器健康检查"></a>容器健康检查</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行带健康检查的容器</span></span><br><span class="line">podman run -d \</span><br><span class="line">  --name postgres \</span><br><span class="line">  --health-cmd=<span class="string">&quot;pg_isready -U postgres&quot;</span> \</span><br><span class="line">  --health-interval=30s \</span><br><span class="line">  --health-timeout=10s \</span><br><span class="line">  --health-retries=3 \</span><br><span class="line">  postgres:13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查健康状态</span></span><br><span class="line">podman healthcheck run postgres</span><br></pre></td></tr></table></figure>

<h4 id="容器资源限制"><a href="#容器资源限制" class="headerlink" title="容器资源限制"></a>容器资源限制</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存和 CPU 限制</span></span><br><span class="line">podman run -d \</span><br><span class="line">  --name limited-container \</span><br><span class="line">  --memory=512m \</span><br><span class="line">  --cpus=1.5 \</span><br><span class="line">  --cpu-shares=1024 \</span><br><span class="line">  nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看资源使用</span></span><br><span class="line">podman stats</span><br></pre></td></tr></table></figure>

<h4 id="容器安全特性"><a href="#容器安全特性" class="headerlink" title="容器安全特性"></a>容器安全特性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用安全选项运行容器</span></span><br><span class="line">podman run -d \</span><br><span class="line">  --name secure-app \</span><br><span class="line">  --security-opt=no-new-privileges \</span><br><span class="line">  --cap-drop=ALL \</span><br><span class="line">  --cap-add=NET_BIND_SERVICE \</span><br><span class="line">  nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 SELinux 标签</span></span><br><span class="line">podman run --security-opt label=<span class="built_in">type</span>:container_t myapp</span><br></pre></td></tr></table></figure>

<h3 id="实际应用场景-2"><a href="#实际应用场景-2" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p>场景 1：开发环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发人员无需 sudo 权限</span></span><br><span class="line">podman run -d --name db -p 5432:5432 postgres:13</span><br><span class="line">podman run -d --name redis -p 6379:6379 redis:alpine</span><br><span class="line">podman run -d --name app -p 3000:3000 \</span><br><span class="line">  --<span class="built_in">env</span> DATABASE_URL=postgresql://user:pass@localhost:5432/db \</span><br><span class="line">  myapp:dev</span><br></pre></td></tr></table></figure>

<p>场景 2：CI&#x2F;CD 流水线</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">fedora:latest</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dnf</span> <span class="string">install</span> <span class="string">-y</span> <span class="string">podman</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">podman</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">myapp</span> <span class="string">.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">podman</span> <span class="string">run</span> <span class="string">myapp</span> <span class="string">npm</span> <span class="string">test</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">podman</span> <span class="string">push</span> <span class="string">myapp</span> <span class="string">my-registry.com/myapp:$CI_COMMIT_SHA</span></span><br></pre></td></tr></table></figure>

<p>场景 3：生产环境部署</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># deploy.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取最新镜像</span></span><br><span class="line">podman pull my-registry.com/myapp:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止旧容器</span></span><br><span class="line">podman stop myapp || <span class="literal">true</span></span><br><span class="line">podman <span class="built_in">rm</span> myapp || <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行新容器</span></span><br><span class="line">podman run -d \</span><br><span class="line">  --name myapp \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --security-opt=no-new-privileges \</span><br><span class="line">  --memory=1g \</span><br><span class="line">  --cpus=2 \</span><br><span class="line">  -p 80:8080 \</span><br><span class="line">  my-registry.com/myapp:latest</span><br></pre></td></tr></table></figure>

<h3 id="与-Docker-的兼容性"><a href="#与-Docker-的兼容性" class="headerlink" title="与 Docker 的兼容性"></a>与 Docker 的兼容性</h3><p><strong>命令兼容性：</strong><br>大部分 Docker 命令在 Podman 中直接可用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这些命令在两者中都能工作</span></span><br><span class="line">docker/podman run</span><br><span class="line">docker/podman build  </span><br><span class="line">docker/podman ps</span><br><span class="line">docker/podman images</span><br><span class="line">docker/podman <span class="built_in">exec</span></span><br></pre></td></tr></table></figure>

<p><strong>别名设置：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/.bashrc 中添加</span></span><br><span class="line"><span class="built_in">alias</span> docker=podman</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 docket 项目提供完全兼容</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install podman-docker</span><br></pre></td></tr></table></figure>

<p><strong>不兼容的特性：</strong> </p>
<ul>
<li>Docker Swarm（使用 Kubernetes 替代）</li>
<li>某些高级网络特性</li>
<li>部分商业版功能</li>
</ul>
<h3 id="生态系统工具"><a href="#生态系统工具" class="headerlink" title="生态系统工具"></a>生态系统工具</h3><p>Podman 有一系列配套工具：</p>
<h4 id="Buildah"><a href="#Buildah" class="headerlink" title="Buildah"></a>Buildah</h4><p>专门用于构建 OCI 镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Buildah 构建镜像</span></span><br><span class="line">buildah from ubuntu:20.04</span><br><span class="line">buildah run working-container apt update</span><br><span class="line">buildah run working-container apt install -y nginx</span><br><span class="line">buildah commit working-container my-nginx</span><br></pre></td></tr></table></figure>

<h4 id="Skopeo"><a href="#Skopeo" class="headerlink" title="Skopeo"></a>Skopeo</h4><p>镜像仓库操作工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制镜像</span></span><br><span class="line">skopeo copy docker://nginx:alpine docker://localhost:5000/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查镜像信息</span></span><br><span class="line">skopeo inspect docker://nginx:alpine</span><br></pre></td></tr></table></figure>

<h4 id="CRI-O"><a href="#CRI-O" class="headerlink" title="CRI-O"></a>CRI-O</h4><p>Kubernetes 容器运行时，与 Podman 共享技术栈。</p>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><table>
<thead>
<tr>
<th>操作</th>
<th>Docker</th>
<th>Podman</th>
</tr>
</thead>
<tbody><tr>
<td><strong>容器启动时间</strong></td>
<td>快</td>
<td>相当</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>较高（有守护进程）</td>
<td>较低</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>需要 root</td>
<td>Rootless 支持</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>依赖守护进程</td>
<td>更稳定</td>
</tr>
</tbody></table>
<h3 id="迁移指南"><a href="#迁移指南" class="headerlink" title="迁移指南"></a>迁移指南</h3><h4 id="从-Docker-迁移到-Podman："><a href="#从-Docker-迁移到-Podman：" class="headerlink" title="从 Docker 迁移到 Podman："></a>从 Docker 迁移到 Podman：</h4><ol>
<li>安装 Podman：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> apt install podman</span><br><span class="line"></span><br><span class="line"><span class="comment"># RHEL/CentOS/Fedora</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install podman</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>测试兼容性：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置别名测试</span></span><br><span class="line"><span class="built_in">alias</span> docker=podman</span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置 Rootless：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用用户命名空间</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;user.max_user_namespaces=28633&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/sysctl.conf</span><br><span class="line"><span class="built_in">sudo</span> sysctl -p</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>更新脚本：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将脚本中的 docker 改为 podman</span></span><br><span class="line">sed -i <span class="string">&#x27;s/docker/podman/g&#x27;</span> deploy.sh</span><br></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p><strong>Podman 的核心优势：</strong></p>
<ol>
<li><strong>安全性</strong>：Rootless 容器，无守护进程</li>
<li><strong>轻量级</strong>：不需要长期运行的服务</li>
<li><strong>兼容性</strong>：大部分 Docker 命令直接可用</li>
<li><strong>现代性</strong>：原生 Pod 支持，Kubernetes 友好</li>
<li><strong>灵活性</strong>：与 systemd 深度集成</li>
</ol>
<p><strong>适用场景：</strong></p>
<ul>
<li>✅ 开发环境（无需 sudo）</li>
<li>✅ 安全敏感的环境</li>
<li>✅ Kubernetes 相关工作流</li>
<li>✅ CI&#x2F;CD 流水线</li>
<li>✅ 边缘计算和设备</li>
</ul>
<p><strong>何时选择 Docker：</strong></p>
<ul>
<li>需要 Docker Swarm</li>
<li>依赖特定的 Docker 商业功能</li>
<li>已有复杂的 Docker 生态系统</li>
</ul>
<p><strong>总结：Podman 是容器技术的现代化演进，它解决了 Docker 在安全性和架构上的一些根本性问题，特别适合云原生和安全敏感的环境。</strong></p>
<h2 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h2><h3 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h3><h4 id="如何批量清理临时镜像文件？"><a href="#如何批量清理临时镜像文件？" class="headerlink" title="如何批量清理临时镜像文件？"></a>如何批量清理临时镜像文件？</h4><p>答：可以使用 <code>docker image prune</code> 命令。</p>
<h4 id="如何查看镜像支持的环境变量？"><a href="#如何查看镜像支持的环境变量？" class="headerlink" title="如何查看镜像支持的环境变量？"></a>如何查看镜像支持的环境变量？</h4><p>答：可以使用 <code>docker run IMAGE env</code> 命令。</p>
<h4 id="本地的镜像文件都存放在哪里？"><a href="#本地的镜像文件都存放在哪里？" class="headerlink" title="本地的镜像文件都存放在哪里？"></a>本地的镜像文件都存放在哪里？</h4><p>答：与 Docker 相关的本地资源默认存放在 <code>/var/lib/docker/</code> 目录下，以 <code>overlay2</code> 文件系统为例，其中 <code>containers</code> 目录存放容器信息，<code>image</code> 目录存放镜像信息，<code>overlay2</code> 目录下存放具体的镜像层文件。</p>
<h4 id="构建-Docker-镜像应该遵循哪些原则？"><a href="#构建-Docker-镜像应该遵循哪些原则？" class="headerlink" title="构建 Docker 镜像应该遵循哪些原则？"></a>构建 Docker 镜像应该遵循哪些原则？</h4><p>答：整体原则上，尽量保持镜像功能的明确和内容的精简，要点包括</p>
<ul>
<li><p>尽量选取满足需求但较小的基础系统镜像，例如大部分时候可以选择 <code>alpine</code> 镜像，仅有不足六兆大小；</p>
</li>
<li><p>清理编译生成文件、安装包的缓存等临时文件；</p>
</li>
<li><p>安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖；</p>
</li>
<li><p>从安全角度考虑，应用要尽量使用系统的库和依赖；</p>
</li>
<li><p>如果安装应用时候需要配置一些特殊的环境变量，在安装后要还原不需要保持的变量值；</p>
</li>
<li><p>使用 Dockerfile 创建镜像时候要添加 .dockerignore 文件或使用干净的工作目录。</p>
</li>
</ul>
<!-- 更多内容请查看 [Dockerfile 最佳实践](../best_practices.md) -->

<h4 id="碰到网络问题，无法-pull-镜像，命令行指定-http-proxy-无效？"><a href="#碰到网络问题，无法-pull-镜像，命令行指定-http-proxy-无效？" class="headerlink" title="碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？"></a>碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？</h4><p>答：在 Docker 配置文件中添加 <code>export http_proxy=&quot;http://&lt;PROXY_HOST&gt;:&lt;PROXY_PORT&gt;&quot;</code>，之后重启 Docker 服务即可。</p>
<h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><h4 id="容器退出后，通过-docker-container-ls-命令查看不到，数据会丢失么？"><a href="#容器退出后，通过-docker-container-ls-命令查看不到，数据会丢失么？" class="headerlink" title="容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？"></a>容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？</h4><p>答：容器退出后会处于终止（exited）状态，此时可以通过 <code>docker container ls -a</code> 查看。其中的数据也不会丢失，还可以通过 <code>docker start</code> 命令来启动它。只有删除掉容器才会清除所有数据。</p>
<h4 id="如何停止所有正在运行的容器？"><a href="#如何停止所有正在运行的容器？" class="headerlink" title="如何停止所有正在运行的容器？"></a>如何停止所有正在运行的容器？</h4><p>答：可以使用 <code>docker stop $(docker container ls -q)</code> 命令。</p>
<h4 id="如何批量清理已经停止的容器？"><a href="#如何批量清理已经停止的容器？" class="headerlink" title="如何批量清理已经停止的容器？"></a>如何批量清理已经停止的容器？</h4><p>答：可以使用 <code>docker container prune</code> 命令。</p>
<h4 id="如何获取某个容器的-PID-信息？"><a href="#如何获取某个容器的-PID-信息？" class="headerlink" title="如何获取某个容器的 PID 信息？"></a>如何获取某个容器的 PID 信息？</h4><p>答：可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27;</span> &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>

<h3 id="如何获取某个容器的-IP-地址？"><a href="#如何获取某个容器的-IP-地址？" class="headerlink" title="如何获取某个容器的 IP 地址？"></a>如何获取某个容器的 IP 地址？</h3><p>答：可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>

<h4 id="如何给容器指定一个固定-IP-地址，而不是每次重启容器-IP-地址都会变？"><a href="#如何给容器指定一个固定-IP-地址，而不是每次重启容器-IP-地址都会变？" class="headerlink" title="如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？"></a>如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？</h4><p>答：使用以下命令启动容器可以使容器 IP 固定不变</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge --subnet 172.25.0.0/16 my-net</span><br><span class="line"></span><br><span class="line">$ docker run --network=my-net --ip=172.25.3.3 -itd --name=my-container busybox</span><br></pre></td></tr></table></figure>

<h4 id="如何临时退出一个正在交互的容器的终端，而不终止它？"><a href="#如何临时退出一个正在交互的容器的终端，而不终止它？" class="headerlink" title="如何临时退出一个正在交互的容器的终端，而不终止它？"></a>如何临时退出一个正在交互的容器的终端，而不终止它？</h4><p>答：按 <code>Ctrl-p Ctrl-q</code>。如果按 <code>Ctrl-c</code> 往往会让容器内应用进程终止，进而会终止容器。</p>
<h4 id="使用-docker-port-命令映射容器的端口时，系统报错“Error-No-public-port-‘80’-published-for-xxx”？"><a href="#使用-docker-port-命令映射容器的端口时，系统报错“Error-No-public-port-‘80’-published-for-xxx”？" class="headerlink" title="使用 docker port 命令映射容器的端口时，系统报错“Error: No public port ‘80’ published for xxx”？"></a>使用 <code>docker port</code> 命令映射容器的端口时，系统报错“Error: No public port ‘80’ published for xxx”？</h4><p>答：</p>
<ul>
<li><p>创建镜像时 <code>Dockerfile</code> 要通过 <code>EXPOSE</code> 指定正确的开放端口；</p>
</li>
<li><p>容器启动时指定 <code>PublishAllPort = true</code>。</p>
</li>
</ul>
<h4 id="可以在一个容器中同时运行多个应用进程么？"><a href="#可以在一个容器中同时运行多个应用进程么？" class="headerlink" title="可以在一个容器中同时运行多个应用进程么？"></a>可以在一个容器中同时运行多个应用进程么？</h4><p>答：一般并不推荐在同一个容器内运行多个应用进程。如果有类似需求，可以通过一些额外的进程管理机制，比如 <code>supervisord</code> 来管理所运行的进程。可以参考 <a target="_blank" rel="noopener" href="https://docs.docker.com/config/containers/multi-service_container/">https://docs.docker.com/config/containers/multi-service_container/</a> 。</p>
<h4 id="如何控制容器占用系统资源（CPU、内存）的份额？"><a href="#如何控制容器占用系统资源（CPU、内存）的份额？" class="headerlink" title="如何控制容器占用系统资源（CPU、内存）的份额？"></a>如何控制容器占用系统资源（CPU、内存）的份额？</h4><p>答：在使用 <code>docker create</code> 命令创建容器或使用 <code>docker run</code> 创建并启动容器的时候，可以使用 -c|–cpu-shares[&#x3D;0] 参数来调整容器使用 CPU 的权重；使用 -m|–memory[&#x3D;MEMORY] 参数来调整容器使用内存的大小。</p>
<h3 id="仓库相关"><a href="#仓库相关" class="headerlink" title="仓库相关"></a>仓库相关</h3><h4 id="仓库（Repository）、注册服务器（Registry）、注册索引（Index）-有何关系？"><a href="#仓库（Repository）、注册服务器（Registry）、注册索引（Index）-有何关系？" class="headerlink" title="仓库（Repository）、注册服务器（Registry）、注册索引（Index） 有何关系？"></a>仓库（Repository）、注册服务器（Registry）、注册索引（Index） 有何关系？</h4><p>首先，仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像。</p>
<p>注册服务器是存放实际的镜像文件的地方。注册索引则负责维护用户的账号、权限、搜索、标签等的管理。因此，注册服务器利用注册索引来实现认证等管理。</p>
<h3 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h3><h4 id="Docker-的配置文件放在哪里，如何修改配置？"><a href="#Docker-的配置文件放在哪里，如何修改配置？" class="headerlink" title="Docker 的配置文件放在哪里，如何修改配置？"></a>Docker 的配置文件放在哪里，如何修改配置？</h4><p>答：使用 <code>systemd</code> 的系统（如 Ubuntu 16.04、Centos 等）的配置文件在 <code>/etc/docker/daemon.json</code>。</p>
<h3 id="如何更改-Docker-的默认存储位置？"><a href="#如何更改-Docker-的默认存储位置？" class="headerlink" title="如何更改 Docker 的默认存储位置？"></a>如何更改 Docker 的默认存储位置？</h3><p>答：Docker 的默认存储位置是 <code>/var/lib/docker</code>，如果希望将 Docker 的本地文件存储到其他分区，可以使用 Linux 软连接的方式来完成，或者在启动 daemon 时通过 <code>-g</code> 参数指定，或者修改配置文件 <code>/etc/docker/daemon.json</code> 的 “data-root” 项 。可以使用 <code>docker system info | grep &quot;Root Dir&quot;</code> 查看当前使用的存储位置。</p>
<p>例如，如下操作将默认存储位置迁移到 &#x2F;storage&#x2F;docker。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@s26 ~]# <span class="built_in">df</span> -h</span><br><span class="line">Filesystem                    Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/VolGroup-lv_root   50G  5.3G   42G  12% /</span><br><span class="line">tmpfs                          48G  228K   48G   1% /dev/shm</span><br><span class="line">/dev/sda1                     485M   40M  420M   9% /boot</span><br><span class="line">/dev/mapper/VolGroup-lv_home  222G  188M  210G   1% /home</span><br><span class="line">/dev/sdb2                     2.7T  323G  2.3T  13% /storage</span><br><span class="line">[root@s26 ~]# service docker stop</span><br><span class="line">[root@s26 ~]# <span class="built_in">cd</span> /var/lib/</span><br><span class="line">[root@s26 lib]# <span class="built_in">mv</span> docker /storage/</span><br><span class="line">[root@s26 lib]# <span class="built_in">ln</span> -s /storage/docker/ docker</span><br><span class="line">[root@s26 lib]# <span class="built_in">ls</span> -la docker</span><br><span class="line">lrwxrwxrwx. 1 root root 15 11月 17 13:43 docker -&gt; /storage/docker</span><br><span class="line">[root@s26 lib]# service docker start</span><br></pre></td></tr></table></figure>

<h4 id="使用内存和-swap-限制启动容器时候报警告：”WARNING-Your-kernel-does-not-support-cgroup-swap-limit-WARNING-Your-kernel-does-not-support-swap-limit-capabilities-Limitation-discarded-”？"><a href="#使用内存和-swap-限制启动容器时候报警告：”WARNING-Your-kernel-does-not-support-cgroup-swap-limit-WARNING-Your-kernel-does-not-support-swap-limit-capabilities-Limitation-discarded-”？" class="headerlink" title="使用内存和 swap 限制启动容器时候报警告：”WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.”？"></a>使用内存和 swap 限制启动容器时候报警告：”WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.”？</h4><p>答：这是因为系统默认没有开启对内存和 swap 使用的统计功能，引入该功能会带来性能的下降。要开启该功能，可以采取如下操作：</p>
<ul>
<li><p>编辑 <code>/etc/default/grub</code> 文件（Ubuntu 系统为例），配置 <code>GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;</code></p>
</li>
<li><p>更新 grub：<code>$ sudo update-grub</code></p>
</li>
<li><p>重启系统，即可。</p>
</li>
</ul>
<h3 id="Docker-与虚拟化"><a href="#Docker-与虚拟化" class="headerlink" title="Docker 与虚拟化"></a>Docker 与虚拟化</h3><h4 id="Docker-与-LXC（Linux-Container）有何不同？"><a href="#Docker-与-LXC（Linux-Container）有何不同？" class="headerlink" title="Docker 与 LXC（Linux Container）有何不同？"></a>Docker 与 LXC（Linux Container）有何不同？</h4><p>答：LXC 利用 Linux 上相关技术实现了容器。Docker 则在如下的几个方面进行了改进：</p>
<ul>
<li>移植性：通过抽象容器配置，容器可以实现从一个平台移植到另一个平台；</li>
<li>镜像系统：基于 OverlayFS 的镜像系统为容器的分发带来了很多的便利，同时共同的镜像层只需要存储一份，实现高效率的存储；</li>
<li>版本管理：类似于Git的版本管理理念，用户可以更方便的创建、管理镜像文件；</li>
<li>仓库系统：仓库系统大大降低了镜像的分发和管理的成本；</li>
<li>周边工具：各种现有工具（配置管理、云平台）对 Docker 的支持，以及基于 Docker的 PaaS、CI 等系统，让 Docker 的应用更加方便和多样化。</li>
</ul>
<h4 id="Docker-与-Vagrant-有何不同？"><a href="#Docker-与-Vagrant-有何不同？" class="headerlink" title="Docker 与 Vagrant 有何不同？"></a>Docker 与 Vagrant 有何不同？</h4><p>答：两者的定位完全不同。</p>
<ul>
<li><p>Vagrant 类似 Boot2Docker（一款运行 Docker 的最小内核），是一套虚拟机的管理环境。Vagrant 可以在多种系统上和虚拟机软件中运行，可以在 Windows，Mac 等非 Linux 平台上为 Docker 提供支持，自身具有较好的包装性和移植性。</p>
</li>
<li><p>原生的 Docker 自身只能运行在 Linux 平台上，但启动和运行的性能都比虚拟机要快，往往更适合快速开发和部署应用的场景。</p>
</li>
</ul>
<p>简单说：Vagrant 适合用来管理虚拟机，而 Docker 适合用来管理应用环境。</p>
<h4 id="开发环境中-Docker-和-Vagrant-该如何选择？"><a href="#开发环境中-Docker-和-Vagrant-该如何选择？" class="headerlink" title="开发环境中 Docker 和 Vagrant 该如何选择？"></a>开发环境中 Docker 和 Vagrant 该如何选择？</h4><p>答：Docker 不是虚拟机，而是进程隔离，对于资源的消耗很少，但是目前需要 Linux 环境支持。Vagrant 是虚拟机上做的封装，虚拟机本身会消耗资源。</p>
<p>如果本地使用的 Linux 环境，推荐都使用 Docker。</p>
<p>如果本地使用的是 macOS 或者 Windows 环境，那就需要开虚拟机，单一开发环境下 Vagrant 更简单；多环境开发下推荐在 Vagrant 里面再使用 Docker 进行环境隔离。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="Docker-能在非-Linux-平台（比如-Windows-或-macOS-）上运行么？"><a href="#Docker-能在非-Linux-平台（比如-Windows-或-macOS-）上运行么？" class="headerlink" title="Docker 能在非 Linux 平台（比如 Windows 或 macOS ）上运行么？"></a>Docker 能在非 Linux 平台（比如 Windows 或 macOS ）上运行么？</h4><p>答：完全可以。安装方法请查看 <a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/get-docker/">安装 Docker</a></p>
<h4 id="如何将一台宿主主机的-Docker-环境迁移到另外一台宿主主机？"><a href="#如何将一台宿主主机的-Docker-环境迁移到另外一台宿主主机？" class="headerlink" title="如何将一台宿主主机的 Docker 环境迁移到另外一台宿主主机？"></a>如何将一台宿主主机的 Docker 环境迁移到另外一台宿主主机？</h4><p>答：停止 Docker 服务。将整个 Docker 存储文件夹复制到另外一台宿主主机，然后调整另外一台宿主主机的配置即可。</p>
<h4 id="如何进入-Docker-容器的网络命名空间？"><a href="#如何进入-Docker-容器的网络命名空间？" class="headerlink" title="如何进入 Docker 容器的网络命名空间？"></a>如何进入 Docker 容器的网络命名空间？</h4><p>答：Docker 在创建容器后，删除了宿主主机上 <code>/var/run/netns</code> 目录中的相关的网络命名空间文件。因此，在宿主主机上是无法看到或访问容器的网络命名空间的。</p>
<p>用户可以通过如下方法来手动恢复它。</p>
<p>首先，使用下面的命令查看容器进程信息，比如这里的 1234。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format=<span class="string">&#x27;&#123;&#123;. State.Pid&#125;&#125; &#x27;</span> <span class="variable">$container_id</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>接下来，在 <code>/proc</code> 目录下，把对应的网络命名空间文件链接到 <code>/var/run/netns</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">ln</span> -s /proc/1234/ns/net /var/run/netns/</span><br></pre></td></tr></table></figure>

<p>然后，在宿主主机上就可以看到容器的网络命名空间信息。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip netns show</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>此时，用户可以通过正常的系统命令来查看或操作容器的命名空间了。例如修改容器的 IP 地址信息为 <code>172.17.0.100/16</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ip netns <span class="built_in">exec</span> 1234 ifconfig eth0 172.17.0.100/16</span><br></pre></td></tr></table></figure>

<h4 id="如何获取容器绑定到本地那个-veth-接口上？"><a href="#如何获取容器绑定到本地那个-veth-接口上？" class="headerlink" title="如何获取容器绑定到本地那个 veth 接口上？"></a>如何获取容器绑定到本地那个 veth 接口上？</h4><p>答：Docker 容器启动后，会通过 veth 接口对连接到本地网桥，veth 接口命名跟容器命名毫无关系，十分难以找到对应关系。</p>
<p>最简单的一种方式是通过查看接口的索引号，在容器中执行 <code>ip a</code> 命令，查看到本地接口最前面的接口索引号，如 <code>205</code>，将此值加上 1，即 <code>206</code>，然后在本地主机执行 <code>ip a</code> 命令，查找接口索引号为 <code>206</code> 的接口，两者即为连接的 veth 接口对。</p>
<h2 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p>
<ul>
<li>客户端命令：基本命令格式为 <code>docker [OPTIONS] COMMAND [arg...]</code>；</li>
<li>服务端命令：基本命令格式为 <code>dockerd [OPTIONS]</code>。</li>
</ul>
<p>可以通过 <code>man docker</code> 或 <code>docker help</code> 来查看这些命令。</p>
<h3 id="客户端命令-docker"><a href="#客户端命令-docker" class="headerlink" title="客户端命令(docker)"></a>客户端命令(docker)</h3><h4 id="客户端命令选项"><a href="#客户端命令选项" class="headerlink" title="客户端命令选项"></a>客户端命令选项</h4><ul>
<li><code>--config=&quot;&quot;</code>：指定客户端配置文件，默认为 <code>~/.docker</code>；</li>
<li><code>-D=true|false</code>：是否使用 debug 模式。默认不开启；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--tls=true|false</code>：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否。</li>
</ul>
<h4 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h4><p>可以通过 <code>docker COMMAND --help</code> 来查看这些命令的具体用法。</p>
<ul>
<li><code>attach</code>：依附到一个正在运行的容器中；</li>
<li><code>build</code>：从一个 Dockerfile 创建一个镜像；</li>
<li><code>commit</code>：从一个容器的修改中创建一个新的镜像；</li>
<li><code>cp</code>：在容器和本地宿主系统之间复制文件中；</li>
<li><code>create</code>：创建一个新容器，但并不运行它；</li>
<li><code>diff</code>：检查一个容器内文件系统的修改，包括修改和增加；</li>
<li><code>events</code>：从服务端获取实时的事件；</li>
<li><code>exec</code>：在运行的容器内执行命令；</li>
<li><code>export</code>：导出容器内容为一个 <code>tar</code> 包；</li>
<li><code>history</code>：显示一个镜像的历史信息；</li>
<li><code>images</code>：列出存在的镜像；</li>
<li><code>import</code>：导入一个文件（典型为 <code>tar</code> 包）路径或目录来创建一个本地镜像；</li>
<li><code>info</code>：显示一些相关的系统信息；</li>
<li><code>inspect</code>：显示一个容器的具体配置信息；</li>
<li><code>kill</code>：关闭一个运行中的容器 (包括进程和所有相关资源)；</li>
<li><code>load</code>：从一个 tar 包中加载一个镜像；</li>
<li><code>login</code>：注册或登录到一个 Docker 的仓库服务器；</li>
<li><code>logout</code>：从 Docker 的仓库服务器登出；</li>
<li><code>logs</code>：获取容器的 log 信息；</li>
<li><code>network</code>：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</li>
<li><code>node</code>：管理 swarm 集群中的节点，包括查看、更新、删除、提升&#x2F;取消管理节点等；</li>
<li><code>pause</code>：暂停一个容器中的所有进程；</li>
<li><code>port</code>：查找一个 nat 到一个私有网口的公共口；</li>
<li><code>ps</code>：列出主机上的容器；</li>
<li><code>pull</code>：从一个Docker的仓库服务器下拉一个镜像或仓库；</li>
<li><code>push</code>：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</li>
<li><code>rename</code>：重命名一个容器；</li>
<li><code>restart</code>：重启一个运行中的容器；</li>
<li><code>rm</code>：删除给定的若干个容器；</li>
<li><code>rmi</code>：删除给定的若干个镜像；</li>
<li><code>run</code>：创建一个新容器，并在其中运行给定命令；</li>
<li><code>save</code>：保存一个镜像为 tar 包文件；</li>
<li><code>search</code>：在 Docker index 中搜索一个镜像；</li>
<li><code>service</code>：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</li>
<li><code>start</code>：启动一个容器；</li>
<li><code>stats</code>：输出（一个或多个）容器的资源使用统计信息；</li>
<li><code>stop</code>：终止一个运行中的容器；</li>
<li><code>swarm</code>：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</li>
<li><code>tag</code>：为一个镜像打标签；</li>
<li><code>top</code>：查看一个容器中的正在运行的进程信息；</li>
<li><code>unpause</code>：将一个容器内所有的进程从暂停状态中恢复；</li>
<li><code>update</code>：更新指定的若干容器的配置信息；</li>
<li><code>version</code>：输出 Docker 的版本信息；</li>
<li><code>volume</code>：管理 Docker volume，包括查看、创建、删除等；</li>
<li><code>wait</code>：阻塞直到一个容器终止，然后输出它的退出符。</li>
</ul>
<h4 id="一张图总结-Docker-的命令"><a href="#一张图总结-Docker-的命令" class="headerlink" title="一张图总结 Docker 的命令"></a>一张图总结 Docker 的命令</h4><p><img src="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/img-10.png" alt="Docker 命令总结"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/cli/">官方文档</a></li>
</ul>
<h3 id="服务端命令-dockerd"><a href="#服务端命令-dockerd" class="headerlink" title="服务端命令(dockerd)"></a>服务端命令(dockerd)</h3><h4 id="dockerd-命令选项"><a href="#dockerd-命令选项" class="headerlink" title="dockerd 命令选项"></a>dockerd 命令选项</h4><ul>
<li><code>--api-cors-header=&quot;&quot;</code>：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；</li>
<li><code>--authorization-plugin=&quot;&quot;</code>：载入认证的插件；</li>
<li><code>-b=&quot;&quot;</code>：将容器挂载到一个已存在的网桥上。指定为 <code>none</code> 时则禁用容器的网络，与 <code>--bip</code> 选项互斥；</li>
<li><code>--bip=&quot;&quot;</code>：让动态创建的 <code>docker0</code> 网桥采用给定的 CIDR 地址; 与 <code>-b</code> 选项互斥；</li>
<li><code>--cgroup-parent=&quot;&quot;</code>：指定 cgroup 的父组，默认 fs cgroup 驱动为 <code>/docker</code>，systemd cgroup 驱动为 <code>system.slice</code>；</li>
<li><code>--cluster-store=&quot;&quot;</code>：构成集群（如 <code>Swarm</code>）时，集群键值数据库服务地址；</li>
<li><code>--cluster-advertise=&quot;&quot;</code>：构成集群时，自身的被访问地址，可以为 <code>host:port</code> 或 <code>interface:port</code>；</li>
<li><code>--cluster-store-opt=&quot;&quot;</code>：构成集群时，键值数据库的配置选项；</li>
<li><code>--config-file=&quot;/etc/docker/daemon.json&quot;</code>：daemon 配置文件路径；</li>
<li><code>--containerd=&quot;&quot;</code>：containerd 文件的路径；</li>
<li><code>-D, --debug=true|false</code>：是否使用 Debug 模式。缺省为 false；</li>
<li><code>--default-gateway=&quot;&quot;</code>：容器的 IPv4 网关地址，必须在网桥的子网段内；</li>
<li><code>--default-gateway-v6=&quot;&quot;</code>：容器的 IPv6 网关地址；</li>
<li><code>--default-ulimit=[]</code>：默认的 ulimit 值；</li>
<li><code>--disable-legacy-registry=true|false</code>：是否允许访问旧版本的镜像仓库服务器；</li>
<li><code>--dns=&quot;&quot;</code>：指定容器使用的 DNS 服务器地址；</li>
<li><code>--dns-opt=&quot;&quot;</code>：DNS 选项；</li>
<li><code>--dns-search=[]</code>：DNS 搜索域；</li>
<li><code>--exec-opt=[]</code>：运行时的执行选项；</li>
<li><code>--exec-root=&quot;&quot;</code>：容器执行状态文件的根路径，默认为 <code>/var/run/docker</code>；</li>
<li><code>--fixed-cidr=&quot;&quot;</code>：限定分配 IPv4 地址范围；</li>
<li><code>--fixed-cidr-v6=&quot;&quot;</code>：限定分配 IPv6 地址范围；</li>
<li><code>-G, --group=&quot;&quot;</code>：分配给 unix 套接字的组，默认为 <code>docker</code>；</li>
<li><code>-g, --graph=&quot;&quot;</code>：Docker 运行时的根路径，默认为 <code>/var/lib/docker</code>；</li>
<li><code>-H, --host=[]</code>：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字 <code>unix:///path/to/socket</code>，文件句柄 <code>fd://socketfd</code> 或 tcp 套接字 <code>tcp://[host[:port]]</code>，默认为 <code>unix:///var/run/docker.sock</code>；</li>
<li><code>--icc=true|false</code>：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</li>
<li><code>--insecure-registry=[]</code>：允许访问给定的非安全仓库服务；</li>
<li><code>--ip=&quot;&quot;</code>：绑定容器端口时候的默认 IP 地址。缺省为 <code>0.0.0.0</code>；</li>
<li><code>--ip-forward=true|false</code>：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</li>
<li><code>--ip-masq=true|false</code>：是否进行地址伪装，用于容器访问外部网络，默认开启；</li>
<li><code>--iptables=true|false</code>：是否允许 Docker 添加 iptables 规则。缺省为 true；</li>
<li><code>--ipv6=true|false</code>：是否启用 IPv6 支持，默认关闭；</li>
<li><code>-l, --log-level=&quot;debug|info|warn|error|fatal&quot;</code>：指定日志输出级别；</li>
<li><code>--label=&quot;[]&quot;</code>：添加指定的键值对标注；</li>
<li><code>--log-driver=&quot;json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none&quot;</code>：指定日志后端驱动，默认为 <code>json-file</code>；</li>
<li><code>--log-opt=[]</code>：日志后端的选项；</li>
<li><code>--mtu=VALUE</code>：指定容器网络的 <code>mtu</code>；</li>
<li><code>-p=&quot;&quot;</code>：指定 daemon 的 PID 文件路径。缺省为 <code>/var/run/docker.pid</code>；</li>
<li><code>--raw-logs</code>：输出原始，未加色彩的日志信息；</li>
<li><code>--registry-mirror=&lt;scheme&gt;://&lt;host&gt;</code>：指定 <code>docker pull</code> 时使用的注册服务器镜像地址；</li>
<li><code>-s, --storage-driver=&quot;&quot;</code>：指定使用给定的存储后端；</li>
<li><code>--selinux-enabled=true|false</code>：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</li>
<li><code>--storage-opt=[]</code>：驱动后端选项；</li>
<li><code>--tls=true|false</code>：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</li>
<li><code>--tlscacert=/.docker/ca.pem</code>：TLS CA 签名的可信证书文件路径；</li>
<li><code>--tlscert=/.docker/cert.pem</code>：TLS 可信证书文件路径；</li>
<li><code>--tlscert=/.docker/key.pem</code>：TLS 密钥文件路径；</li>
<li><code>--tlsverify=true|false</code>：启用 TLS 校验，默认为否；</li>
<li><code>--userland-proxy=true|false</code>：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</li>
<li><code>--userns-remap=default|uid:gid|user:group|user|uid</code>：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</li>
</ul>
<h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/dockerd/">官方文档</a></li>
</ul>
<h2 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h2><p>对 Docker 官方文档中 <a target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles</a> 参考。</p>
<h3 id="一般性的指南和建议"><a href="#一般性的指南和建议" class="headerlink" title="一般性的指南和建议"></a>一般性的指南和建议</h3><h4 id="容器应该是短暂的"><a href="#容器应该是短暂的" class="headerlink" title="容器应该是短暂的"></a>容器应该是短暂的</h4><p>通过 <code>Dockerfile</code> 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p>
<h4 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 <code>.dockerignore</code> 文件</h4><p>使用 <code>Dockerfile</code> 构建镜像时最好是将 <code>Dockerfile</code> 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，可以在目录下新建一个 <code>.dockerignore</code> 文件来指定要忽略的文件和目录。<code>.dockerignore</code> 文件的排除模式语法和 Git 的 <code>.gitignore</code> 文件相似。</p>
<h4 id="使用多阶段构建-1"><a href="#使用多阶段构建-1" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h4><p>在 <code>Docker 17.05</code> 以上版本中，可以使用 <a href="#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">多阶段构建</a> 来减少所构建镜像的大小。</p>
<h4 id="避免安装不必要的包"><a href="#避免安装不必要的包" class="headerlink" title="避免安装不必要的包"></a>避免安装不必要的包</h4><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
<h4 id="一个容器只运行一个进程"><a href="#一个容器只运行一个进程" class="headerlink" title="一个容器只运行一个进程"></a>一个容器只运行一个进程</h4><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。</p>
<p>如果容器互相依赖，可以使用 <a href="#%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE">Docker 自定义网络</a> 来把这些容器连接起来。</p>
<h4 id="镜像层数尽可能少"><a href="#镜像层数尽可能少" class="headerlink" title="镜像层数尽可能少"></a>镜像层数尽可能少</h4><p>需要在 <code>Dockerfile</code> 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
<h4 id="将多行参数排序"><a href="#将多行参数排序" class="headerlink" title="将多行参数排序"></a>将多行参数排序</h4><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助避免重复包含同一个包，更新包列表时也更容易。也便于 <code>PRs</code> 阅读和审查。建议在反斜杠符号 <code>\</code> 之前添加一个空格，以增加可读性。</p>
<p>下面是来自 <code>buildpack-deps</code> 镜像的例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">  bzr \</span></span><br><span class="line"><span class="language-bash">  cvs \</span></span><br><span class="line"><span class="language-bash">  git \</span></span><br><span class="line"><span class="language-bash">  mercurial \</span></span><br><span class="line"><span class="language-bash">  subversion</span></span><br></pre></td></tr></table></figure>

<h4 id="构建缓存-1"><a href="#构建缓存-1" class="headerlink" title="构建缓存"></a>构建缓存</h4><p>在镜像的构建过程中，Docker 会遍历 <code>Dockerfile</code> 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果不想在构建过程中使用缓存，你可以在 <code>docker build</code> 命令中使用 <code>--no-cache=true</code> 选项。</p>
<p><a href="#%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98">构建缓存规则</a></p>
<p>一旦缓存失效，所有后续的 <code>Dockerfile</code> 指令都将产生新的镜像，缓存不会被使用。</p>
<h3 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h3><p>下面针对 <code>Dockerfile</code> 中各种指令的最佳编写方式给出建议。</p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 <a target="_blank" rel="noopener" href="https://hub.docker.com/_/alpine/">Alpine</a> 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p>
<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 <code>LABEL</code> 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。</p>
<blockquote>
<p>注意：如果字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set one or more individual labels</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version.is-production=<span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 <code>LABEL</code> 指令中。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="language-bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="language-bash">      com.example.is-production=<span class="string">&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>关于标签可以接受的键值对，参考 <a target="_blank" rel="noopener" href="https://docs.docker.com/config/labels-custom-metadata/">Understanding object labels</a>。关于查询标签信息，参考 <a target="_blank" rel="noopener" href="https://docs.docker.com/config/labels-custom-metadata/">Managing labels on objects</a>。</p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>为了保持 <code>Dockerfile</code> 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 <code>RUN</code> 指令用反斜杠 <code>\</code> 分割成多行。</p>
<h5 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h5><p><code>RUN</code> 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。</p>
<p>不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，应该联系它的维护者。如果确定某个特定的包，比如 <code>foo</code>，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 <code>foo</code> 包。</p>
<p>永远将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 组合成一条 <code>RUN</code> 声明，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">        package-bar \</span></span><br><span class="line"><span class="language-bash">        package-baz \</span></span><br><span class="line"><span class="language-bash">        package-foo</span></span><br></pre></td></tr></table></figure>

<p>将 <code>apt-get update</code> 放在一条单独的 <code>RUN</code> 声明中会导致缓存问题以及后续的 <code>apt-get install</code> 失败。比如，假设有一个 <code>Dockerfile</code> 文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl</span></span><br></pre></td></tr></table></figure>

<p>构建镜像后，所有的层都在 Docker 的缓存中。假设后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl nginx</span></span><br></pre></td></tr></table></figure>

<p>Docker 发现修改后的 <code>RUN apt-get update</code> 指令和之前的完全一样。所以，<code>apt-get update</code> 不会执行，而是使用之前的缓存镜像。因为 <code>apt-get update</code> 没有运行，后面的 <code>apt-get install</code> 可能安装的是过时的 <code>curl</code> 和 <code>nginx</code> 版本。</p>
<p>使用 <code>RUN apt-get update &amp;&amp; apt-get install -y</code> 可以确保 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 <code>cache busting</code>。也可以显示指定一个包的版本号来达到 <code>cache-busting</code>，这就是所谓的固定版本，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    package-bar \</span></span><br><span class="line"><span class="language-bash">    package-baz \</span></span><br><span class="line"><span class="language-bash">    package-foo=1.3.*</span></span><br></pre></td></tr></table></figure>

<p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。</p>
<p>下面是一个 <code>RUN</code> 指令的示例模板，展示了所有关于 <code>apt-get</code> 的建议。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    aufs-tools \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    dpkg-sig \</span></span><br><span class="line"><span class="language-bash">    libcap-dev \</span></span><br><span class="line"><span class="language-bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="language-bash">    mercurial \</span></span><br><span class="line"><span class="language-bash">    reprepro \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="language-bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>s3cmd</code> 指令指定了一个版本号 <code>1.1.*</code>。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 <code>apt-get update</code> 缓存失效并确保安装的是新版本。</p>
<p>另外，清理掉 apt 缓存 <code>var/lib/apt/lists</code> 可以减小镜像大小。因为 <code>RUN</code> 指令的开头为 <code>apt-get update</code>，包缓存总是会在 <code>apt-get install</code> 之前刷新。</p>
<blockquote>
<p>注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p>
</blockquote>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p><code>CMD</code> 指令用于执行目标镜像中包含的软件，可以包含参数。<code>CMD</code> 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 <code>Apache</code>)，可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。建议任何服务镜像都使用这种形式的命令。</p>
<p>多数情况下，<code>CMD</code> 都需要一个交互式的 <code>shell</code> (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>，或者 <code>CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当执行类似 <code>docker run -it python</code> 时，会进入一个准备好的 <code>shell</code> 中。<code>CMD</code> 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非镜像创建者和使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><code>EXPOSE</code> 指令用于指定容器将要监听的端口。因此，应该为应用程序使用常见的端口。例如，提供 <code>Apache</code> web 服务的镜像应该使用 <code>EXPOSE 80</code>，而提供 <code>MongoDB</code> 服务的镜像使用 <code>EXPOSE 27017</code>。</p>
<p>对于外部访问，用户可以在执行 <code>docker run</code> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>为了方便新程序运行，可以使用 <code>ENV</code> 来为容器中安装的程序更新 <code>PATH</code> 环境变量。例如使用 <code>ENV PATH /usr/local/nginx/bin:$PATH</code> 来确保 <code>CMD [&quot;nginx&quot;]</code> 能正确运行。</p>
<p><code>ENV</code> 指令也可用于为想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 <code>PGDATA</code>。</p>
<p>最后，<code>ENV</code> 也能用于设置常见的版本号，比如下面的示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>类似于程序中的常量，这种方法可以让你只需改变 <code>ENV</code> 指令来自动的改变容器中的软件版本。</p>
<h4 id="ADD-和-COPY"><a href="#ADD-和-COPY" class="headerlink" title="ADD 和 COPY"></a>ADD 和 COPY</h4><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能类似，但一般优先使用 <code>COPY</code>。因为它比 <code>ADD</code> 更透明。<code>COPY</code> 只支持简单将本地文件拷贝到容器中，而 <code>ADD</code> 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，<code>ADD</code> 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 <code>ADD rootfs.tar.xz</code>。</p>
<p>如果 <code>Dockerfile</code> 有多个步骤需要使用上下文中不同的文件。单独 <code>COPY</code> 每个文件，而不是一次性的 <code>COPY</code> 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /tmp/</span></span><br></pre></td></tr></table></figure>

<p>如果将 <code>COPY . /tmp/</code> 放置在 <code>RUN</code> 指令之前，只要 <code>.</code> 目录中任何一个文件变化，都会导致后续指令的缓存失效。</p>
<p>为了让镜像尽量小，最好不要使用 <code>ADD</code> 指令从远程 URL 获取包，而是使用 <code>curl</code> 和 <code>wget</code>。这样可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> http://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>而是应该使用下面这种方法：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="language-bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>上面使用的管道操作，所以没有中间文件需要删除。</p>
<p>对于其他不需要 <code>ADD</code> 的自动提取功能的文件或目录，应该使用 <code>COPY</code>。</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 <code>CMD</code> 提供默认选项）。</p>
<p>例如，下面的示例镜像提供了命令行工具 <code>s3cmd</code>:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;s3cmd&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>现在直接运行该镜像创建的容器会显示命令帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run s3cmd</span><br></pre></td></tr></table></figure>

<p>或者提供正确的参数来执行某个命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run s3cmd <span class="built_in">ls</span> s3://mybucket</span><br></pre></td></tr></table></figure>

<p>这样镜像名可以当成命令行的参考。</p>
<p><code>ENTRYPOINT</code> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</p>
<p>例如，<code>Postgres</code> 官方镜像使用下面的脚本作为 <code>ENTRYPOINT</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;postgres&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">chown</span> -R postgres <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="subst">$(ls -A <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>
</blockquote>
<p>该辅助脚本被拷贝到容器，并在容器启动时通过 <code>ENTRYPOINT</code> 执行：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>该脚本可以让用户用几种不同的方式和 <code>Postgres</code> 交互。</p>
<p>可以很简单地启动 <code>Postgres</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run postgres</span><br></pre></td></tr></table></figure>

<p>也可以执行 <code>Postgres</code> 并传递参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run postgres postgres --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>最后，还可以启动另外一个完全不同的工具，比如 <code>Bash</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> -it postgres bash</span><br></pre></td></tr></table></figure>

<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p><code>VOLUME</code> 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 <code>VOLUME</code> 来管理镜像中的可变部分和用户可以改变的部分。</p>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>如果某个服务不需要特权执行，建议使用 <code>USER</code> 指令切换到非 root 用户。先在 <code>Dockerfile</code> 中使用类似 <code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code> 的指令创建用户和用户组。</p>
<blockquote>
<p>注意：在镜像中，用户和用户组每次被分配的 UID&#x2F;GID 都是不确定的，下次重新构建镜像时被分配到的 UID&#x2F;GID 可能会不一样。如果要依赖确定的 UID&#x2F;GID，应该显式的指定一个 UID&#x2F;GID。</p>
</blockquote>
<p>应该避免使用 <code>sudo</code>，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果真的需要和 <code>sudo</code> 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），可以使用 <a target="_blank" rel="noopener" href="https://github.com/tianon/gosu">gosu</a>。</p>
<p>最后，为了减少层数和复杂度，避免频繁地使用 <code>USER</code> 来回切换用户。</p>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>为了清晰性和可靠性，应该总是在 <code>WORKDIR</code> 中使用绝对路径。另外，应该使用 <code>WORKDIR</code> 来替代类似于 <code>RUN cd ... &amp;&amp; do-something</code> 的指令，后者难以阅读、排错和维护。</p>
<h3 id="官方镜像示例"><a href="#官方镜像示例" class="headerlink" title="官方镜像示例"></a>官方镜像示例</h3><p>这些官方镜像的 Dockerfile 都是参考典范：<a target="_blank" rel="noopener" href="https://github.com/docker-library/docs">https://github.com/docker-library/docs</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xiangnan321.github.io">South</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xiangnan321.github.io/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/">https://xiangnan321.github.io/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xiangnan321.github.io" target="_blank">Hi</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/24/Docker-Compose%E3%80%81Docker-Swarm-%E4%B8%8E-Kubernetes-K8s-%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Docker Compose、Docker Swarm 与 Kubernetes (K8s) 的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Docker Compose、Docker Swarm 与 Kubernetes (K8s) 的区别</div></div><div class="info-2"><div class="info-item-1">Docker Swarm、Docker Compose 和 Kubernetes 是容器编排领域三个关键的工具，它们定位不同，适用于不同的场景。 简单比喻：  Docker Compose：像是一个音响系统的遥控器。可以在一个房间（一台机器）里，一键控制多个音响设备（多个容器）的开关、音量，让它们协同工作。管理单机。 Docker Swarm：像是一个大型商场的中央广播系统。有一个控制中心，可以同时向商场里的所有分区（多台机器）发布指令，让整个商场的背景音乐同步。内置的、简单的集群管理。 Kubernetes (K8s)：像是整个城市的交通指挥中心。它管理着成千上万辆汽车（容器），自动处理交通拥堵（负载均衡）、车辆故障（自愈）、新建道路（自动扩缩容），确保城市交通高效、可靠。企业级的、复杂的集群管理。  Docker Compose - 编排工具（单机）核心定位：定义和运行多个容器的单机应用。  工作范围：单台主机。它无法管理多台机器组成的集群。 主要功能：通过一个 docker-compose.yml 文件，定义一组相关联的服务（容器）、它们的依赖关系、网络、数据卷等。然后用一...</div></div></div></a><a class="pagination-related" href="/2025/08/15/js%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="js数组与字符串的方法总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">js数组与字符串的方法总结</div></div><div class="info-2"><div class="info-item-1">简单整理的数组与字符串的方法。 数组concat( )给数组添加元素，会返回一个新的数组，不会改变原数组。 1234let arr=[3,5,2,7,9,13,8];let arr1=arr.concat(2);console.log(arr);//[3,5,2,7,9,13,8]console.log(arr1);//[3,5,2,7,9,13,8,2];  join( )join( separator ) 将数组中所有元素都转换为字符串，然后连接在一起。separator 在返回的字符串中用于分隔数组元素的字符或字符串，它是可选的。如果省略了这个参数，用逗号作为分隔符。 123let arr=[3,5,2,7,9,13,8];console.log(arr.join());//3,5,2,7,9,13,8console.log(arr.join(&quot;/&quot;));//3/5/2/7/9/13/8  pop( )从数组尾部删除一个项目。 123let arr=[3,5,2,7,9,13,8];arr.pop();console.log(arr);//[3,5,2,...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">South</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">Docker架构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">Docker在Linux环境下的架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92"><span class="toc-number">1.1.2.</span> <span class="toc-text">Docker 工作原理与组件交互</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Docker"><span class="toc-number">1.2.</span> <span class="toc-text">为什么使用Docker</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%EF%BC%88Image%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">镜像（Image）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">分层存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E9%95%9C%E5%83%8F%E7%9A%84%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">核心概念：镜像的唯一标识</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%EF%BC%88Container%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">容器（Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%EF%BC%88Docker-Repository%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">仓库（Docker Repository）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Registry-%E5%85%AC%E5%BC%80%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.3.1.</span> <span class="toc-text">Docker Registry 公开服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89-Docker-Registry"><span class="toc-number">2.3.2.</span> <span class="toc-text">私有 Docker Registry</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Docker-%E9%95%9C%E5%83%8F"><span class="toc-number">3.</span> <span class="toc-text">使用 Docker 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.</span> <span class="toc-text">获取镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-number">3.1.1.</span> <span class="toc-text">运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F"><span class="toc-number">3.2.</span> <span class="toc-text">列出镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">镜像体积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F"><span class="toc-number">3.2.2.</span> <span class="toc-text">虚悬镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E5%B1%82%E9%95%9C%E5%83%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">中间层镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E9%83%A8%E5%88%86%E9%95%9C%E5%83%8F"><span class="toc-number">3.2.4.</span> <span class="toc-text">列出部分镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E7%89%B9%E5%AE%9A%E6%A0%BC%E5%BC%8F%E6%98%BE%E7%A4%BA"><span class="toc-number">3.2.5.</span> <span class="toc-text">以特定格式显示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F"><span class="toc-number">3.3.</span> <span class="toc-text">删除本地镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-ID%E3%80%81%E9%95%9C%E5%83%8F%E5%90%8D%E3%80%81%E6%91%98%E8%A6%81%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">用 ID、镜像名、摘要删除镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Untagged-%E5%92%8C-Deleted"><span class="toc-number">3.3.2.</span> <span class="toc-text">Untagged 和 Deleted</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Untagged-%E5%8F%96%E6%B6%88%E6%A0%87%E7%AD%BE"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">Untagged (取消标签)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Deleted-%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E5%B1%82"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">Deleted (删除镜像层)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E7%B1%BB%E6%AF%94"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">总结与类比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-docker-image-ls-%E5%91%BD%E4%BB%A4%E6%9D%A5%E9%85%8D%E5%90%88"><span class="toc-number">3.3.3.</span> <span class="toc-text">用 docker image ls 命令来配合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-commit-%E7%90%86%E8%A7%A3%E9%95%9C%E5%83%8F%E6%9E%84%E6%88%90"><span class="toc-number">3.4.</span> <span class="toc-text">利用 commit 理解镜像构成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%8E%E7%94%A8-docker-commit"><span class="toc-number">3.4.1.</span> <span class="toc-text">慎用 docker commit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Dockerfile-%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F"><span class="toc-number">3.5.</span> <span class="toc-text">使用 Dockerfile 定制镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FROM-%E6%8C%87%E5%AE%9A%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">FROM 指定基础镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RUN-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">3.5.2.</span> <span class="toc-text">RUN 执行命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">3.5.3.</span> <span class="toc-text">构建镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88Context%EF%BC%89"><span class="toc-number">3.5.4.</span> <span class="toc-text">镜像构建上下文（Context）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%94%A8-Git-repo-%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="toc-number">3.5.5.</span> <span class="toc-text">直接用 Git repo 进行构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E7%BB%99%E5%AE%9A%E7%9A%84-tar-%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%9E%84%E5%BB%BA"><span class="toc-number">3.5.6.</span> <span class="toc-text">用给定的 tar 压缩包构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96-Dockerfile-%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="toc-number">3.5.7.</span> <span class="toc-text">从标准输入中读取 Dockerfile 进行构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8E%8B%E7%BC%A9%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="toc-number">3.5.8.</span> <span class="toc-text">标准输入中读取上下文压缩包进行构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">其它制作镜像的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-rootfs-%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%BC%E5%85%A5"><span class="toc-number">3.6.1.</span> <span class="toc-text">从 rootfs 压缩包导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA-docker-save-%E5%92%8C-docker-load"><span class="toc-number">3.6.2.</span> <span class="toc-text">Docker 镜像的导入和导出 docker save 和 docker load</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E9%95%9C%E5%83%8F"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">保存镜像</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.3.</span> <span class="toc-text">镜像的实现原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">操作容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">列出容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">启动容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">新建并启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">启动已终止容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">4.2.3.</span> <span class="toc-text">后台运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">终止容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">进入容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#attach-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.4.1.</span> <span class="toc-text">attach 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.4.2.</span> <span class="toc-text">exec 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">导出和导入容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">4.5.1.</span> <span class="toc-text">导出容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8%E5%BF%AB%E7%85%A7"><span class="toc-number">4.5.2.</span> <span class="toc-text">导入容器快照</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">删除容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E4%BB%93%E5%BA%93"><span class="toc-number">5.</span> <span class="toc-text">Docker 仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Hub"><span class="toc-number">5.1.</span> <span class="toc-text">Docker Hub</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C"><span class="toc-number">5.1.1.</span> <span class="toc-text">注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E5%BD%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">拉取镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E9%95%9C%E5%83%8F"><span class="toc-number">5.1.4.</span> <span class="toc-text">推送镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">5.2.</span> <span class="toc-text">私有仓库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">Docker 数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volume%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8D%B7%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">volume（数据卷）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">6.1.1.</span> <span class="toc-text">创建一个数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">6.1.2.</span> <span class="toc-text">启动一个挂载数据卷的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF"><span class="toc-number">6.1.3.</span> <span class="toc-text">查看数据卷的具体信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">6.1.4.</span> <span class="toc-text">删除数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.5.</span> <span class="toc-text">核心特性与工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.6.</span> <span class="toc-text">使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%8D%B7%EF%BC%88Anonymous-Volumes%EF%BC%89"><span class="toc-number">6.1.6.1.</span> <span class="toc-text">匿名卷（Anonymous Volumes）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E5%8D%B7%EF%BC%88Named-Volumes%EF%BC%89-%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="toc-number">6.1.6.2.</span> <span class="toc-text">命名卷（Named Volumes）- 最常用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AE%B9%E5%99%A8%E5%A1%AB%E5%85%85%EF%BC%88%E2%80%93volumes-from%EF%BC%89"><span class="toc-number">6.1.6.3.</span> <span class="toc-text">通过容器填充（–volumes-from）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95-Bind-mounts-%E7%BB%91%E5%AE%9A%E6%8C%82%E8%BD%BD"><span class="toc-number">6.2.</span> <span class="toc-text">挂载主机目录 (Bind mounts - 绑定挂载)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">6.2.1.</span> <span class="toc-text">挂载一个本地主机文件作为数据卷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%8C%82%E8%BD%BD-%E4%B8%8E-%E5%91%BD%E5%90%8D%E5%8D%B7-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">绑定挂载 与 命名卷 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C"><span class="toc-number">7.</span> <span class="toc-text">使用网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">外部访问容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3"><span class="toc-number">7.1.1.</span> <span class="toc-text">指定映射端口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">映射所有接口地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">映射到指定地址的指定端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%BB%E6%84%8F%E7%AB%AF%E5%8F%A3"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">映射到指定地址的任意端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-number">7.1.1.4.</span> <span class="toc-text">查看映射端口配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="toc-number">7.2.</span> <span class="toc-text">容器互联</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E7%BD%91%E7%BB%9C"><span class="toc-number">7.2.1.</span> <span class="toc-text">Docker 网络</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">连接容器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">7.2.2.</span> <span class="toc-text">Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">核心概念与工作流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E4%B8%8E-docker-compose-yml-%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">核心语法与 docker-compose.yml 文件详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-Docker-Compose-%E5%91%BD%E4%BB%A4"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">常用 Docker Compose 命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5%E5%BC%80%E5%8F%91%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">7.2.2.4.</span> <span class="toc-text">典型工作流程（以开发为例）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">7.2.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-DNS"><span class="toc-number">7.3.</span> <span class="toc-text">配置 DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84-DNS-%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.1.</span> <span class="toc-text">默认的 DNS 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%B9%E5%99%A8%E7%9A%84-DNS-%E9%85%8D%E7%BD%AE"><span class="toc-number">7.3.2.</span> <span class="toc-text">自定义容器的 DNS 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A-etc-resolv-conf"><span class="toc-number">7.3.3.</span> <span class="toc-text">配置文件：&#x2F;etc&#x2F;resolv.conf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">7.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile"><span class="toc-number">8.</span> <span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#COPY-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">8.1.</span> <span class="toc-text">COPY 复制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD-%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.</span> <span class="toc-text">ADD 更高级的复制文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">8.3.</span> <span class="toc-text">CMD 容器启动命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENTRYPOINT-%E5%85%A5%E5%8F%A3%E7%82%B9"><span class="toc-number">8.4.</span> <span class="toc-text">ENTRYPOINT 入口点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.4.1.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENV-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">8.5.</span> <span class="toc-text">ENV 设置环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARG-%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><span class="toc-number">8.6.</span> <span class="toc-text">ARG 构建参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VOLUME-%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%8D%B7"><span class="toc-number">8.7.</span> <span class="toc-text">VOLUME 定义匿名卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPOSE-%E5%A3%B0%E6%98%8E%E7%AB%AF%E5%8F%A3"><span class="toc-number">8.8.</span> <span class="toc-text">EXPOSE 声明端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WORKDIR-%E6%8C%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-number">8.9.</span> <span class="toc-text">WORKDIR 指定工作目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USER-%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7"><span class="toc-number">8.10.</span> <span class="toc-text">USER 指定当前用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEALTHCHECK-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">8.11.</span> <span class="toc-text">HEALTHCHECK 健康检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LABEL-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.12.</span> <span class="toc-text">LABEL 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHELL-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.13.</span> <span class="toc-text">SHELL 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">8.13.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.13.2.</span> <span class="toc-text">作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ONBUILD-%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="toc-number">8.14.</span> <span class="toc-text">ONBUILD 延迟执行指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">8.14.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.14.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%92%8C%E7%AE%A1%E7%90%86-ONBUILD-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.14.3.</span> <span class="toc-text">查看和管理 ONBUILD 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">8.14.4.</span> <span class="toc-text">注意事项和最佳实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.14.5.</span> <span class="toc-text">实际应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA"><span class="toc-number">8.15.</span> <span class="toc-text">多阶段构建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-17-05-%E7%89%88%E6%9C%AC%E4%B9%8B%E5%89%8D"><span class="toc-number">8.15.1.</span> <span class="toc-text">Docker 17.05 版本之前</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E9%83%A8%E6%94%BE%E5%85%A5%E4%B8%80%E4%B8%AA-Dockerfile"><span class="toc-number">8.15.1.1.</span> <span class="toc-text">全部放入一个 Dockerfile</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E5%88%B0%E5%A4%9A%E4%B8%AA-Dockerfile"><span class="toc-number">8.15.1.2.</span> <span class="toc-text">分散到多个 Dockerfile</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA"><span class="toc-number">8.15.2.</span> <span class="toc-text">使用多阶段构建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E6%9E%84%E5%BB%BA%E6%9F%90%E4%B8%80%E9%98%B6%E6%AE%B5%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">8.15.2.1.</span> <span class="toc-text">只构建某一阶段的镜像</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%97%B6%E4%BB%8E%E5%85%B6%E4%BB%96%E9%95%9C%E5%83%8F%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">8.15.2.2.</span> <span class="toc-text">构建时从其他镜像复制文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%A7%8D%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%94%AF%E6%8C%81%E7%9A%84-Docker-%E9%95%9C%E5%83%8F-%E2%80%93-docker-manifest-%E5%91%BD%E4%BB%A4"><span class="toc-number">8.16.</span> <span class="toc-text">构建多种系统架构支持的 Docker 镜像 – docker manifest 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-manifest-%E5%91%BD%E4%BB%A4"><span class="toc-number">8.16.1.</span> <span class="toc-text">启用 manifest 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%AD%90%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.16.2.</span> <span class="toc-text">主要子命令详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">8.16.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Buildx"><span class="toc-number">8.17.</span> <span class="toc-text">Docker Buildx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">8.17.1.</span> <span class="toc-text">核心特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-docker-build-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">8.17.2.</span> <span class="toc-text">传统 docker build 的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-Buildx-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.17.3.</span> <span class="toc-text">Docker Buildx 的核心功能详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA%EF%BC%88%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-number">8.17.3.1.</span> <span class="toc-text">多平台构建（最重要的功能）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8-Buildx-%E6%9E%84%E5%BB%BA%E5%99%A8"><span class="toc-number">8.17.3.2.</span> <span class="toc-text">创建和使用 Buildx 构建器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.17.4.</span> <span class="toc-text">实际使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA"><span class="toc-number">8.17.4.1.</span> <span class="toc-text">基础多平台构建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%9E%84%E5%BB%BA%E5%B9%B6%E5%AF%BC%E5%87%BA"><span class="toc-number">8.17.4.2.</span> <span class="toc-text">本地构建并导出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">8.17.4.3.</span> <span class="toc-text">导出到文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="toc-number">8.17.5.</span> <span class="toc-text">高级功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84-Secret-%E7%AE%A1%E7%90%86"><span class="toc-number">8.17.5.1.</span> <span class="toc-text">安全的 Secret 管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.17.5.2.</span> <span class="toc-text">缓存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="toc-number">8.17.5.3.</span> <span class="toc-text">并行构建</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.17.6.</span> <span class="toc-text">常见使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">8.17.7.</span> <span class="toc-text">故障排除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">8.17.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E5%8F%98%E9%87%8F"><span class="toc-number">8.18.</span> <span class="toc-text">架构相关变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB"><span class="toc-number">8.18.1.</span> <span class="toc-text">变量分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E5%85%B7%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-number">8.18.2.</span> <span class="toc-text">详细解释具体变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TARGETPLATFORM"><span class="toc-number">8.18.2.1.</span> <span class="toc-text">TARGETPLATFORM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TARGETOS"><span class="toc-number">8.18.2.2.</span> <span class="toc-text">TARGETOS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TARGETARCH"><span class="toc-number">8.18.2.3.</span> <span class="toc-text">TARGETARCH</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TARGETVARIANT"><span class="toc-number">8.18.2.4.</span> <span class="toc-text">TARGETVARIANT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BUILDPLATFORM"><span class="toc-number">8.18.2.5.</span> <span class="toc-text">BUILDPLATFORM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BUILDOS"><span class="toc-number">8.18.2.6.</span> <span class="toc-text">BUILDOS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BUILDARCH"><span class="toc-number">8.18.2.7.</span> <span class="toc-text">BUILDARCH</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BUILDVARIANT"><span class="toc-number">8.18.2.8.</span> <span class="toc-text">BUILDVARIANT</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.18.3.</span> <span class="toc-text">实际应用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.18.4.</span> <span class="toc-text">构建命令示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">8.18.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BuildKit"><span class="toc-number">8.19.</span> <span class="toc-text">BuildKit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F-Docker-Builder-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">8.19.1.</span> <span class="toc-text">与传统 Docker Builder 的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-BuildKit"><span class="toc-number">8.19.2.</span> <span class="toc-text">启用 BuildKit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BuildKit-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.19.3.</span> <span class="toc-text">BuildKit 的核心特性详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%9E%84%E5%BB%BA%E6%89%A7%E8%A1%8C"><span class="toc-number">8.19.3.1.</span> <span class="toc-text">并行构建执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">8.19.3.2.</span> <span class="toc-text">高级缓存机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84-Secret-%E7%AE%A1%E7%90%86-1"><span class="toc-number">8.19.3.3.</span> <span class="toc-text">安全的 Secret 管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81"><span class="toc-number">8.19.3.4.</span> <span class="toc-text">多平台构建支持</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E7%9A%84%E6%8C%82%E8%BD%BD%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.19.3.5.</span> <span class="toc-text">灵活的挂载类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BuildKit-%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF"><span class="toc-number">8.19.4.</span> <span class="toc-text">BuildKit 的架构优势</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LLB%EF%BC%88Low-Level-Builder%EF%BC%89"><span class="toc-number">8.19.4.1.</span> <span class="toc-text">LLB（Low-Level Builder）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB"><span class="toc-number">8.19.4.2.</span> <span class="toc-text">前端和后端分离</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">8.19.5.</span> <span class="toc-text">实际应用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="toc-number">8.19.6.</span> <span class="toc-text">性能优化技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">8.19.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98"><span class="toc-number">8.20.</span> <span class="toc-text">构建缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E8%A7%84%E5%88%99"><span class="toc-number">8.20.1.</span> <span class="toc-text">核心缓存命中规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%86%85%E5%AE%B9%E5%AE%8C%E5%85%A8%E5%8C%B9%E9%85%8D"><span class="toc-number">8.20.1.1.</span> <span class="toc-text">指令内容完全匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E5%B1%82%E7%BC%93%E5%AD%98%E7%8A%B6%E6%80%81"><span class="toc-number">8.20.1.2.</span> <span class="toc-text">父层缓存状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%93%E5%AD%98%E8%A7%84%E5%88%99%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.20.2.</span> <span class="toc-text">不同指令的缓存规则详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FROM-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.20.2.1.</span> <span class="toc-text">FROM 指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RUN-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.20.2.2.</span> <span class="toc-text">RUN 指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#COPY-ADD-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.20.2.3.</span> <span class="toc-text">COPY&#x2F;ADD 指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ENV-ARG-LABEL-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.20.2.4.</span> <span class="toc-text">ENV&#x2F;ARG&#x2F;LABEL 指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WORKDIR-USER-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.20.2.5.</span> <span class="toc-text">WORKDIR&#x2F;USER 指令</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">8.20.3.</span> <span class="toc-text">缓存优化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-1%EF%BC%9A%E5%88%A9%E7%94%A8-Dockerfile-%E6%8C%87%E4%BB%A4%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.20.3.1.</span> <span class="toc-text">策略 1：利用 Dockerfile 指令顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-2%EF%BC%9A%E5%90%88%E5%B9%B6%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-number">8.20.3.2.</span> <span class="toc-text">策略 2：合并相关指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-3%EF%BC%9A%E4%BD%BF%E7%94%A8-dockerignore"><span class="toc-number">8.20.3.3.</span> <span class="toc-text">策略 3：使用 .dockerignore</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5-4%EF%BC%9A%E5%9B%BA%E5%AE%9A%E7%89%88%E6%9C%AC%E5%92%8C%E6%91%98%E8%A6%81"><span class="toc-number">8.20.3.4.</span> <span class="toc-text">策略 4：固定版本和摘要</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="toc-number">8.20.4.</span> <span class="toc-text">缓存调试技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E6%83%85%E5%86%B5"><span class="toc-number">8.20.4.1.</span> <span class="toc-text">查看缓存命中情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%B1%82%E6%91%98%E8%A6%81"><span class="toc-number">8.20.4.2.</span> <span class="toc-text">检查层摘要</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E9%87%8D%E5%BB%BA%E7%89%B9%E5%AE%9A%E5%B1%82"><span class="toc-number">8.20.4.3.</span> <span class="toc-text">强制重建特定层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%9A%84%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.20.5.</span> <span class="toc-text">特殊情况的缓存行为</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ADD-%E6%8C%87%E4%BB%A4%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">8.20.5.1.</span> <span class="toc-text">ADD 指令的特殊性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0%EF%BC%88ARG%EF%BC%89%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">8.20.5.2.</span> <span class="toc-text">构建参数（ARG）的影响</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E6%9B%B4%E6%96%B0"><span class="toc-number">8.20.5.3.</span> <span class="toc-text">外部基础镜像更新</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BuildKit-%E7%9A%84%E7%BC%93%E5%AD%98%E6%94%B9%E8%BF%9B"><span class="toc-number">8.20.6.</span> <span class="toc-text">BuildKit 的缓存改进</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98%EF%BC%88Inline-Cache%EF%BC%89"><span class="toc-number">8.20.6.1.</span> <span class="toc-text">内联缓存（Inline Cache）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%BC%93%E5%AD%98%E5%90%8E%E7%AB%AF"><span class="toc-number">8.20.6.2.</span> <span class="toc-text">外部缓存后端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%8C%82%E8%BD%BD"><span class="toc-number">8.20.6.3.</span> <span class="toc-text">缓存挂载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">8.20.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-number">9.</span> <span class="toc-text">高级网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">9.1.</span> <span class="toc-text">Docker 网络相关的命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">9.2.</span> <span class="toc-text">容器访问控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C"><span class="toc-number">9.2.1.</span> <span class="toc-text">容器访问外部网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BF%E9%97%AE"><span class="toc-number">9.2.2.</span> <span class="toc-text">容器之间访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%A2%B3%E7%90%86"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">核心概念梳理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E6%89%80%E6%9C%89%E5%AE%B9%E5%99%A8%E9%97%B4%E8%AE%BF%E9%97%AE%EF%BC%88%E9%BB%98%E8%AE%A4%E6%A8%A1%E5%BC%8F%EF%BC%8C-icc-true%EF%BC%89"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">允许所有容器间访问（默认模式，--icc&#x3D;true）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E7%A6%81%E6%AD%A2%E5%AE%B9%E5%99%A8%E9%97%B4%E8%AE%BF%E9%97%AE%EF%BC%88-icc-false%EF%BC%89"><span class="toc-number">9.2.2.3.</span> <span class="toc-text">完全禁止容器间访问（--icc&#x3D;false）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-link-%E5%85%81%E8%AE%B8%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E9%97%B4%E8%AE%BF%E9%97%AE%EF%BC%88%E7%99%BD%E5%90%8D%E5%8D%95%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">9.2.2.4.</span> <span class="toc-text">通过 --link 允许特定容器间访问（白名单方式）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E5%88%B0%E5%AE%BF%E4%B8%BB%E4%B8%BB%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.</span> <span class="toc-text">映射容器端口到宿主主机的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.1.</span> <span class="toc-text">容器访问外部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.2.</span> <span class="toc-text">外部访问容器实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%A1%A5"><span class="toc-number">9.4.</span> <span class="toc-text">自定义网桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">9.5.</span> <span class="toc-text">编辑网络配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%82%B9%E5%88%B0%E7%82%B9%E8%BF%9E%E6%8E%A5"><span class="toc-number">9.6.</span> <span class="toc-text">示例：创建一个点到点连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A"><span class="toc-number">9.6.1.</span> <span class="toc-text">命令解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-Docker-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.6.2.</span> <span class="toc-text">与 Docker 的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">10.</span> <span class="toc-text">安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">10.1.</span> <span class="toc-text">内核命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%84"><span class="toc-number">10.2.</span> <span class="toc-text">控制组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E9%98%B2%E6%8A%A4"><span class="toc-number">10.3.</span> <span class="toc-text">Docker服务端的防护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E8%83%BD%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">10.4.</span> <span class="toc-text">内核能力机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7"><span class="toc-number">10.5.</span> <span class="toc-text">其它安全特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">10.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.</span> <span class="toc-text">底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84"><span class="toc-number">11.1.</span> <span class="toc-text">基本架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">11.2.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PID-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88Process-ID%EF%BC%89"><span class="toc-number">11.2.1.</span> <span class="toc-text">PID 命名空间（Process ID）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NET-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88Network%EF%BC%89"><span class="toc-number">11.2.2.</span> <span class="toc-text">NET 命名空间（Network）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPC-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88Inter-Process-Communication%EF%BC%89"><span class="toc-number">11.2.3.</span> <span class="toc-text">IPC 命名空间（Inter-Process Communication）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MNT-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88Mount%EF%BC%89"><span class="toc-number">11.2.4.</span> <span class="toc-text">MNT 命名空间（Mount）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UTS-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88UNIX-Time-sharing-System%EF%BC%89"><span class="toc-number">11.2.5.</span> <span class="toc-text">UTS 命名空间（UNIX Time-sharing System）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#USER-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88User%EF%BC%89"><span class="toc-number">11.2.6.</span> <span class="toc-text">USER 命名空间（User）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%9C%A8-Docker-%E4%B8%AD%E7%9A%84%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-number">11.2.7.</span> <span class="toc-text">命名空间在 Docker 中的综合应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">11.2.8.</span> <span class="toc-text">查看命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">11.2.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%84-1"><span class="toc-number">11.3.</span> <span class="toc-text">控制组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">11.4.</span> <span class="toc-text">联合文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.5.</span> <span class="toc-text">容器格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.6.</span> <span class="toc-text">Docker 网络实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">11.6.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E6%97%B6%E7%9A%84%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C"><span class="toc-number">11.6.2.</span> <span class="toc-text">Docker 创建容器时的网络操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.6.3.</span> <span class="toc-text">四种网络模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%BC%94%E7%A4%BA"><span class="toc-number">11.6.4.</span> <span class="toc-text">手动网络配置演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">11.6.5.</span> <span class="toc-text">关键概念深度解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3-Docker-%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">11.6.6.</span> <span class="toc-text">现代 Docker 的改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Etcd"><span class="toc-number">12.</span> <span class="toc-text">Etcd</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D%EF%BC%9A"><span class="toc-number">12.1.</span> <span class="toc-text">核心定位：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%81%E5%9C%A8%E4%BD%BF%E7%94%A8-etcd%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">谁在使用 etcd？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#etcd-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">12.3.</span> <span class="toc-text">etcd 的核心特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">12.3.1.</span> <span class="toc-text">高可用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8F%AF%E9%9D%A0%E7%9A%84-API"><span class="toc-number">12.3.2.</span> <span class="toc-text">简单可靠的 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">12.3.3.</span> <span class="toc-text">安全性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#etcd-%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">12.4.</span> <span class="toc-text">etcd 的架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-number">12.4.1.</span> <span class="toc-text">核心组件：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.5.</span> <span class="toc-text">数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%EF%BC%9A"><span class="toc-number">12.5.1.</span> <span class="toc-text">键值存储：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">12.5.2.</span> <span class="toc-text">键的设计原则：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-API-%E6%93%8D%E4%BD%9C"><span class="toc-number">12.6.</span> <span class="toc-text">核心 API 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%94%AE%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">12.6.1.</span> <span class="toc-text">基本的键值操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">12.6.1.1.</span> <span class="toc-text">写入数据：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">12.6.1.2.</span> <span class="toc-text">读取数据：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">12.6.1.3.</span> <span class="toc-text">删除数据：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Watch%EF%BC%88%E7%9B%91%E5%90%AC%EF%BC%89%E5%8A%9F%E8%83%BD"><span class="toc-number">12.6.2.</span> <span class="toc-text">Watch（监听）功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%9F%E7%BA%A6%EF%BC%88Lease%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">12.6.3.</span> <span class="toc-text">租约（Lease）机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">12.7.</span> <span class="toc-text">实际应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Kubernetes-%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E4%BD%9C%E7%94%A8"><span class="toc-number">12.8.</span> <span class="toc-text">在 Kubernetes 中的关键作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes-%E5%9C%A8-etcd-%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">12.8.1.</span> <span class="toc-text">Kubernetes 在 etcd 中存储的数据：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2"><span class="toc-number">12.9.</span> <span class="toc-text">安装和部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E5%92%8C%E7%9B%91%E6%8E%A7"><span class="toc-number">12.10.</span> <span class="toc-text">运维和监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">12.11.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">12.12.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fedora-CoreOS"><span class="toc-number">13.</span> <span class="toc-text">Fedora CoreOS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D%EF%BC%9A-1"><span class="toc-number">13.1.</span> <span class="toc-text">核心定位：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CoreOS-%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2"><span class="toc-number">13.2.</span> <span class="toc-text">CoreOS 的演进历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-number">13.3.</span> <span class="toc-text">核心特性详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%EF%BC%88Immutable-Infrastructure%EF%BC%89"><span class="toc-number">13.3.1.</span> <span class="toc-text">不可变基础设施（Immutable Infrastructure）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%EF%BC%88rpm-ostree%EF%BC%89"><span class="toc-number">13.3.2.</span> <span class="toc-text">自动原子更新（rpm-ostree）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%EF%BC%88Ignition%EF%BC%89"><span class="toc-number">13.3.3.</span> <span class="toc-text">声明式系统配置（Ignition）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%94%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">13.3.4.</span> <span class="toc-text">容器原生设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="toc-number">13.4.</span> <span class="toc-text">架构组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%A0%88%EF%BC%9A"><span class="toc-number">13.4.1.</span> <span class="toc-text">核心组件栈：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E9%83%A8%E7%BD%B2-1"><span class="toc-number">13.5.</span> <span class="toc-text">安装和部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.6.</span> <span class="toc-text">实际使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F-Linux-%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">13.7.</span> <span class="toc-text">与传统 Linux 发行版的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86"><span class="toc-number">13.8.</span> <span class="toc-text">运维管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1"><span class="toc-number">13.9.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">13.10.</span> <span class="toc-text">与相关技术的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-number">13.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Podman"><span class="toc-number">14.</span> <span class="toc-text">Podman</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D%EF%BC%9A-2"><span class="toc-number">14.1.</span> <span class="toc-text">核心定位：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Podman-%E4%B8%8E-Docker-%E7%9A%84%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">14.2.</span> <span class="toc-text">Podman 与 Docker 的架构对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3-1"><span class="toc-number">14.3.</span> <span class="toc-text">核心特性详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84%EF%BC%88Daemonless%EF%BC%89"><span class="toc-number">14.3.1.</span> <span class="toc-text">无守护进程架构（Daemonless）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rootless-%E5%AE%B9%E5%99%A8"><span class="toc-number">14.3.2.</span> <span class="toc-text">Rootless 容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pod-%E6%94%AF%E6%8C%81"><span class="toc-number">14.3.3.</span> <span class="toc-text">Pod 支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Systemd-%E9%9B%86%E6%88%90"><span class="toc-number">14.3.4.</span> <span class="toc-text">Systemd 集成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">14.4.</span> <span class="toc-text">基本使用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD-1"><span class="toc-number">14.5.</span> <span class="toc-text">高级功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Podman-Machine%EF%BC%88macOS-Windows%EF%BC%89"><span class="toc-number">14.5.1.</span> <span class="toc-text">Podman Machine（macOS&#x2F;Windows）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">14.5.2.</span> <span class="toc-text">容器健康检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">14.5.3.</span> <span class="toc-text">容器资源限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7"><span class="toc-number">14.5.4.</span> <span class="toc-text">容器安全特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">14.6.</span> <span class="toc-text">实际应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-Docker-%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">14.7.</span> <span class="toc-text">与 Docker 的兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7"><span class="toc-number">14.8.</span> <span class="toc-text">生态系统工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buildah"><span class="toc-number">14.8.1.</span> <span class="toc-text">Buildah</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Skopeo"><span class="toc-number">14.8.2.</span> <span class="toc-text">Skopeo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CRI-O"><span class="toc-number">14.8.3.</span> <span class="toc-text">CRI-O</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">14.9.</span> <span class="toc-text">性能比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97"><span class="toc-number">14.10.</span> <span class="toc-text">迁移指南</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-Docker-%E8%BF%81%E7%A7%BB%E5%88%B0-Podman%EF%BC%9A"><span class="toc-number">14.10.1.</span> <span class="toc-text">从 Docker 迁移到 Podman：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-number">14.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">15.</span> <span class="toc-text">常见问题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3"><span class="toc-number">15.1.</span> <span class="toc-text">镜像相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%B8%85%E7%90%86%E4%B8%B4%E6%97%B6%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="toc-number">15.1.1.</span> <span class="toc-text">如何批量清理临时镜像文件？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E6%94%AF%E6%8C%81%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="toc-number">15.1.2.</span> <span class="toc-text">如何查看镜像支持的环境变量？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%9A%84%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E9%83%BD%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">15.1.3.</span> <span class="toc-text">本地的镜像文件都存放在哪里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-Docker-%E9%95%9C%E5%83%8F%E5%BA%94%E8%AF%A5%E9%81%B5%E5%BE%AA%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">15.1.4.</span> <span class="toc-text">构建 Docker 镜像应该遵循哪些原则？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%B0%E5%88%B0%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%EF%BC%8C%E6%97%A0%E6%B3%95-pull-%E9%95%9C%E5%83%8F%EF%BC%8C%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8C%87%E5%AE%9A-http-proxy-%E6%97%A0%E6%95%88%EF%BC%9F"><span class="toc-number">15.1.5.</span> <span class="toc-text">碰到网络问题，无法 pull 镜像，命令行指定 http_proxy 无效？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">15.2.</span> <span class="toc-text">容器相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%80%E5%87%BA%E5%90%8E%EF%BC%8C%E9%80%9A%E8%BF%87-docker-container-ls-%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E4%B8%8D%E5%88%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E4%B9%88%EF%BC%9F"><span class="toc-number">15.2.1.</span> <span class="toc-text">容器退出后，通过 docker container ls 命令查看不到，数据会丢失么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E6%89%80%E6%9C%89%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-number">15.2.2.</span> <span class="toc-text">如何停止所有正在运行的容器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E6%B8%85%E7%90%86%E5%B7%B2%E7%BB%8F%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-number">15.2.3.</span> <span class="toc-text">如何批量清理已经停止的容器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84-PID-%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">15.2.4.</span> <span class="toc-text">如何获取某个容器的 PID 信息？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84-IP-%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">15.3.</span> <span class="toc-text">如何获取某个容器的 IP 地址？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99%E5%AE%B9%E5%99%A8%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A-IP-%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%AF%8F%E6%AC%A1%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8-IP-%E5%9C%B0%E5%9D%80%E9%83%BD%E4%BC%9A%E5%8F%98%EF%BC%9F"><span class="toc-number">15.3.1.</span> <span class="toc-text">如何给容器指定一个固定 IP 地址，而不是每次重启容器 IP 地址都会变？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%B8%B4%E6%97%B6%E9%80%80%E5%87%BA%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E4%BA%A4%E4%BA%92%E7%9A%84%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BB%88%E7%AB%AF%EF%BC%8C%E8%80%8C%E4%B8%8D%E7%BB%88%E6%AD%A2%E5%AE%83%EF%BC%9F"><span class="toc-number">15.3.2.</span> <span class="toc-text">如何临时退出一个正在交互的容器的终端，而不终止它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-docker-port-%E5%91%BD%E4%BB%A4%E6%98%A0%E5%B0%84%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E6%8A%A5%E9%94%99%E2%80%9CError-No-public-port-%E2%80%9880%E2%80%99-published-for-xxx%E2%80%9D%EF%BC%9F"><span class="toc-number">15.3.3.</span> <span class="toc-text">使用 docker port 命令映射容器的端口时，系统报错“Error: No public port ‘80’ published for xxx”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E4%B9%88%EF%BC%9F"><span class="toc-number">15.3.4.</span> <span class="toc-text">可以在一个容器中同时运行多个应用进程么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%AE%B9%E5%99%A8%E5%8D%A0%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%EF%BC%88CPU%E3%80%81%E5%86%85%E5%AD%98%EF%BC%89%E7%9A%84%E4%BB%BD%E9%A2%9D%EF%BC%9F"><span class="toc-number">15.3.5.</span> <span class="toc-text">如何控制容器占用系统资源（CPU、内存）的份额？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%E7%9B%B8%E5%85%B3"><span class="toc-number">15.4.</span> <span class="toc-text">仓库相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%93%E5%BA%93%EF%BC%88Repository%EF%BC%89%E3%80%81%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Registry%EF%BC%89%E3%80%81%E6%B3%A8%E5%86%8C%E7%B4%A2%E5%BC%95%EF%BC%88Index%EF%BC%89-%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">15.4.1.</span> <span class="toc-text">仓库（Repository）、注册服务器（Registry）、注册索引（Index） 有何关系？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3"><span class="toc-number">15.5.</span> <span class="toc-text">配置相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">15.5.1.</span> <span class="toc-text">Docker 的配置文件放在哪里，如何修改配置？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9-Docker-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">15.6.</span> <span class="toc-text">如何更改 Docker 的默认存储位置？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%92%8C-swap-%E9%99%90%E5%88%B6%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E6%97%B6%E5%80%99%E6%8A%A5%E8%AD%A6%E5%91%8A%EF%BC%9A%E2%80%9DWARNING-Your-kernel-does-not-support-cgroup-swap-limit-WARNING-Your-kernel-does-not-support-swap-limit-capabilities-Limitation-discarded-%E2%80%9D%EF%BC%9F"><span class="toc-number">15.6.1.</span> <span class="toc-text">使用内存和 swap 限制启动容器时候报警告：”WARNING: Your kernel does not support cgroup swap limit. WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.”？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">15.7.</span> <span class="toc-text">Docker 与虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E4%B8%8E-LXC%EF%BC%88Linux-Container%EF%BC%89%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">15.7.1.</span> <span class="toc-text">Docker 与 LXC（Linux Container）有何不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E4%B8%8E-Vagrant-%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">15.7.2.</span> <span class="toc-text">Docker 与 Vagrant 有何不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD-Docker-%E5%92%8C-Vagrant-%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">15.7.3.</span> <span class="toc-text">开发环境中 Docker 和 Vagrant 该如何选择？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">15.8.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E8%83%BD%E5%9C%A8%E9%9D%9E-Linux-%E5%B9%B3%E5%8F%B0%EF%BC%88%E6%AF%94%E5%A6%82-Windows-%E6%88%96-macOS-%EF%BC%89%E4%B8%8A%E8%BF%90%E8%A1%8C%E4%B9%88%EF%BC%9F"><span class="toc-number">15.8.1.</span> <span class="toc-text">Docker 能在非 Linux 平台（比如 Windows 或 macOS ）上运行么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E5%8F%B0%E5%AE%BF%E4%B8%BB%E4%B8%BB%E6%9C%BA%E7%9A%84-Docker-%E7%8E%AF%E5%A2%83%E8%BF%81%E7%A7%BB%E5%88%B0%E5%8F%A6%E5%A4%96%E4%B8%80%E5%8F%B0%E5%AE%BF%E4%B8%BB%E4%B8%BB%E6%9C%BA%EF%BC%9F"><span class="toc-number">15.8.2.</span> <span class="toc-text">如何将一台宿主主机的 Docker 环境迁移到另外一台宿主主机？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5-Docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="toc-number">15.8.3.</span> <span class="toc-text">如何进入 Docker 容器的网络命名空间？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E7%BB%91%E5%AE%9A%E5%88%B0%E6%9C%AC%E5%9C%B0%E9%82%A3%E4%B8%AA-veth-%E6%8E%A5%E5%8F%A3%E4%B8%8A%EF%BC%9F"><span class="toc-number">15.8.4.</span> <span class="toc-text">如何获取容器绑定到本地那个 veth 接口上？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E5%91%BD%E4%BB%A4"><span class="toc-number">16.</span> <span class="toc-text">Docker 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">16.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4-docker"><span class="toc-number">16.2.</span> <span class="toc-text">客户端命令(docker)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">16.2.1.</span> <span class="toc-text">客户端命令选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4"><span class="toc-number">16.2.2.</span> <span class="toc-text">客户端命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%80%BB%E7%BB%93-Docker-%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">16.2.3.</span> <span class="toc-text">一张图总结 Docker 的命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">16.2.4.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%91%BD%E4%BB%A4-dockerd"><span class="toc-number">16.3.</span> <span class="toc-text">服务端命令(dockerd)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerd-%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9"><span class="toc-number">16.3.1.</span> <span class="toc-text">dockerd 命令选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83-1"><span class="toc-number">16.3.2.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">17.</span> <span class="toc-text">Dockerfile 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%80%A7%E7%9A%84%E6%8C%87%E5%8D%97%E5%92%8C%E5%BB%BA%E8%AE%AE"><span class="toc-number">17.1.</span> <span class="toc-text">一般性的指南和建议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%94%E8%AF%A5%E6%98%AF%E7%9F%AD%E6%9A%82%E7%9A%84"><span class="toc-number">17.1.1.</span> <span class="toc-text">容器应该是短暂的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-dockerignore-%E6%96%87%E4%BB%B6"><span class="toc-number">17.1.2.</span> <span class="toc-text">使用 .dockerignore 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA-1"><span class="toc-number">17.1.3.</span> <span class="toc-text">使用多阶段构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AE%89%E8%A3%85%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%8C%85"><span class="toc-number">17.1.4.</span> <span class="toc-text">避免安装不必要的包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%8F%AA%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">17.1.5.</span> <span class="toc-text">一个容器只运行一个进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%B1%82%E6%95%B0%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%B0%91"><span class="toc-number">17.1.6.</span> <span class="toc-text">镜像层数尽可能少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%A4%9A%E8%A1%8C%E5%8F%82%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">17.1.7.</span> <span class="toc-text">将多行参数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98-1"><span class="toc-number">17.1.8.</span> <span class="toc-text">构建缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-%E6%8C%87%E4%BB%A4"><span class="toc-number">17.2.</span> <span class="toc-text">Dockerfile 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FROM"><span class="toc-number">17.2.1.</span> <span class="toc-text">FROM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LABEL"><span class="toc-number">17.2.2.</span> <span class="toc-text">LABEL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RUN"><span class="toc-number">17.2.3.</span> <span class="toc-text">RUN</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#apt-get"><span class="toc-number">17.2.3.1.</span> <span class="toc-text">apt-get</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMD"><span class="toc-number">17.2.4.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXPOSE"><span class="toc-number">17.2.5.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENV"><span class="toc-number">17.2.6.</span> <span class="toc-text">ENV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADD-%E5%92%8C-COPY"><span class="toc-number">17.2.7.</span> <span class="toc-text">ADD 和 COPY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">17.2.8.</span> <span class="toc-text">ENTRYPOINT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VOLUME"><span class="toc-number">17.2.9.</span> <span class="toc-text">VOLUME</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#USER"><span class="toc-number">17.2.10.</span> <span class="toc-text">USER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WORKDIR"><span class="toc-number">17.2.11.</span> <span class="toc-text">WORKDIR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">17.3.</span> <span class="toc-text">官方镜像示例</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/" title="Kubernetes学习">Kubernetes学习</a><time datetime="2025-10-13T06:30:41.000Z" title="发表于 2025-10-13 14:30:41">2025-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/24/Docker-Compose%E3%80%81Docker-Swarm-%E4%B8%8E-Kubernetes-K8s-%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Docker Compose、Docker Swarm 与 Kubernetes (K8s) 的区别">Docker Compose、Docker Swarm 与 Kubernetes (K8s) 的区别</a><time datetime="2025-09-24T07:05:21.000Z" title="发表于 2025-09-24 15:05:21">2025-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/" title="Docker学习">Docker学习</a><time datetime="2025-09-02T08:18:48.000Z" title="发表于 2025-09-02 16:18:48">2025-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/15/js%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="js数组与字符串的方法总结">js数组与字符串的方法总结</a><time datetime="2025-08-15T10:25:58.000Z" title="发表于 2025-08-15 18:25:58">2025-08-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/13/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="go语言学习">go语言学习</a><time datetime="2025-08-13T03:08:23.000Z" title="发表于 2025-08-13 11:08:23">2025-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By South</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>