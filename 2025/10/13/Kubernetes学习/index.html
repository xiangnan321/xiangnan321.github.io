<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kubernetes学习 | Hi</title><meta name="author" content="South"><meta name="copyright" content="South"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="阅读 Kubernetes 官方文档 的整理与总结。 概述Kubernetes 也称为 K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统。 Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。 Kubernetes 这个名字源于希腊语，意">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes学习">
<meta property="og:url" content="https://xiangnan321.github.io/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hi">
<meta property="og:description" content="阅读 Kubernetes 官方文档 的整理与总结。 概述Kubernetes 也称为 K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统。 Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。 Kubernetes 这个名字源于希腊语，意">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiangnan321.github.io/image/avatar.png">
<meta property="article:published_time" content="2025-10-13T06:30:41.000Z">
<meta property="article:modified_time" content="2025-10-14T03:45:30.602Z">
<meta property="article:author" content="South">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiangnan321.github.io/image/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes学习",
  "url": "https://xiangnan321.github.io/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/",
  "image": "https://xiangnan321.github.io/image/avatar.png",
  "datePublished": "2025-10-13T06:30:41.000Z",
  "dateModified": "2025-10-14T03:45:30.602Z",
  "author": [
    {
      "@type": "Person",
      "name": "South",
      "url": "https://xiangnan321.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/image/logo.png"><link rel="canonical" href="https://xiangnan321.github.io/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: South","link":"链接: ","source":"来源: Hi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'medium_zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/styles.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/logo.png" alt="Logo"><span class="site-name">Hi</span></a><a class="nav-page-title" href="/"><span class="site-name">Kubernetes学习</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Kubernetes学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-13T06:30:41.000Z" title="发表于 2025-10-13 14:30:41">2025-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-14T03:45:30.602Z" title="更新于 2025-10-14 11:45:30">2025-10-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>阅读 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/">Kubernetes 官方文档</a> 的整理与总结。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Kubernetes 也称为 K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统。</p>
<p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。</p>
<p><strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。K8s 这个缩写是因为 K 和 s 之间有 8 个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 Google 大规模运行生产工作负载十几年经验的基础上， 结合了社区中最优秀的想法和实践。</p>
<h3 id="k8s-作用"><a href="#k8s-作用" class="headerlink" title="k8s 作用"></a>k8s 作用</h3><p>Kubernetes 提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足扩展要求、故障转移应用、提供部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary (金丝雀) 部署。</p>
<p>Kubernetes 提供：</p>
<ul>
<li><strong>服务发现和负载均衡</strong><br>Kubernetes 可以使用 DNS 名称或自己的 IP 地址来暴露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</li>
<li><strong>存储编排</strong><br>Kubernetes 允许自动挂载任何选择的存储系统，例如本地存储、公共云提供商等。</li>
<li><strong>自动部署和回滚</strong><br>可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，自动化 Kubernetes 来部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</li>
<li><strong>自动完成装箱计算</strong><br>为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到节点上，以最佳方式利用资源。</li>
<li><strong>自我修复</strong><br>Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。</li>
<li><strong>密钥与配置管理</strong><br>Kubernetes 允许存储和管理敏感信息，例如密码、OAuth 令牌和 SSH 密钥。 可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。</li>
<li><strong>批处理执行</strong> 除了服务外，Kubernetes 还可以管理批处理和 CI（持续集成）工作负载，如有需要，可以替换失败的容器。</li>
<li><strong>水平扩缩</strong> 使用简单的命令、用户界面或根据 CPU 使用率自动对应用进行扩缩。</li>
<li><strong>IPv4&#x2F;IPv6 双栈</strong> 为 Pod（容器组）和 Service（服务）分配 IPv4 和 IPv6 地址。</li>
<li><strong>为可扩展性设计</strong> 在不改变上游源代码的情况下为 Kubernetes 集群添加功能。</li>
</ul>
<h3 id="Kubernetes-不是什么"><a href="#Kubernetes-不是什么" class="headerlink" title="Kubernetes 不是什么"></a>Kubernetes 不是什么</h3><p>Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 是在容器级别运行，而非在硬件级别，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡，允许用户集成他们的日志记录、监控和警报方案。 但是，Kubernetes 不是单体式（monolithic）系统，那些默认解决方案都是可选、可插拔的。 Kubernetes 为构建开发人员平台提供了基础，但是在重要的地方保留了用户选择权，能有更高的灵活性。</p>
<p><strong>Kubernetes：</strong></p>
<ul>
<li>不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。</li>
<li>不部署源代码，也不构建应用程序。 持续集成（CI）、交付和部署（CI&#x2F;CD）工作流取决于组织的文化和偏好以及技术要求。</li>
<li>不提供应用程序级别的服务作为内置服务，例如中间件（例如消息中间件）、 数据处理框架（例如 Spark）、数据库（例如 MySQL）、缓存、集群存储系统 （例如 Ceph）。这样的组件可以在 Kubernetes 上运行，并且&#x2F;或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如<a target="_blank" rel="noopener" href="https://www.openservicebrokerapi.org/">开放服务代理</a>）来访问。</li>
<li>不是日志记录、监视或警报的解决方案。 它集成了一些功能作为概念证明，并提供了收集和导出指标的机制。</li>
<li>不提供也不要求配置用的语言、系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。</li>
<li>不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。</li>
<li>此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 而 Kubernetes 包含了一组独立可组合的控制过程，可以持续地将当前状态驱动到所提供的预期状态。 用户不需要在乎如何从 A 移动到 C，也不需要集中控制，这使得系统更易于使用且功能更强大、 系统更健壮，更为弹性和可扩展。</li>
</ul>
<h3 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h3><p><img src="/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/img-01.svg" alt="Kubernetes 集群的组件"></p>
<h3 id="Kubernetes-对象"><a href="#Kubernetes-对象" class="headerlink" title="Kubernetes 对象"></a>Kubernetes 对象</h3><p>在 Kubernetes 系统中，<strong>Kubernetes 对象</strong>是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。 具体而言，它们描述了如下信息：</p>
<ul>
<li>哪些容器化应用正在运行（以及在哪些节点上运行）</li>
<li>可以被应用使用的资源</li>
<li>关于应用运行时行为的策略，比如重启策略、升级策略以及容错策略</li>
</ul>
<p>Kubernetes 对象是一种“意向表达（Record of Intent）”。一旦创建该对象， Kubernetes 系统将不断工作以确保该对象存在。通过创建对象，本质上是在告知 Kubernetes 系统，想要的集群工作负载状态看起来应是什么样子的， 这就是 Kubernetes 集群所谓的<strong>期望状态（Desired State）</strong>。</p>
<p>操作 Kubernetes 对象 —— 无论是创建、修改或者删除 —— 需要使用 Kubernetes API。 比如，当使用 <code>kubectl</code> 命令行接口（CLI）时，CLI 会调用必要的 Kubernetes API； 也可以在程序中使用<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/">客户端库</a>， 来直接调用 Kubernetes API。</p>
<h4 id="对象规约（Spec）与状态（Status）"><a href="#对象规约（Spec）与状态（Status）" class="headerlink" title="对象规约（Spec）与状态（Status）"></a>对象规约（Spec）与状态（Status）</h4><p>几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 <strong><code>spec</code>（规约）</strong> 和对象 <strong><code>status</code>（状态）</strong>。 对于具有 <code>spec</code> 的对象，必须在创建对象时设置其内容，描述希望对象所具有的特征： <strong>期望状态（Desired State）</strong>。</p>
<p><code>status</code> 描述了对象的<strong>当前状态（Current State）</strong>，它是由 Kubernetes 系统和组件设置并更新的。在任何时刻，Kubernetes 控制平面 都一直在积极地管理着对象的实际状态，以使之达成期望状态。</p>
<p>例如，Kubernetes 中的 Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，可能会设置 Deployment 的 <code>spec</code>，指定该应用要有 3 个副本运行。 Kubernetes 系统读取 Deployment 的 <code>spec</code>， 并启动所期望的应用的 3 个实例 —— 更新状态以与规约相匹配。 如果这些实例中有的失败了（一种状态变更），Kubernetes 系统会通过执行修正操作来响应 <code>spec</code> 和 <code>status</code> 间的不一致 —— 意味着它会启动一个新的实例来替换。</p>
<h4 id="描述-Kubernetes-对象"><a href="#描述-Kubernetes-对象" class="headerlink" title="描述 Kubernetes 对象"></a>描述 Kubernetes 对象</h4><p>创建 Kubernetes 对象时，必须提供对象的 <code>spec</code>，用来描述该对象的期望状态， 以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（直接创建或经由 <code>kubectl</code> 创建）， API 请求必须在请求主体中包含 JSON 格式的信息。 大多数情况下，会通过 <strong>清单（Manifest）</strong> 文件为 <code>kubectl</code> 提供这些信息。 按照惯例，清单是 YAML 格式的（也可以使用 JSON 格式）。 像 <code>kubectl</code> 这样的工具在通过 HTTP 进行 API 请求时， 会将清单中的信息转换为 JSON 或其他受支持的序列化格式。</p>
<p>这里有一个清单示例文件，展示了 Kubernetes Deployment 的必需字段和对象 <code>spec</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>   <span class="comment"># Kubernetes API 版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      <span class="comment"># 资源类型：部署控制器</span></span><br><span class="line"><span class="attr">metadata:</span>             <span class="comment"># 元数据部分</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span> <span class="comment"># Deployment 名称</span></span><br><span class="line"><span class="attr">spec:</span>                 <span class="comment"># 描述对象期望状态</span></span><br><span class="line">  <span class="attr">selector:</span>           <span class="comment"># 匹配标签选择器</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># 匹配标签</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>      <span class="comment"># 匹配所有带有标签 app: nginx 的 Pod。这是连接 Deployment 和 Pod 的桥梁</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span>         <span class="comment"># 告诉部署运行 2 个与模板匹配的 pod</span></span><br><span class="line">  <span class="attr">template:</span>           <span class="comment"># 描述 Pod 的模板</span></span><br><span class="line">    <span class="attr">metadata:</span>         <span class="comment"># Pod 元数据</span></span><br><span class="line">      <span class="attr">labels:</span>         <span class="comment"># Pod 标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span>    <span class="comment"># Pod 匹配标签 app: nginx。这个标签必须与上面的 selector.matchLabels 一致</span></span><br><span class="line">    <span class="attr">spec:</span>             <span class="comment"># Pod 描述</span></span><br><span class="line">      <span class="attr">containers:</span>     <span class="comment"># Pod 中包含的容器列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>   <span class="comment"># 容器名称</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span> <span class="comment"># 使用的 Docker 镜像</span></span><br><span class="line">        <span class="attr">ports:</span>        <span class="comment"># 容器端口</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 容器暴露的端口</span></span><br></pre></td></tr></table></figure>
<p>与上面使用清单文件来创建 Deployment 类似，另一种方式是使用 <code>kubectl</code> 命令行接口（CLI）的 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply"><code>kubectl apply</code></a> 命令， 将 <code>.yaml</code> 文件作为参数。下面是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/deployment.yaml</span><br></pre></td></tr></table></figure>
<p>输出类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deployment.apps/nginx-deployment created</span><br></pre></td></tr></table></figure>

<p>工作流程：<br><img src="/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/img-02.svg" alt="yaml工作流程"></p>
<h4 id="必需字段"><a href="#必需字段" class="headerlink" title="必需字段"></a>必需字段</h4><p>在想要创建的 Kubernetes 对象所对应的清单（YAML 或 JSON 文件）中，需要配置的字段如下：</p>
<ul>
<li><code>apiVersion</code> - 创建该对象所使用的 Kubernetes API 的版本</li>
<li><code>kind</code> - 想要创建的对象的类别</li>
<li><code>metadata</code> - 帮助唯一标识对象的一些数据，包括一个 name 字符串、UID 和可选的 namespace</li>
<li><code>spec</code> - 所期望的该对象的状态<br>对每个 Kubernetes 对象而言，其 <code>spec</code> 之精确格式都是不同的，包含了特定于该对象的嵌套字段。</li>
</ul>
<p>例如，参阅 Pod API 参考文档中 <code>spec</code> 字段。 对于每个 Pod，其 <code>.spec</code> 字段设置了 Pod 及其期望状态（例如 Pod 中每个容器的容器镜像名称）。 另一个对象规约的例子是 StatefulSet API 中的 <code>spec</code> 字段。 对于 StatefulSet 而言，其 <code>.spec</code> 字段设置了 StatefulSet 及其期望状态。 在 StatefulSet 的 <code>.spec</code> 内，有一个为 Pod 对象提供的模板。 该模板描述了 StatefulSet 控制器为了满足 StatefulSet 规约而要创建的 Pod。 不同类型的对象可以有不同的 <code>.status</code> 信息。API 参考页面给出了 <code>.status</code> 字段的详细结构， 以及针对不同类型 API 对象的具体内容。</p>
<h4 id="服务器端字段验证"><a href="#服务器端字段验证" class="headerlink" title="服务器端字段验证"></a>服务器端字段验证</h4><p>从 Kubernetes v1.25 开始，API 服务器提供了服务器端<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/using-api/api-concepts/#field-validation">字段验证</a>， 可以检测对象中未被识别或重复的字段。它在服务器端提供了 <code>kubectl --validate</code> 的所有功能。</p>
<p><code>kubectl</code> 工具使用 <code>--validate</code> 标志来设置字段验证级别。它接受值 <code>ignore</code>、<code>warn</code> 和 <code>strict</code>，同时还接受值 <code>true</code>（等同于 <code>strict</code>）和 <code>false</code>（等同于 <code>ignore</code>）。<code>kubectl</code> 的默认验证设置为 <code>--validate=true</code>。</p>
<ul>
<li><strong>Strict</strong> 严格的字段验证，验证失败时会报错</li>
<li><strong>Warn</strong> 执行字段验证，但错误会以警告形式提供而不是拒绝请求</li>
<li><strong>Ignore</strong> 不执行服务器端字段验证</li>
</ul>
<p>当 <code>kubectl</code> 无法连接到支持字段验证的 API 服务器时，它将回退为使用客户端验证。 Kubernetes 1.27 及更高版本始终提供字段验证；较早的 Kubernetes 版本可能没有此功能。 如果集群版本低于 v1.27，可以查阅适用的 Kubernetes 版本的文档。</p>
<h4 id="Kubernetes-对象管理"><a href="#Kubernetes-对象管理" class="headerlink" title="Kubernetes 对象管理"></a>Kubernetes 对象管理</h4><p><code>kubectl</code> 命令行工具支持多种不同的方式来创建和管理 Kubernetes 对象。阅读 <a target="_blank" rel="noopener" href="https://kubectl.docs.kubernetes.io/zh/">Kubectl book</a> 来了解 kubectl 管理对象的详细信息。</p>
<blockquote>
<p>警告：<br>应该只使用一种技术来管理 Kubernetes 对象。混合和匹配技术作用在同一对象上将导致未定义行为。</p>
</blockquote>
<table>
<thead>
<tr>
<th>管理技术</th>
<th>作用于</th>
<th>建议的环境</th>
<th>支持的写者</th>
<th>学习难度</th>
</tr>
</thead>
<tbody><tr>
<td>指令式命令</td>
<td>活跃对象</td>
<td>开发项目</td>
<td>1+</td>
<td>最低</td>
</tr>
<tr>
<td>指令式对象配置</td>
<td>单个文件</td>
<td>生产项目</td>
<td>1</td>
<td>中等</td>
</tr>
<tr>
<td>声明式对象配置</td>
<td>文件目录</td>
<td>生产项目</td>
<td>1+</td>
<td>最高</td>
</tr>
</tbody></table>
<h5 id="指令式命令-Imperative-Commands"><a href="#指令式命令-Imperative-Commands" class="headerlink" title="指令式命令 (Imperative Commands)"></a>指令式命令 (Imperative Commands)</h5><p><strong>直接执行操作，不依赖配置文件。</strong> 使用指令式命令时，用户可以在集群中的活动对象上进行操作。用户将操作传给 <code>kubectl</code> 命令作为参数或标志。</p>
<p>这是开始或者在集群中运行一次性任务的推荐方法。因为这个技术直接在活跃对象 上操作，所以它不提供以前配置的历史记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建资源</span></span><br><span class="line">kubectl run nginx --image=nginx:1.14.2 --replicas=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新资源</span></span><br><span class="line">kubectl scale deployment nginx --replicas=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除资源</span></span><br><span class="line">kubectl delete deployment nginx</span><br></pre></td></tr></table></figure>
<p><strong>对比：</strong><br>与对象配置相比的优点：</p>
<ul>
<li>命令用单个动词表示。</li>
<li>命令仅需一步即可对集群进行更改。</li>
</ul>
<p>与对象配置相比的缺点：</p>
<ul>
<li>命令不与变更审查流程集成。</li>
<li>命令不提供与更改关联的审核跟踪。</li>
<li>除了实时内容外，命令不提供记录源。</li>
<li>命令不提供用于创建新对象的模板。</li>
</ul>
<h5 id="指令式对象配置-Imperative-Object-Configuration"><a href="#指令式对象配置-Imperative-Object-Configuration" class="headerlink" title="指令式对象配置 (Imperative Object Configuration)"></a>指令式对象配置 (Imperative Object Configuration)</h5><p><strong>使用配置文件，但明确指定操作类型。</strong> 在指令式对象配置中，<code>kubectl</code> 命令指定操作（创建，替换等），可选标志和至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。</p>
<p>有关对象定义的详细信息，请查看 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.34/">API 参考</a>。</p>
<blockquote>
<p>警告：<br><code>replace</code> 指令式命令将现有规范替换为新提供的规范，并放弃对配置文件中 缺少的对象的所有更改。此方法不应与对象规约被独立于配置文件进行更新的 资源类型一起使用。比如类型为 <code>LoadBalancer</code> 的服务，它的 <code>externalIPs</code> 字段就是独立于集群配置进行更新。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 明确指定操作类型</span></span><br><span class="line">kubectl create -f nginx-deployment.yaml    <span class="comment"># 只能创建，已存在会报错</span></span><br><span class="line">kubectl replace -f nginx-deployment.yaml   <span class="comment"># 只能替换，不存在会报错</span></span><br><span class="line">kubectl delete -f nginx-deployment.yaml    <span class="comment"># 删除指定资源</span></span><br></pre></td></tr></table></figure>

<p><strong>对比：</strong><br>与指令式命令相比的优点：</p>
<ul>
<li>对象配置可以存储在源控制系统中，比如 Git。</li>
<li>对象配置可以与流程集成，例如在推送和审计之前检查更新。</li>
<li>对象配置提供了用于创建新对象的模板。</li>
</ul>
<p>与指令式命令相比的缺点：</p>
<ul>
<li>对象配置需要对对象架构有基本的了解。</li>
<li>对象配置需要额外的步骤来编写 YAML 文件。</li>
</ul>
<p>与声明式对象配置相比的优点：</p>
<ul>
<li>指令式对象配置行为更加简单易懂。</li>
<li>从 Kubernetes 1.5 版本开始，指令对象配置更加成熟。</li>
</ul>
<p>与声明式对象配置相比的缺点：</p>
<ul>
<li>指令式对象配置更适合文件，而非目录。</li>
<li>对活动对象的更新必须反映在配置文件中，否则会在下一次替换时丢失。</li>
</ul>
<h5 id="声明式对象配置-Declarative-Object-Configuration"><a href="#声明式对象配置-Declarative-Object-Configuration" class="headerlink" title="声明式对象配置 (Declarative Object Configuration)"></a>声明式对象配置 (Declarative Object Configuration)</h5><p><strong>不关心操作类型，只关心最终状态。</strong>  使用声明式对象配置时，用户对本地存储的对象配置文件进行操作，但是用户未定义要对该文件执行的操作。 · 会自动检测每个文件的创建、更新和删除操作。 这使得配置可以在目录上工作，根据目录中配置文件对不同的对象执行不同的操作。</p>
<blockquote>
<p>说明：<br>声明式对象配置保留其他编写者所做的修改，即使这些更改并未合并到对象配置文件中。 可以通过使用 <code>patch</code> API 操作仅写入观察到的差异，而不是使用 <code>replace</code> API 操作来替换整个对象配置来实现。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 diff 子命令查看将要进行的更改，然后在进行应用</span></span><br><span class="line">kubectl diff -f configs/</span><br><span class="line">kubectl apply -f configs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归处理目录：</span></span><br><span class="line">kubectl diff -R -f configs/</span><br><span class="line">kubectl apply -R -f configs/</span><br></pre></td></tr></table></figure>

<p><strong>对比：</strong><br>与指令式对象配置相比的优点：</p>
<ul>
<li>对活动对象所做的更改即使未合并到配置文件中，也会被保留下来。</li>
<li>声明性对象配置更好地支持对目录进行操作并自动检测每个文件的操作类型（创建，修补，删除）。</li>
</ul>
<p>与指令式对象配置相比的缺点：</p>
<ul>
<li>声明式对象配置难于调试并且出现异常时结果难以理解。</li>
<li>使用 diff 产生的部分更新会创建复杂的合并和补丁操作。</li>
</ul>
<p><strong>实际执行对比</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指令式：必须知道当前状态和要执行的操作</span></span><br><span class="line"><span class="keyword">if</span> resource_exists; <span class="keyword">then</span></span><br><span class="line">  kubectl replace -f config.yaml</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  kubectl create -f config.yaml</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明式：不需要知道当前状态</span></span><br><span class="line">kubectl apply -f config.yaml  <span class="comment"># 自动判断创建或更新</span></span><br></pre></td></tr></table></figure>

<p><strong>混合使用模式</strong><br>在实际工作中，常常混合使用两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用声明式管理核心应用</span></span><br><span class="line">kubectl apply -f production/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用指令式进行临时操作</span></span><br><span class="line">kubectl scale deployment frontend --replicas=10  <span class="comment"># 应对流量高峰</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用指令式进行调试</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it frontend-pod -- bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 回到声明式管理</span></span><br><span class="line">kubectl apply -f production/  <span class="comment"># 恢复标准配置</span></span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><table>
<thead>
<tr>
<th>特性</th>
<th>指令式对象配置</th>
<th>声明式对象配置</th>
</tr>
</thead>
<tbody><tr>
<td>操作方式</td>
<td><code>create/replace/delete</code></td>
<td><code>apply</code></td>
</tr>
<tr>
<td>幂等性</td>
<td>❌ 非幂等</td>
<td>✅ 幂等</td>
</tr>
<tr>
<td>状态感知</td>
<td>需要知道当前状态</td>
<td>自动感知状态</td>
</tr>
<tr>
<td>复杂度</td>
<td>简单操作</td>
<td>复杂变更</td>
</tr>
<tr>
<td>版本控制</td>
<td>有限支持</td>
<td>✅ 完整支持</td>
</tr>
<tr>
<td>学习曲线</td>
<td>简单直观</td>
<td>需要理解控制器概念</td>
</tr>
</tbody></table>
<p><strong>推荐策略：</strong> </p>
<ul>
<li><strong>生产环境、团队协作</strong>：使用声明式</li>
<li><strong>临时操作、调试探索</strong>：使用指令式</li>
<li><strong>自动化脚本：根据场景选择</strong>，优先声明式</li>
</ul>
<h4 id="对象名称和-ID"><a href="#对象名称和-ID" class="headerlink" title="对象名称和 ID"></a>对象名称和 ID</h4><p>集群中的每一个对象都有一个名称来标识在同类资源中的唯一性。</p>
<p>每个 Kubernetes 对象也有一个 UID 来标识在整个集群中的唯一性。</p>
<p>比如，在同一个名字空间 中只能有一个名为 <code>myapp-1234</code> 的 Pod，但是可以命名一个 Pod 和一个 Deployment 同为 <code>myapp-1234</code>。</p>
<p>对于用户提供的非唯一性的属性，Kubernetes 提供了 <strong>标签（Label）</strong> 和 <strong>注解（Annotation）</strong> 机制。</p>
<h5 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h5><p>客户端提供的字符串，引用资源 URL 中的对象，如<code>/api/v1/pods/some name</code>。</p>
<p>某一时刻，只能有一个给定类型的对象具有给定的名称。但是，如果删除该对象，则可以创建同名的新对象。</p>
<p><strong>名称在同一资源的所有 API 版本中必须是唯一的。 这些 API 资源通过各自的 API 组、资源类型、名字空间（对于划分名字空间的资源）和名称来区分。 换言之，API 版本在此上下文中是不相关的。</strong></p>
<blockquote>
<p>说明：<br>当对象所代表的是一个物理实体（例如代表一台物理主机的 Node）时， 如果在 Node 对象未被删除并重建的条件下，重新创建了同名的物理主机， 则 Kubernetes 会将新的主机看作是老的主机，这可能会带来某种不一致性。</p>
</blockquote>
<p>当在资源创建请求中提供 <code>generateName</code> 而不是 <code>name</code> 时，服务器可能会生成一个名称。 使用 <code>generateName</code> 时，所提供的值将作为名称前缀，服务器会在其后附加一个生成的后缀。 即使名称是自动生成的，它仍可能与现有名称冲突，从而导致 HTTP 409 响应。 从 Kubernetes v1.31 及更高版本开始，这种情况发生的概率大大降低， 因为服务器会尝试最多 8 次生成唯一名称，然后才返回 HTTP 409 响应。</p>
<h6 id="DNS-子域名"><a href="#DNS-子域名" class="headerlink" title="DNS 子域名"></a>DNS 子域名</h6><p>很多资源类型需要可以用作 DNS 子域名的名称。 DNS 子域名的定义可参见 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1123">RFC 1123</a>。 这一要求意味着名称必须满足如下规则：</p>
<ul>
<li>不能超过 253 个字符</li>
<li>只能包含小写字母、数字，以及 ‘-‘ 和 ‘.’</li>
<li>必须以字母数字开头</li>
<li>必须以字母数字结尾</li>
</ul>
<h6 id="RFC-1123-标签名"><a href="#RFC-1123-标签名" class="headerlink" title="RFC 1123 标签名"></a>RFC 1123 标签名</h6><p>某些资源类型需要其名称遵循 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1123">RFC 1123</a> 所定义的 DNS 标签标准。也就是命名必须满足如下规则：</p>
<ul>
<li>最多 63 个字符</li>
<li>只能包含小写字母、数字，以及 ‘-‘</li>
<li>必须以字母开头</li>
<li>必须以字母数字结尾</li>
</ul>
<blockquote>
<p>注意：<br>启用 <code>RelaxedServiceNameValidation</code> 功能门控后，服务对象名称可以以数字开头。</p>
</blockquote>
<h6 id="RFC-1035-标签名"><a href="#RFC-1035-标签名" class="headerlink" title="RFC 1035 标签名"></a>RFC 1035 标签名</h6><p>某些资源类型需要其名称遵循 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035</a> 所定义的 DNS 标签标准。也就是命名必须满足如下规则：</p>
<ul>
<li>最多 63 个字符</li>
<li>只能包含小写字母、数字，以及 ‘-‘</li>
<li>必须以字母开头</li>
<li>必须以字母数字结尾</li>
</ul>
<blockquote>
<p>注意：<br>虽然 RFC 1123 从技术上允许标签以数字开头，但当前的 Kubernetes 实现要求 RFC 1035 和 RFC 1123 标签均以字母开头。例外情况是，当<code>RelaxedServiceNameValidation</code> 为服务对象启用特性门控时，允许服务名称以数字开头。</p>
</blockquote>
<h6 id="路径分段名称"><a href="#路径分段名称" class="headerlink" title="路径分段名称"></a>路径分段名称</h6><p>某些资源类型要求名称能被安全地用作路径中的片段。 换句话说，其名称不能是 <code>.</code>、<code>..</code>，也不可以包含 <code>/</code> 或<code>%</code> 这些字符。</p>
<p>下面是一个名为 <code>nginx-demo</code> 的 Pod 的配置清单：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<br>某些资源类型可能具有额外的命名约束。</p>
</blockquote>
<h5 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h5><p>Kubernetes 系统生成的字符串，唯一标识对象。</p>
<p>在 Kubernetes 集群的整个生命周期中创建的每个对象都有一个不同的 UID，它旨在区分类似实体的历史事件。</p>
<p>Kubernetes UID 是全局唯一标识符（也叫 UUID）。 UUID 是标准化的，见 ISO&#x2F;IEC 9834-8 和 ITU-T X.667。</p>
<h4 id="标签和选择算符"><a href="#标签和选择算符" class="headerlink" title="标签和选择算符"></a>标签和选择算符</h4><p><strong>标签（Labels）</strong> 是附加到 Kubernetes 对象（比如 Pod）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键&#x2F;值标签。每个键对于给定对象必须是唯一的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;metadata&quot;:</span> &#123;</span><br><span class="line">  <span class="attr">&quot;labels&quot;:</span> &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span> <span class="string">:</span> <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span> <span class="string">:</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标签能够支持高效的查询和监听操作，对于用户界面和命令行是很理想的。 应使用 <strong>注解</strong> 记录非识别信息。</p>
<h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><p>标签使用户能够以松散耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射。</p>
<p>服务部署和批处理流水线通常是多维实体（例如，多个分区或部署、多个发行序列、多个层，每层多个微服务）。 管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。</p>
<p>示例标签：</p>
<ul>
<li><code>&quot;release&quot; : &quot;stable&quot;</code>, <code>&quot;release&quot; : &quot;canary&quot;</code></li>
<li><code>&quot;environment&quot; : &quot;dev&quot;</code>, <code>&quot;environment&quot; : &quot;qa&quot;</code>, <code>&quot;environment&quot; : &quot;production&quot;</code></li>
<li><code>&quot;tier&quot; : &quot;frontend&quot;</code>, <code>&quot;tier&quot; : &quot;backend&quot;</code>, <code>&quot;tier&quot; : &quot;cache&quot;</code></li>
<li><code>&quot;partition&quot; : &quot;customerA&quot;</code>, <code>&quot;partition&quot; : &quot;customerB&quot;</code></li>
<li><code>&quot;track&quot; : &quot;daily&quot;</code>, <code>&quot;track&quot; : &quot;weekly&quot;</code></li>
</ul>
<p>有一些<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/">常用标签</a>的例子；可以任意制定自己的约定。注意： <strong>标签的 Key 对于给定对象必须是唯一的。</strong></p>
<h5 id="语法和字符集"><a href="#语法和字符集" class="headerlink" title="语法和字符集"></a>语法和字符集</h5><p><strong>标签</strong> 是键值对。有效的标签键有两个段：可选的前缀和名称，用斜杠（<code>/</code>）分隔。 名称段是必需的，必须小于等于 63 个字符，以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾， 带有破折号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>）和之间的字母数字。 前缀是可选的。如果指定，前缀必须是 DNS 子域：由点（<code>.</code>）分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠（<code>/</code>）。</p>
<p>如果省略前缀，则假定标签键对用户是私有的。 向最终用户对象添加标签的自动系统组件（例如 <code>kube-scheduler</code>、<code>kube-controller-manager</code>、 <code>kube-apiserver</code>、<code>kubectl</code> 或其他第三方自动化工具）必须指定前缀。</p>
<p><code>kubernetes.io/</code> 和 <code>k8s.io/</code> 前缀是为 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/">Kubernetes 核心组件保留的</a>。</p>
<p>有效标签值：</p>
<ul>
<li>必须为 63 个字符或更少（可以为空）</li>
<li>除非标签值为空，必须以字母数字字符（<code>[a-z0-9A-Z]</code>）开头和结尾</li>
<li>包含破折号（<code>-</code>）、下划线（<code>_</code>）、点（<code>.</code>）和字母或数字</li>
</ul>
<p>例如，以下是一个清单 (manifest)，适用于具有 <code>environment: production</code> 和 <code>app: nginx</code> 这两个标签的 Pod：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">label-demo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">production</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>







</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xiangnan321.github.io">South</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xiangnan321.github.io/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/">https://xiangnan321.github.io/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xiangnan321.github.io" target="_blank">Hi</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/image/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/09/24/Docker-Compose%E3%80%81Docker-Swarm-%E4%B8%8E-Kubernetes-K8s-%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Docker Compose、Docker Swarm 与 Kubernetes (K8s) 的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Docker Compose、Docker Swarm 与 Kubernetes (K8s) 的区别</div></div><div class="info-2"><div class="info-item-1">Docker Swarm、Docker Compose 和 Kubernetes 是容器编排领域三个关键的工具，它们定位不同，适用于不同的场景。 简单比喻：  Docker Compose：像是一个音响系统的遥控器。可以在一个房间（一台机器）里，一键控制多个音响设备（多个容器）的开关、音量，让它们协同工作。管理单机。 Docker Swarm：像是一个大型商场的中央广播系统。有一个控制中心，可以同时向商场里的所有分区（多台机器）发布指令，让整个商场的背景音乐同步。内置的、简单的集群管理。 Kubernetes (K8s)：像是整个城市的交通指挥中心。它管理着成千上万辆汽车（容器），自动处理交通拥堵（负载均衡）、车辆故障（自愈）、新建道路（自动扩缩容），确保城市交通高效、可靠。企业级的、复杂的集群管理。  Docker Compose - 编排工具（单机）核心定位：定义和运行多个容器的单机应用。  工作范围：单台主机。它无法管理多台机器组成的集群。 主要功能：通过一个 docker-compose.yml 文件，定义一组相关联的服务（容器）、它们的依赖关系、网络、数据卷等。然后用一...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">South</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s-%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">k8s 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">Kubernetes 不是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">Kubernetes 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kubernetes-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">Kubernetes 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%84%E7%BA%A6%EF%BC%88Spec%EF%BC%89%E4%B8%8E%E7%8A%B6%E6%80%81%EF%BC%88Status%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">对象规约（Spec）与状态（Status）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0-Kubernetes-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">描述 Kubernetes 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E9%9C%80%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.3.</span> <span class="toc-text">必需字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AD%97%E6%AE%B5%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.4.</span> <span class="toc-text">服务器端字段验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kubernetes-%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.5.</span> <span class="toc-text">Kubernetes 对象管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%BC%8F%E5%91%BD%E4%BB%A4-Imperative-Commands"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">指令式命令 (Imperative Commands)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%BC%8F%E5%AF%B9%E8%B1%A1%E9%85%8D%E7%BD%AE-Imperative-Object-Configuration"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">指令式对象配置 (Imperative Object Configuration)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%B9%E8%B1%A1%E9%85%8D%E7%BD%AE-Declarative-Object-Configuration"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">声明式对象配置 (Declarative Object Configuration)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%90%8D%E7%A7%B0%E5%92%8C-ID"><span class="toc-number">1.4.6.</span> <span class="toc-text">对象名称和 ID</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">名称</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#DNS-%E5%AD%90%E5%9F%9F%E5%90%8D"><span class="toc-number">1.4.6.1.1.</span> <span class="toc-text">DNS 子域名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RFC-1123-%E6%A0%87%E7%AD%BE%E5%90%8D"><span class="toc-number">1.4.6.1.2.</span> <span class="toc-text">RFC 1123 标签名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RFC-1035-%E6%A0%87%E7%AD%BE%E5%90%8D"><span class="toc-number">1.4.6.1.3.</span> <span class="toc-text">RFC 1035 标签名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%88%86%E6%AE%B5%E5%90%8D%E7%A7%B0"><span class="toc-number">1.4.6.1.4.</span> <span class="toc-text">路径分段名称</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UID"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">UID</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E5%92%8C%E9%80%89%E6%8B%A9%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.7.</span> <span class="toc-text">标签和选择算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">动机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">语法和字符集</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/13/Kubernetes%E5%AD%A6%E4%B9%A0/" title="Kubernetes学习">Kubernetes学习</a><time datetime="2025-10-13T06:30:41.000Z" title="发表于 2025-10-13 14:30:41">2025-10-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/24/Docker-Compose%E3%80%81Docker-Swarm-%E4%B8%8E-Kubernetes-K8s-%E7%9A%84%E5%8C%BA%E5%88%AB/" title="Docker Compose、Docker Swarm 与 Kubernetes (K8s) 的区别">Docker Compose、Docker Swarm 与 Kubernetes (K8s) 的区别</a><time datetime="2025-09-24T07:05:21.000Z" title="发表于 2025-09-24 15:05:21">2025-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/02/Docker%E5%AD%A6%E4%B9%A0/" title="Docker学习">Docker学习</a><time datetime="2025-09-02T08:18:48.000Z" title="发表于 2025-09-02 16:18:48">2025-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/15/js%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" title="js数组与字符串的方法总结">js数组与字符串的方法总结</a><time datetime="2025-08-15T10:25:58.000Z" title="发表于 2025-08-15 18:25:58">2025-08-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/13/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="go语言学习">go语言学习</a><time datetime="2025-08-13T03:08:23.000Z" title="发表于 2025-08-13 11:08:23">2025-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By South</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>